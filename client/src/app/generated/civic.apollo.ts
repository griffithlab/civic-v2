/* eslint-disable */
import { gql } from 'apollo-angular';
import { Injectable } from '@angular/core';
import * as Apollo from 'apollo-angular';
import { AppModule } from '../app.module';
export type Maybe<T> = T | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};



/** Autogenerated input type of AcceptRevision */
export type AcceptRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Body of an optional comment to attach to the revision on acceptance. */
  comment?: Maybe<Scalars['String']>;
  /** The ID of the Revision to accept. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of AcceptRevision */
export type AcceptRevisionPayload = {
  __typename: 'AcceptRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly accepted Revision. */
  revision: Revision;
  /** A list of any revisions that were superseded by the acceptance of this one. */
  supersededRevisions: Array<Revision>;
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** Text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The commentable to attach the comment to. Specified by ID and Type. */
  subject: CommentableInput;
  /** Optional title for the comment. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddComment */
export type AddCommentPayload = {
  __typename: 'AddCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<Comment>;
};

export type AdvancedSearchResult = {
  __typename: 'AdvancedSearchResult';
  permalinkId?: Maybe<Scalars['String']>;
  resultIds: Array<Scalars['Int']>;
  searchEndpoint: Scalars['String'];
};

export enum BooleanOperator {
  And = 'AND',
  Or = 'OR'
}

export type BooleanSearchInput = {
  value: Scalars['Boolean'];
};

export type BrowseGene = {
  __typename: 'BrowseGene';
  aliases?: Maybe<Array<GeneAlias>>;
  assertionCount: Scalars['Int'];
  description: Scalars['String'];
  diseases?: Maybe<Array<Disease>>;
  drugs?: Maybe<Array<Drug>>;
  entrezId: Scalars['Int'];
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseGene. */
export type BrowseGeneConnection = {
  __typename: 'BrowseGeneConnection';
  /** A list of edges. */
  edges: Array<BrowseGeneEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseGene>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseGeneEdge = {
  __typename: 'BrowseGeneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseGene>;
};

export type ClinicalTrial = {
  __typename: 'ClinicalTrial';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nctId: Scalars['String'];
};

export type Comment = EventOriginObject & {
  __typename: 'Comment';
  comment: Scalars['String'];
  commenter: User;
  createdAt: Scalars['ISO8601DateTime'];
  creationEvent?: Maybe<Event>;
  id: Scalars['Int'];
  name: Scalars['String'];
  title?: Maybe<Scalars['String']>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename: 'CommentConnection';
  /** A list of edges. */
  edges: Array<CommentEdge>;
  /** A list of nodes. */
  nodes: Array<Comment>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have commented on this entity. */
  uniqueCommenters: Array<User>;
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

/** A CIViC entity that can have comments on it. */
export type Commentable = {
  /** List and filter comments. */
  comments: CommentConnection;
};


/** A CIViC entity that can have comments on it. */
export type CommentableCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum CommentableEntities {
  Gene = 'GENE'
}

/** Entity to comment on */
export type CommentableInput = {
  /** The type of the entity to comment on. */
  entityType: CommentableEntities;
  /** ID of the entity to comment on. */
  id: Scalars['Int'];
};

export type DateSort = {
  /** Value to sort by. */
  column: DateSortColumns;
  /** Sort direction. */
  direction: SortDirection;
};

export enum DateSortColumns {
  Created = 'CREATED',
  LastModified = 'LAST_MODIFIED'
}

export type Disease = {
  __typename: 'Disease';
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  name: Scalars['String'];
};

export type Drug = {
  __typename: 'Drug';
  drugUrl?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

export enum DrugInteraction {
  Combination = 'COMBINATION',
  Sequential = 'SEQUENTIAL',
  Substitutes = 'SUBSTITUTES'
}

export type Event = {
  __typename: 'Event';
  action: EventAction;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['Int'];
  organization: Organization;
  originatingObject?: Maybe<EventOriginObject>;
  originatingUser: User;
  subject: EventSubject;
};

export enum EventAction {
  Accepted = 'ACCEPTED',
  AssertionAccepted = 'ASSERTION_ACCEPTED',
  AssertionRejected = 'ASSERTION_REJECTED',
  AssertionSubmitted = 'ASSERTION_SUBMITTED',
  Commented = 'COMMENTED',
  Flagged = 'FLAGGED',
  FlagResolved = 'FLAG_RESOLVED',
  PublicationSuggested = 'PUBLICATION_SUGGESTED',
  Rejected = 'REJECTED',
  Reverted = 'REVERTED',
  RevisionAccepted = 'REVISION_ACCEPTED',
  RevisionRejected = 'REVISION_REJECTED',
  RevisionSuggested = 'REVISION_SUGGESTED',
  RevisionSuperseded = 'REVISION_SUPERSEDED',
  Submitted = 'SUBMITTED'
}

/** The connection type for Event. */
export type EventConnection = {
  __typename: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** List of event types that have occured on this entity. */
  eventTypes: Array<EventAction>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** List of all organizations who are involved in this event stream. */
  participatingOrganizations: Array<Organization>;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have generated an event on the subject entity. */
  uniqueParticipants: Array<User>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/**
 * The originating object for an event.
 * This is useful when the subject of an event is not the actual origin of the event.
 * For instance when you suggest a revision, the subject of the Event will be the entity being revised,
 * while the originating object will be the Revision itself.
 */
export type EventOriginObject = {
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** The subject of an event log event. */
export type EventSubject = {
  /** List and filter events for an object */
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
};


/** The subject of an event log event. */
export type EventSubjectEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum EvidenceClinicalSignificance {
  AdverseResponse = 'ADVERSE_RESPONSE',
  Benign = 'BENIGN',
  BetterOutcome = 'BETTER_OUTCOME',
  DominantNegative = 'DOMINANT_NEGATIVE',
  GainOfFunction = 'GAIN_OF_FUNCTION',
  LikelyBenign = 'LIKELY_BENIGN',
  LikelyPathogenic = 'LIKELY_PATHOGENIC',
  LossOfFunction = 'LOSS_OF_FUNCTION',
  Na = 'NA',
  Negative = 'NEGATIVE',
  Neomorphic = 'NEOMORPHIC',
  Pathogenic = 'PATHOGENIC',
  PoorOutcome = 'POOR_OUTCOME',
  Positive = 'POSITIVE',
  ReducedSensitivity = 'REDUCED_SENSITIVITY',
  Resistance = 'RESISTANCE',
  Sensitivityresponse = 'SENSITIVITYRESPONSE',
  UnalteredFunction = 'UNALTERED_FUNCTION',
  UncertainSignificance = 'UNCERTAIN_SIGNIFICANCE',
  Unknown = 'UNKNOWN'
}

export enum EvidenceDirection {
  DoesNotSupport = 'DOES_NOT_SUPPORT',
  Na = 'NA',
  Supports = 'SUPPORTS'
}

export type EvidenceItem = Commentable & Flaggable & {
  __typename: 'EvidenceItem';
  clinicalSignificance: EvidenceClinicalSignificance;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  disease?: Maybe<Disease>;
  drugInteractionType?: Maybe<DrugInteraction>;
  drugs?: Maybe<Array<Drug>>;
  events: EventConnection;
  evidenceDirection: EvidenceDirection;
  evidenceLevel: EvidenceLevel;
  evidenceRating?: Maybe<Scalars['Int']>;
  evidenceType: EvidenceType;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  phenotypes?: Maybe<Array<Phenotype>>;
  revisions: Array<Revision>;
  source: Source;
  status: EvidenceStatus;
  variant: Variant;
  variantHgvs: Scalars['String'];
  variantOrigin: VariantOrigin;
};


export type EvidenceItemCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type EvidenceItemEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type EvidenceItemFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};

/** The connection type for EvidenceItem. */
export type EvidenceItemConnection = {
  __typename: 'EvidenceItemConnection';
  /** A list of edges. */
  edges: Array<EvidenceItemEdge>;
  /** A list of nodes. */
  nodes: Array<EvidenceItem>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type EvidenceItemEdge = {
  __typename: 'EvidenceItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EvidenceItem>;
};

export enum EvidenceLevel {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  E = 'E'
}

export enum EvidenceStatus {
  Accepted = 'ACCEPTED',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export enum EvidenceType {
  Diagnostic = 'DIAGNOSTIC',
  Functional = 'FUNCTIONAL',
  Oncogenic = 'ONCOGENIC',
  Predictive = 'PREDICTIVE',
  Predisposing = 'PREDISPOSING',
  Prognostic = 'PROGNOSTIC'
}

export type FieldName = {
  __typename: 'FieldName';
  /** The user facing representation of the field name. */
  displayName: Scalars['String'];
  /** The internal server representation of the field name. */
  name: Scalars['String'];
};

export type Flag = Commentable & EventOriginObject & {
  __typename: 'Flag';
  /** List and filter comments. */
  comments: CommentConnection;
  flaggingUser: User;
  id: Scalars['Int'];
  name: Scalars['String'];
  resolvingUser?: Maybe<User>;
  state: FlagState;
};


export type FlagCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** The connection type for Flag. */
export type FlagConnection = {
  __typename: 'FlagConnection';
  /** A list of edges. */
  edges: Array<FlagEdge>;
  /** A list of nodes. */
  nodes: Array<Flag>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type FlagEdge = {
  __typename: 'FlagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Flag>;
};

/** Autogenerated input type of FlagEntity */
export type FlagEntityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the problem you observed with this entity. */
  comment: Scalars['String'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The entity to flag, specified by its ID and type. */
  subject: FlaggableInput;
};

/** Autogenerated return type of FlagEntity */
export type FlagEntityPayload = {
  __typename: 'FlagEntityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created Flag. */
  flag?: Maybe<Flag>;
};

export enum FlagState {
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

/** A CIViC entity that can be flagged for editor attention. */
export type Flaggable = {
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
};


/** A CIViC entity that can be flagged for editor attention. */
export type FlaggableFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};

/** Enumeration of all entities in CIViC that can be flagged. */
export enum FlaggableEntities {
  Gene = 'GENE'
}

/** Entity to flag */
export type FlaggableInput = {
  /** The type of the entity to flag. */
  entityType: FlaggableEntities;
  /** The ID of the entity. */
  id: Scalars['Int'];
};

export type Gene = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Gene';
  aliases: Array<GeneAlias>;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  entrezId: Scalars['Int'];
  /** List and filter events for an object */
  events: EventConnection;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  lifecycleActions: Lifecycle;
  myGeneInfoDetails?: Maybe<Scalars['JSON']>;
  name: Scalars['String'];
  officialName: Scalars['String'];
  /** List and filter revisions. */
  revisions: RevisionConnection;
  sources: Array<Source>;
  variants: VariantConnection;
};


export type GeneCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type GeneEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type GeneFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type GeneRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};


export type GeneVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type GeneAlias = {
  __typename: 'GeneAlias';
  name: Scalars['String'];
};

export type GeneFields = {
  /** The Gene's description/summary text. */
  description: Scalars['String'];
  /** Source IDs cited by the Gene's summary. */
  sourceIds: Array<Scalars['Int']>;
};

export type GeneSearchFilter = {
  alias?: Maybe<StringSearchInput>;
  booleanOperator?: Maybe<BooleanOperator>;
  description?: Maybe<StringSearchInput>;
  entrezId?: Maybe<IntSearchInput>;
  entrezSymbol?: Maybe<StringSearchInput>;
  hasAssertion?: Maybe<BooleanSearchInput>;
  id?: Maybe<IntSearchInput>;
  openRevisionCount?: Maybe<IntSearchInput>;
  subFilters?: Maybe<Array<GeneSearchFilter>>;
};

export type GenesSort = {
  /** Available columns for sorting */
  column: GenesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum GenesSortColumns {
  AssertionCount = 'assertionCount',
  DiseaseName = 'diseaseName',
  DrugName = 'drugName',
  EntrezSymbol = 'entrezSymbol',
  EvidenceItemCount = 'evidenceItemCount',
  GeneAlias = 'geneAlias',
  VariantCount = 'variantCount'
}


export type IntSearchInput = {
  comparisonOperator: IntSearchOperator;
  value: Scalars['Int'];
};

export enum IntSearchOperator {
  /** Equal To */
  Eq = 'EQ',
  Ge = 'GE',
  Gt = 'GT',
  Le = 'LE',
  Lt = 'LT',
  Ne = 'NE'
}


export type Lifecycle = {
  __typename: 'Lifecycle';
  lastCommentedOn?: Maybe<Event>;
  lastModified?: Maybe<Event>;
  lastReviewed?: Maybe<Event>;
};

export type LinkoutData = {
  __typename: 'LinkoutData';
  currentValue: ModeratedField;
  diffValue: ModeratedFieldDiff;
  name: Scalars['String'];
  suggestedValue: ModeratedField;
};

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more Notification IDs. */
  ids: Array<Scalars['Int']>;
};

/** Autogenerated return type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadPayload = {
  __typename: 'MarkNotificationsAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of the notifications in their new state. */
  notifications: Array<Notification>;
};

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedField = ObjectField | ScalarField;

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedFieldDiff = ObjectFieldDiff | ScalarField;

export type ModeratedObjectField = {
  __typename: 'ModeratedObjectField';
  displayName: Scalars['String'];
  displayType: Scalars['String'];
  entityType: Scalars['String'];
  id: Scalars['Int'];
};

export type Mutation = {
  __typename: 'Mutation';
  /**
   * Accept a revision by ID. The accepting user must be an editor with a valid
   * conflict of interest statement on file and the revision must not be their own.
   */
  acceptRevision?: Maybe<AcceptRevisionPayload>;
  /** Add a comment to any commentable entity. */
  addComment?: Maybe<AddCommentPayload>;
  /** Flag an entity to signal to the editorial team that you believe there is an issue with it. */
  flagEntity?: Maybe<FlagEntityPayload>;
  /** Mark one or more of your notifications as read. The notification IDs provided must belong to the requesting user. */
  markNotificationsAsRead?: Maybe<MarkNotificationsAsReadPayload>;
  /**
   * Reject a revision by ID. Any user may reject a Revision that they submitted
   * themselves. Otherwise, the rejecting user must be an editor with valid
   * conflict of interest statement on file.
   */
  rejectRevision?: Maybe<RejectRevisionPayload>;
  /**
   * Resolve a flag on a CIViC entity indicating that it was either erronously flagged or the issue has been resolved.
   * Any user may resolve their own flag however only editors with valid conflict
   * of interest statements can resolve other flags.
   */
  resolveFlag?: Maybe<ResolveFlagPayload>;
  /** Subscribe to a CIViC entity in order to receive notifications about it. */
  subscribe?: Maybe<SubscribePayload>;
  /** Suggest a Revision to a Gene entity. */
  suggestGeneRevision?: Maybe<SuggestGeneRevisionPayload>;
  /** Unsubscribe from a CIViC entity to stop receiving notifications about it. */
  unsubscribe?: Maybe<UnsubscribePayload>;
};


export type MutationAcceptRevisionArgs = {
  input: AcceptRevisionInput;
};


export type MutationAddCommentArgs = {
  input: AddCommentInput;
};


export type MutationFlagEntityArgs = {
  input: FlagEntityInput;
};


export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput;
};


export type MutationRejectRevisionArgs = {
  input: RejectRevisionInput;
};


export type MutationResolveFlagArgs = {
  input: ResolveFlagInput;
};


export type MutationSubscribeArgs = {
  input: SubscribeInput;
};


export type MutationSuggestGeneRevisionArgs = {
  input: SuggestGeneRevisionInput;
};


export type MutationUnsubscribeArgs = {
  input: UnsubscribeInput;
};

export type Notification = {
  __typename: 'Notification';
  createdAt: Scalars['ISO8601DateTime'];
  event: Event;
  id: Scalars['Int'];
  notifiedUser: User;
  originatingUser: User;
  seen: Scalars['Boolean'];
  subscription?: Maybe<Subscription>;
  type: NotificationReason;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename: 'NotificationConnection';
  /** A list of edges. */
  edges: Array<NotificationEdge>;
  /** A list of nodes. */
  nodes: Array<Notification>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

export enum NotificationReason {
  Mention = 'MENTION',
  Subscription = 'SUBSCRIPTION'
}

export type ObjectField = {
  __typename: 'ObjectField';
  objects: Array<ModeratedObjectField>;
};

export type ObjectFieldDiff = {
  __typename: 'ObjectFieldDiff';
  addedObjects: Array<ModeratedObjectField>;
  keptObjects: Array<ModeratedObjectField>;
  removedObjects: Array<ModeratedObjectField>;
};

export type Organization = {
  __typename: 'Organization';
  description: Scalars['String'];
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
  profileImagePath?: Maybe<Scalars['String']>;
  url: Scalars['String'];
};


export type OrganizationEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type OrganizationProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Phenotype = {
  __typename: 'Phenotype';
  hpoClass: Scalars['String'];
  hpoId: Scalars['String'];
  id: Scalars['Int'];
};

export type Query = {
  __typename: 'Query';
  browseGenes: BrowseGeneConnection;
  /** List and filter comments. */
  comments: CommentConnection;
  /** Find a disease by CIViC ID */
  disease?: Maybe<Disease>;
  /** Find a drug by CIViC ID */
  drug?: Maybe<Drug>;
  /** List and filter events for an object */
  events: EventConnection;
  evidenceItem?: Maybe<EvidenceItem>;
  /** Find a gene by CIViC ID */
  gene?: Maybe<Gene>;
  /** Find an organization by CIViC ID */
  organization?: Maybe<Organization>;
  searchByPermalink: AdvancedSearchResult;
  searchGenes: AdvancedSearchResult;
  /** Find a source by CIViC ID */
  source?: Maybe<Source>;
  user?: Maybe<User>;
  viewer?: Maybe<User>;
};


export type QueryBrowseGenesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneAlias?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<GenesSort>;
};


export type QueryCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  subject?: Maybe<CommentableInput>;
};


export type QueryDiseaseArgs = {
  id: Scalars['Int'];
};


export type QueryDrugArgs = {
  id: Scalars['Int'];
};


export type QueryEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  subject?: Maybe<SubscribableInput>;
};


export type QueryEvidenceItemArgs = {
  id: Scalars['Int'];
};


export type QueryGeneArgs = {
  id: Scalars['Int'];
};


export type QueryOrganizationArgs = {
  id: Scalars['Int'];
};


export type QuerySearchByPermalinkArgs = {
  permalinkId: Scalars['String'];
};


export type QuerySearchGenesArgs = {
  createPermalink?: Maybe<Scalars['Boolean']>;
  query: GeneSearchFilter;
};


export type QuerySourceArgs = {
  id: Scalars['Int'];
};


export type QueryUserArgs = {
  userId: Scalars['Int'];
};

/** Autogenerated input type of RejectRevision */
export type RejectRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text explaining the reasoning for rejecting this Revision. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the Revision to reject. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of RejectRevision */
export type RejectRevisionPayload = {
  __typename: 'RejectRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The rejected Revision. */
  revision: Revision;
};

/** Autogenerated input type of ResolveFlag */
export type ResolveFlagInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for resolving the flag. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the flag to resolve. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of ResolveFlag */
export type ResolveFlagPayload = {
  __typename: 'ResolveFlagPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  flag?: Maybe<Flag>;
};

export type Revision = EventOriginObject & {
  __typename: 'Revision';
  comments: Array<Comment>;
  createdAt: Scalars['ISO8601DateTime'];
  creationEvent?: Maybe<Event>;
  currentValue: Scalars['JSON'];
  fieldName: Scalars['String'];
  id: Scalars['Int'];
  linkoutData: LinkoutData;
  name: Scalars['String'];
  revisionsetId: Scalars['String'];
  revisor: User;
  status: RevisionStatus;
  suggestedValue: Scalars['JSON'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Revision. */
export type RevisionConnection = {
  __typename: 'RevisionConnection';
  /** A list of edges. */
  edges: Array<RevisionEdge>;
  /** A list of nodes. */
  nodes: Array<Revision>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** List of all fields that have at least one revision. */
  revisedFieldNames: Array<FieldName>;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have submitted a revision to this entity. */
  uniqueRevisors: Array<User>;
};

/** An edge in a connection. */
export type RevisionEdge = {
  __typename: 'RevisionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Revision>;
};

export type RevisionResult = {
  __typename: 'RevisionResult';
  /** Name of the field on the moderated entity that the Revision pertains to. */
  fieldName: Scalars['String'];
  /** ID of the Revision. */
  id: Scalars['Int'];
  /** Was this Revision newly created as a result of this request? */
  newlyCreated: Scalars['Boolean'];
  /** An identifier that can be used to group Revisions proposed at the same time. */
  revisionsetId: Scalars['String'];
};

export enum RevisionStatus {
  Accepted = 'ACCEPTED',
  New = 'NEW',
  Rejected = 'REJECTED',
  Superseded = 'SUPERSEDED'
}

export type ScalarField = {
  __typename: 'ScalarField';
  value?: Maybe<Scalars['String']>;
};

export enum SortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type Source = {
  __typename: 'Source';
  ascoAbstractId?: Maybe<Scalars['Int']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials?: Maybe<Array<ClinicalTrial>>;
  fullJournalTitle: Scalars['String'];
  id: Scalars['Int'];
  journal: Scalars['String'];
  name: Scalars['String'];
  publicationDay?: Maybe<Scalars['Int']>;
  publicationMonth: Scalars['Int'];
  publicationYear: Scalars['Int'];
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
  status: SourceStatus;
};

export enum SourceSource {
  Asco = 'ASCO',
  PubMed = 'PubMed'
}

export enum SourceStatus {
  FullyCurated = 'FullyCurated',
  PartiallyCurated = 'PartiallyCurated',
  Submitted = 'Submitted'
}

export type StringSearchInput = {
  comparisonOperator: StringSearchOperator;
  value: Scalars['String'];
};

export enum StringSearchOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  Eq = 'EQ',
  Ne = 'NE',
  StartsWith = 'STARTS_WITH'
}

export type Subscribable = {
  __typename: 'Subscribable';
  entityType: SubscribableEntities;
  id: Scalars['Int'];
};

/** Enumeration of all subscribable CIViC entities. */
export enum SubscribableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  Variant = 'VARIANT'
}

/** Entity to subscribe to. */
export type SubscribableInput = {
  /** Type of subscribable entity. */
  entityType: SubscribableEntities;
  /** ID of subscribable entity. */
  id: Scalars['Int'];
};

/** Autogenerated input type of Subscribe */
export type SubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to subscribe to, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you want to subscribe to related child entities of the subscribed entities?
   * IE: If you subscribe to a Gene, do you want to receive notifications for its Variants as well?
   */
  subscribeToChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Subscribe */
export type SubscribePayload = {
  __typename: 'SubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created subscription objects. */
  subscriptions: Array<Subscription>;
};

export type Subscription = {
  __typename: 'Subscription';
  id: Scalars['Int'];
};

/** Autogenerated input type of SuggestGeneRevision */
export type SuggestGeneRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Gene's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: GeneFields;
  /** The ID of the Gene to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestGeneRevision */
export type SuggestGeneRevisionPayload = {
  __typename: 'SuggestGeneRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Gene the user has proposed a Revision to. */
  gene: Gene;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of Unsubscribe */
export type UnsubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to unsubscribe from, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you also wish to stop receiving notifications from child entities?
   * IE: If you unsubscribe from a Gene do you want to stop receiving notifications for its Variants as well?
   */
  unsubscribeFromChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Unsubscribe */
export type UnsubscribePayload = {
  __typename: 'UnsubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The entities that were unsubscribed from. */
  unsubscribedEntities: Array<Subscribable>;
};

export type User = {
  __typename: 'User';
  bio?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  email?: Maybe<Scalars['String']>;
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
  /** Filterable list of notifications for the logged in user. */
  notifications?: Maybe<NotificationConnection>;
  organizations: Array<Organization>;
  profileImagePath?: Maybe<Scalars['String']>;
  role: Scalars['String'];
  url?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};


export type UserEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type UserNotificationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  includeSeen?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  notificationType?: Maybe<NotificationReason>;
  subscriptionId?: Maybe<Scalars['Int']>;
};


export type UserProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

export type Variant = Commentable & Flaggable & {
  __typename: 'Variant';
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  events: EventConnection;
  evidenceItems: EvidenceItemConnection;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  id: Scalars['Int'];
  name: Scalars['String'];
};


export type VariantCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type VariantEvidenceItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type VariantFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};

/** The connection type for Variant. */
export type VariantConnection = {
  __typename: 'VariantConnection';
  /** A list of edges. */
  edges: Array<VariantEdge>;
  /** A list of nodes. */
  nodes: Array<Variant>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type VariantEdge = {
  __typename: 'VariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Variant>;
};

export enum VariantOrigin {
  CommonGermline = 'COMMON_GERMLINE',
  GermlineOrSomatic = 'GERMLINE_OR_SOMATIC',
  Na = 'NA',
  RareGermline = 'RARE_GERMLINE',
  Somatic = 'SOMATIC',
  Unknown = 'UNKNOWN'
}

/** A CIViC entity that can have revisions proposed to it. */
export type WithRevisions = {
  /** List and filter revisions. */
  revisions: RevisionConnection;
};


/** A CIViC entity that can have revisions proposed to it. */
export type WithRevisionsRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

export type GeneHoverCardQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GeneHoverCardQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & HovercardGeneFragment
  )> }
);

export type HovercardGeneFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'name' | 'officialName'>
  & { aliases: Array<(
    { __typename: 'GeneAlias' }
    & Pick<GeneAlias, 'name'>
  )>, variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
  ) }
);

export type AddCommentMutationVariables = Exact<{
  input: AddCommentInput;
}>;


export type AddCommentMutation = (
  { __typename: 'Mutation' }
  & { addComment?: Maybe<(
    { __typename: 'AddCommentPayload' }
    & Pick<AddCommentPayload, 'clientMutationId'>
    & { comment?: Maybe<(
      { __typename: 'Comment' }
      & CommentListNodeFragment
    )> }
  )> }
);

export type CommentListFragment = (
  { __typename: 'CommentConnection' }
  & Pick<CommentConnection, 'totalCount'>
  & { pageInfo: (
    { __typename: 'PageInfo' }
    & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
  ), edges: Array<(
    { __typename: 'CommentEdge' }
    & Pick<CommentEdge, 'cursor'>
    & { node?: Maybe<(
      { __typename: 'Comment' }
      & CommentListNodeFragment
    )> }
  )> }
);

export type CommentListNodeFragment = (
  { __typename: 'Comment' }
  & Pick<Comment, 'id' | 'title' | 'comment' | 'createdAt'>
  & { commenter: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'displayName' | 'name' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )> }
  ) }
);

export type CommentParticipantsFragment = (
  { __typename: 'CommentConnection' }
  & { uniqueCommenters: Array<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'profileImagePath'>
  )> }
);

export type EventFeedQueryVariables = Exact<{
  subject?: Maybe<SubscribableInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
}>;


export type EventFeedQuery = (
  { __typename: 'Query' }
  & { events: (
    { __typename: 'EventConnection' }
    & EventFeedFragment
  ) }
);

export type EventFeedFragment = (
  { __typename: 'EventConnection' }
  & Pick<EventConnection, 'eventTypes'>
  & { pageInfo: (
    { __typename: 'PageInfo' }
    & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
  ), uniqueParticipants: Array<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'profileImagePath'>
  )>, participatingOrganizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, edges: Array<(
    { __typename: 'EventEdge' }
    & Pick<EventEdge, 'cursor'>
    & { node?: Maybe<(
      { __typename: 'Event' }
      & EventFeedNodeFragment
    )> }
  )> }
);

export type EventFeedNodeFragment = (
  { __typename: 'Event' }
  & Pick<Event, 'id' | 'action' | 'createdAt'>
  & { organization: (
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  ), originatingUser: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'displayName' | 'profileImagePath'>
  ), subject: (
    { __typename: 'Gene' }
    & Pick<Gene, 'name' | 'id'>
  ), originatingObject?: Maybe<(
    { __typename: 'Comment' }
    & Pick<Comment, 'id' | 'comment' | 'name'>
  ) | (
    { __typename: 'Flag' }
    & Pick<Flag, 'id' | 'name'>
    & { comments: (
      { __typename: 'CommentConnection' }
      & { nodes: Array<(
        { __typename: 'Comment' }
        & Pick<Comment, 'comment' | 'createdAt'>
        & { commenter: (
          { __typename: 'User' }
          & Pick<User, 'id' | 'displayName' | 'profileImagePath'>
        ) }
      )> }
    ) }
  ) | (
    { __typename: 'Revision' }
    & Pick<Revision, 'id' | 'revisionsetId' | 'name'>
    & { revisor: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'profileImagePath'>
    ), linkoutData: (
      { __typename: 'LinkoutData' }
      & Pick<LinkoutData, 'name'>
    ) }
  )> }
);

export type OrgHoverCardQueryVariables = Exact<{
  orgId: Scalars['Int'];
}>;


export type OrgHoverCardQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & HovercardOrgFragment
  )> }
);

export type HovercardOrgFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'profileImagePath' | 'name' | 'description' | 'url'>
);

export type UserHoverCardQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type UserHoverCardQuery = (
  { __typename: 'Query' }
  & { user?: Maybe<(
    { __typename: 'User' }
    & HovercardUserFragment
  )> }
);

export type HovercardUserFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'profileImagePath' | 'displayName' | 'bio'>
  & { organizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name'>
  )> }
);

export type GeneRevisableFieldsQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GeneRevisableFieldsQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'description'>
    & { sources: Array<(
      { __typename: 'Source' }
      & Pick<Source, 'id'>
    )> }
  )> }
);

export type SuggestGeneRevisionMutationVariables = Exact<{
  input: SuggestGeneRevisionInput;
}>;


export type SuggestGeneRevisionMutation = (
  { __typename: 'Mutation' }
  & { suggestGeneRevision?: Maybe<(
    { __typename: 'SuggestGeneRevisionPayload' }
    & Pick<SuggestGeneRevisionPayload, 'clientMutationId'>
    & { gene: (
      { __typename: 'Gene' }
      & Pick<Gene, 'id'>
      & { revisions: (
        { __typename: 'RevisionConnection' }
        & Pick<RevisionConnection, 'totalCount'>
        & { edges: Array<(
          { __typename: 'RevisionEdge' }
          & { node?: Maybe<(
            { __typename: 'Revision' }
            & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
            & { linkoutData: (
              { __typename: 'LinkoutData' }
              & Pick<LinkoutData, 'name'>
              & { diffValue: (
                { __typename: 'ObjectFieldDiff' }
                & { addedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, removedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, keptObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )> }
              ) | (
                { __typename: 'ScalarField' }
                & Pick<ScalarField, 'value'>
              ) }
            ), revisor: (
              { __typename: 'User' }
              & Pick<User, 'id' | 'name'>
            ) }
          )> }
        )> }
      ) }
    ), results: Array<(
      { __typename: 'RevisionResult' }
      & Pick<RevisionResult, 'id' | 'fieldName'>
    )> }
  )> }
);

export type ViewerBaseQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerBaseQuery = (
  { __typename: 'Query' }
  & { viewer?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )>, events: (
      { __typename: 'EventConnection' }
      & { nodes: Array<(
        { __typename: 'Event' }
        & Pick<Event, 'id' | 'createdAt'>
        & { organization: (
          { __typename: 'Organization' }
          & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
        ) }
      )> }
    ) }
  )> }
);

export type ViewerFullQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerFullQuery = (
  { __typename: 'Query' }
  & { viewer?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'name' | 'email' | 'bio' | 'url' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )> }
  )> }
);

export type BrowseGenesQueryVariables = Exact<{
  entrezSymbol?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  geneAlias?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<GenesSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type BrowseGenesQuery = (
  { __typename: 'Query' }
  & { browseGenes: (
    { __typename: 'BrowseGeneConnection' }
    & Pick<BrowseGeneConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { nodes: Array<(
      { __typename: 'BrowseGene' }
      & Pick<BrowseGene, 'id' | 'name'>
    )>, edges: Array<(
      { __typename: 'BrowseGeneEdge' }
      & Pick<BrowseGeneEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseGene' }
        & Pick<BrowseGene, 'id' | 'entrezId' | 'name' | 'variantCount' | 'evidenceItemCount' | 'assertionCount'>
        & { aliases?: Maybe<Array<(
          { __typename: 'GeneAlias' }
          & Pick<GeneAlias, 'name'>
        )>>, diseases?: Maybe<Array<(
          { __typename: 'Disease' }
          & Pick<Disease, 'name'>
        )>>, drugs?: Maybe<Array<(
          { __typename: 'Drug' }
          & Pick<Drug, 'name'>
        )>> }
      )> }
    )>, pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ) }
  ) }
);

export type GeneCommentsQueryVariables = Exact<{
  id: Scalars['Int'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
}>;


export type GeneCommentsQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'id'>
    & { comments: (
      { __typename: 'CommentConnection' }
      & CommentListFragment
      & CommentParticipantsFragment
    ) }
  )> }
);

export type GeneDetailQueryVariables = Exact<{
  geneId: Scalars['Int'];
  commentFirst?: Maybe<Scalars['Int']>;
  commentLast?: Maybe<Scalars['Int']>;
  commentBefore?: Maybe<Scalars['String']>;
  commentAfter?: Maybe<Scalars['String']>;
}>;


export type GeneDetailQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name' | 'officialName' | 'entrezId'>
    & { flags: (
      { __typename: 'FlagConnection' }
      & Pick<FlagConnection, 'totalCount'>
    ), revisions: (
      { __typename: 'RevisionConnection' }
      & Pick<RevisionConnection, 'totalCount'>
    ), comments: (
      { __typename: 'CommentConnection' }
      & Pick<CommentConnection, 'totalCount'>
      & { edges: Array<(
        { __typename: 'CommentEdge' }
        & Pick<CommentEdge, 'cursor'>
        & { node?: Maybe<(
          { __typename: 'Comment' }
          & Pick<Comment, 'id'>
        )> }
      )> }
    ), lifecycleActions: (
      { __typename: 'Lifecycle' }
      & { lastCommentedOn?: Maybe<(
        { __typename: 'Event' }
        & Pick<Event, 'createdAt' | 'id'>
        & { organization: (
          { __typename: 'Organization' }
          & Pick<Organization, 'id' | 'name'>
        ), originatingUser: (
          { __typename: 'User' }
          & Pick<User, 'id' | 'name'>
        ) }
      )>, lastModified?: Maybe<(
        { __typename: 'Event' }
        & Pick<Event, 'createdAt' | 'id'>
        & { organization: (
          { __typename: 'Organization' }
          & Pick<Organization, 'id' | 'name'>
        ), originatingUser: (
          { __typename: 'User' }
          & Pick<User, 'id' | 'name'>
        ) }
      )>, lastReviewed?: Maybe<(
        { __typename: 'Event' }
        & Pick<Event, 'createdAt' | 'id'>
        & { organization: (
          { __typename: 'Organization' }
          & Pick<Organization, 'id' | 'name'>
        ), originatingUser: (
          { __typename: 'User' }
          & Pick<User, 'id' | 'name'>
        ) }
      )> }
    ) }
  )> }
);

export type GeneRevisionsQueryVariables = Exact<{
  geneId: Scalars['Int'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
}>;


export type GeneRevisionsQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'id'>
    & { revisions: (
      { __typename: 'RevisionConnection' }
      & Pick<RevisionConnection, 'totalCount'>
      & { uniqueRevisors: Array<(
        { __typename: 'User' }
        & Pick<User, 'username' | 'id' | 'profileImagePath'>
      )>, revisedFieldNames: Array<(
        { __typename: 'FieldName' }
        & Pick<FieldName, 'name' | 'displayName'>
      )>, edges: Array<(
        { __typename: 'RevisionEdge' }
        & { node?: Maybe<(
          { __typename: 'Revision' }
          & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
          & { linkoutData: (
            { __typename: 'LinkoutData' }
            & Pick<LinkoutData, 'name'>
            & { diffValue: (
              { __typename: 'ObjectFieldDiff' }
              & { addedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, removedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, keptObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )> }
            ) | (
              { __typename: 'ScalarField' }
              & Pick<ScalarField, 'value'>
            ) }
          ), revisor: (
            { __typename: 'User' }
            & Pick<User, 'id' | 'name'>
          ) }
        )> }
      )> }
    ) }
  )> }
);

export type GenesSummaryQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GenesSummaryQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'description' | 'entrezId' | 'id' | 'name' | 'officialName' | 'myGeneInfoDetails'>
    & { aliases: Array<(
      { __typename: 'GeneAlias' }
      & Pick<GeneAlias, 'name'>
    )>, sources: Array<(
      { __typename: 'Source' }
      & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'sourceType'>
    )>, variants: (
      { __typename: 'VariantConnection' }
      & { edges: Array<(
        { __typename: 'VariantEdge' }
        & { node?: Maybe<(
          { __typename: 'Variant' }
          & Pick<Variant, 'id' | 'name' | 'description'>
        )> }
      )> }
    ) }
  )> }
);

export const HovercardGeneFragmentDoc = gql`
    fragment hovercardGene on Gene {
  id
  name
  officialName
  aliases {
    name
  }
  variants {
    totalCount
  }
}
    `;
export const CommentListNodeFragmentDoc = gql`
    fragment commentListNode on Comment {
  id
  title
  comment
  createdAt
  commenter {
    id
    username
    displayName
    name
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
}
    `;
export const CommentListFragmentDoc = gql`
    fragment commentList on CommentConnection {
  totalCount
  pageInfo {
    startCursor
    endCursor
    hasPreviousPage
    hasNextPage
  }
  edges {
    cursor
    node {
      ...commentListNode
    }
  }
}
    ${CommentListNodeFragmentDoc}`;
export const CommentParticipantsFragmentDoc = gql`
    fragment commentParticipants on CommentConnection {
  uniqueCommenters {
    id
    username
    profileImagePath(size: 32)
  }
}
    `;
export const EventFeedNodeFragmentDoc = gql`
    fragment eventFeedNode on Event {
  id
  action
  createdAt
  organization {
    id
    name
    profileImagePath(size: 32)
  }
  originatingUser {
    id
    username
    displayName
    profileImagePath(size: 32)
  }
  subject {
    name
    id
    __typename
  }
  originatingObject {
    id
    name
    __typename
    ... on Revision {
      id
      revisor {
        id
        displayName
        profileImagePath(size: 32)
      }
      linkoutData {
        name
      }
      revisionsetId
    }
    ... on Comment {
      id
      comment
    }
    ... on Flag {
      id
      comments(first: 1) {
        nodes {
          comment
          createdAt
          commenter {
            id
            displayName
            profileImagePath(size: 32)
          }
        }
      }
    }
  }
}
    `;
export const EventFeedFragmentDoc = gql`
    fragment eventFeed on EventConnection {
  pageInfo {
    startCursor
    endCursor
    hasNextPage
    hasPreviousPage
  }
  eventTypes
  uniqueParticipants {
    id
    displayName
    profileImagePath(size: 32)
  }
  participatingOrganizations {
    id
    name
    profileImagePath(size: 32)
  }
  edges {
    cursor
    node {
      ...eventFeedNode
    }
  }
}
    ${EventFeedNodeFragmentDoc}`;
export const HovercardOrgFragmentDoc = gql`
    fragment hovercardOrg on Organization {
  id
  profileImagePath(size: 64)
  name
  description
  url
}
    `;
export const HovercardUserFragmentDoc = gql`
    fragment hovercardUser on User {
  id
  profileImagePath(size: 64)
  displayName
  bio
  organizations {
    id
    name
  }
}
    `;
export const GeneHoverCardDocument = gql`
    query GeneHoverCard($geneId: Int!) {
  gene(id: $geneId) {
    ...hovercardGene
  }
}
    ${HovercardGeneFragmentDoc}`;

  @Injectable({
    providedIn: AppModule
  })
  export class GeneHoverCardGQL extends Apollo.Query<GeneHoverCardQuery, GeneHoverCardQueryVariables> {
    document = GeneHoverCardDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddCommentDocument = gql`
    mutation AddComment($input: AddCommentInput!) {
  addComment(input: $input) {
    clientMutationId
    comment {
      ...commentListNode
    }
  }
}
    ${CommentListNodeFragmentDoc}`;

  @Injectable({
    providedIn: AppModule
  })
  export class AddCommentGQL extends Apollo.Mutation<AddCommentMutation, AddCommentMutationVariables> {
    document = AddCommentDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EventFeedDocument = gql`
    query EventFeed($subject: SubscribableInput, $first: Int, $last: Int, $before: String, $after: String, $originatingUserId: Int, $organizationId: Int) {
  events(
    subject: $subject
    first: $first
    last: $last
    before: $before
    after: $after
    originatingUserId: $originatingUserId
    organizationId: $organizationId
  ) {
    ...eventFeed
  }
}
    ${EventFeedFragmentDoc}`;

  @Injectable({
    providedIn: AppModule
  })
  export class EventFeedGQL extends Apollo.Query<EventFeedQuery, EventFeedQueryVariables> {
    document = EventFeedDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrgHoverCardDocument = gql`
    query OrgHoverCard($orgId: Int!) {
  organization(id: $orgId) {
    ...hovercardOrg
  }
}
    ${HovercardOrgFragmentDoc}`;

  @Injectable({
    providedIn: AppModule
  })
  export class OrgHoverCardGQL extends Apollo.Query<OrgHoverCardQuery, OrgHoverCardQueryVariables> {
    document = OrgHoverCardDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserHoverCardDocument = gql`
    query UserHoverCard($userId: Int!) {
  user(userId: $userId) {
    ...hovercardUser
  }
}
    ${HovercardUserFragmentDoc}`;

  @Injectable({
    providedIn: AppModule
  })
  export class UserHoverCardGQL extends Apollo.Query<UserHoverCardQuery, UserHoverCardQueryVariables> {
    document = UserHoverCardDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneRevisableFieldsDocument = gql`
    query GeneRevisableFields($geneId: Int!) {
  gene(id: $geneId) {
    id
    description
    sources {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class GeneRevisableFieldsGQL extends Apollo.Query<GeneRevisableFieldsQuery, GeneRevisableFieldsQueryVariables> {
    document = GeneRevisableFieldsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SuggestGeneRevisionDocument = gql`
    mutation SuggestGeneRevision($input: SuggestGeneRevisionInput!) {
  suggestGeneRevision(input: $input) {
    clientMutationId
    gene {
      id
      revisions {
        totalCount
        edges {
          node {
            id
            revisionsetId
            createdAt
            fieldName
            currentValue
            suggestedValue
            linkoutData {
              name
              diffValue {
                ... on ObjectFieldDiff {
                  addedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  removedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  keptObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                }
                ... on ScalarField {
                  value
                }
              }
            }
            revisor {
              id
              name
            }
            status
          }
        }
      }
    }
    results {
      id
      fieldName
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class SuggestGeneRevisionGQL extends Apollo.Mutation<SuggestGeneRevisionMutation, SuggestGeneRevisionMutationVariables> {
    document = SuggestGeneRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerBaseDocument = gql`
    query ViewerBase {
  viewer {
    id
    username
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
    events(first: 1) {
      nodes {
        id
        createdAt
        organization {
          id
          name
          profileImagePath(size: 32)
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class ViewerBaseGQL extends Apollo.Query<ViewerBaseQuery, ViewerBaseQueryVariables> {
    document = ViewerBaseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerFullDocument = gql`
    query ViewerFull {
  viewer {
    id
    username
    name
    email
    bio
    url
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class ViewerFullGQL extends Apollo.Query<ViewerFullQuery, ViewerFullQueryVariables> {
    document = ViewerFullDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseGenesDocument = gql`
    query BrowseGenes($entrezSymbol: String, $drugName: String, $geneAlias: String, $diseaseName: String, $sortBy: GenesSort, $first: Int, $last: Int, $before: String, $after: String) {
  browseGenes(
    entrezSymbol: $entrezSymbol
    drugName: $drugName
    geneAlias: $geneAlias
    diseaseName: $diseaseName
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    nodes {
      id
      name
    }
    edges {
      cursor
      node {
        id
        entrezId
        name
        aliases {
          name
        }
        diseases {
          name
        }
        drugs {
          name
        }
        variantCount
        evidenceItemCount
        assertionCount
      }
    }
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    totalCount
    filteredCount
    pageCount
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class BrowseGenesGQL extends Apollo.Query<BrowseGenesQuery, BrowseGenesQueryVariables> {
    document = BrowseGenesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneCommentsDocument = gql`
    query GeneComments($id: Int!, $first: Int, $last: Int, $before: String, $after: String, $userId: Int) {
  gene(id: $id) {
    id
    comments(
      first: $first
      last: $last
      before: $before
      after: $after
      originatingUserId: $userId
    ) {
      ...commentList
      ...commentParticipants
    }
  }
}
    ${CommentListFragmentDoc}
${CommentParticipantsFragmentDoc}`;

  @Injectable({
    providedIn: AppModule
  })
  export class GeneCommentsGQL extends Apollo.Query<GeneCommentsQuery, GeneCommentsQueryVariables> {
    document = GeneCommentsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneDetailDocument = gql`
    query GeneDetail($geneId: Int!, $commentFirst: Int, $commentLast: Int, $commentBefore: String, $commentAfter: String) {
  gene(id: $geneId) {
    id
    name
    officialName
    entrezId
    flags {
      totalCount
    }
    revisions {
      totalCount
    }
    comments(
      first: $commentFirst
      last: $commentLast
      before: $commentBefore
      after: $commentAfter
    ) {
      totalCount
      edges {
        cursor
        node {
          id
        }
      }
    }
    lifecycleActions {
      lastCommentedOn {
        createdAt
        id
        organization {
          id
          name
        }
        originatingUser {
          id
          name
        }
      }
      lastModified {
        createdAt
        id
        organization {
          id
          name
        }
        originatingUser {
          id
          name
        }
      }
      lastReviewed {
        createdAt
        id
        organization {
          id
          name
        }
        originatingUser {
          id
          name
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class GeneDetailGQL extends Apollo.Query<GeneDetailQuery, GeneDetailQueryVariables> {
    document = GeneDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneRevisionsDocument = gql`
    query GeneRevisions($geneId: Int!, $first: Int, $last: Int, $before: String, $after: String, $fieldName: String, $originatingUserId: Int) {
  gene(id: $geneId) {
    id
    revisions(
      first: $first
      last: $last
      before: $before
      after: $after
      fieldName: $fieldName
      originatingUserId: $originatingUserId
    ) {
      totalCount
      uniqueRevisors {
        username
        id
        profileImagePath(size: 32)
      }
      revisedFieldNames {
        name
        displayName
      }
      edges {
        node {
          id
          revisionsetId
          createdAt
          fieldName
          currentValue
          suggestedValue
          linkoutData {
            name
            diffValue {
              ... on ObjectFieldDiff {
                addedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                removedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                keptObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
              }
              ... on ScalarField {
                value
              }
            }
          }
          revisor {
            id
            name
          }
          status
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class GeneRevisionsGQL extends Apollo.Query<GeneRevisionsQuery, GeneRevisionsQueryVariables> {
    document = GeneRevisionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GenesSummaryDocument = gql`
    query GenesSummary($geneId: Int!) {
  gene(id: $geneId) {
    description
    entrezId
    aliases {
      name
    }
    id
    name
    officialName
    sources {
      id
      citation
      sourceUrl
      sourceType
    }
    variants {
      edges {
        node {
          id
          name
          description
        }
      }
    }
    myGeneInfoDetails
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class GenesSummaryGQL extends Apollo.Query<GenesSummaryQuery, GenesSummaryQueryVariables> {
    document = GenesSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }