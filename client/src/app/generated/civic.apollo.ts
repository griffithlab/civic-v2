/* eslint-disable */
import { gql } from 'apollo-angular';
import { Injectable } from '@angular/core';
import * as Apollo from 'apollo-angular';
import { AppModule } from '../app.module';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};



/** Autogenerated input type of AcceptRevision */
export type AcceptRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Body of an optional comment to attach to the revision on acceptance. */
  comment?: Maybe<Scalars['String']>;
  /** The ID of the Revision to accept. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of AcceptRevision */
export type AcceptRevisionPayload = {
  __typename?: 'AcceptRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly accepted Revision. */
  revision: Revision;
  /** A list of any revisions that were superseded by the acceptance of this one. */
  supersededRevisions: Array<Revision>;
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** Text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The commentable to attach the comment to. Specified by ID and Type. */
  subject: CommentableInput;
  /** Optional title for the comment. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddComment */
export type AddCommentPayload = {
  __typename?: 'AddCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<Comment>;
};

export type AdvancedSearchResult = {
  __typename?: 'AdvancedSearchResult';
  permalinkId?: Maybe<Scalars['String']>;
  resultIds: Array<Scalars['Int']>;
  searchEndpoint: Scalars['String'];
};

export enum BooleanOperator {
  And = 'AND',
  Or = 'OR'
}

export type BooleanSearchInput = {
  value: Scalars['Boolean'];
};

export type BrowseGene = {
  __typename?: 'BrowseGene';
  aliases?: Maybe<Array<GeneAlias>>;
  assertionCount: Scalars['Int'];
  description: Scalars['String'];
  diseases?: Maybe<Array<Disease>>;
  drugs?: Maybe<Array<Drug>>;
  entrezId: Scalars['Int'];
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseGene. */
export type BrowseGeneConnection = {
  __typename?: 'BrowseGeneConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BrowseGeneEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BrowseGene>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseGeneEdge = {
  __typename?: 'BrowseGeneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseGene>;
};

export type ClinicalTrial = {
  __typename?: 'ClinicalTrial';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nctId: Scalars['String'];
};

export type Comment = {
  __typename?: 'Comment';
  comment: Scalars['String'];
  commentor: User;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['Int'];
  title?: Maybe<Scalars['String']>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: 'CommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

export enum CommentableEntities {
  Gene = 'GENE'
}

/** Entity to comment on */
export type CommentableInput = {
  /** The type of the entity to comment on. */
  entityType: CommentableEntities;
  /** ID of the entity to comment on. */
  id: Scalars['Int'];
};

export type Disease = {
  __typename?: 'Disease';
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  name: Scalars['String'];
};

export type Drug = {
  __typename?: 'Drug';
  drugUrl?: Maybe<Scalars['String']>;
  id: Scalars['String'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

export type Event = {
  __typename?: 'Event';
  action: EventAction;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['Int'];
  organization: Organization;
  originatingUser: User;
};

export enum EventAction {
  Accepted = 'ACCEPTED',
  AssertionAccepted = 'ASSERTION_ACCEPTED',
  AssertionRejected = 'ASSERTION_REJECTED',
  AssertionSubmitted = 'ASSERTION_SUBMITTED',
  Commented = 'COMMENTED',
  Flagged = 'FLAGGED',
  FlagResolved = 'FLAG_RESOLVED',
  PublicationSuggested = 'PUBLICATION_SUGGESTED',
  Rejected = 'REJECTED',
  Reverted = 'REVERTED',
  RevisionAccepted = 'REVISION_ACCEPTED',
  RevisionRejected = 'REVISION_REJECTED',
  RevisionSuggested = 'REVISION_SUGGESTED',
  RevisionSuperseded = 'REVISION_SUPERSEDED',
  Submitted = 'SUBMITTED'
}

/** The connection type for Event. */
export type EventConnection = {
  __typename?: 'EventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EventEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Event>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type EventEdge = {
  __typename?: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

export type EvidenceItem = {
  __typename?: 'EvidenceItem';
  description: Scalars['String'];
  events: EventConnection;
  id: Scalars['Int'];
  variant: Variant;
};


export type EvidenceItemEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for EvidenceItem. */
export type EvidenceItemConnection = {
  __typename?: 'EvidenceItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EvidenceItemEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EvidenceItem>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type EvidenceItemEdge = {
  __typename?: 'EvidenceItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EvidenceItem>;
};

export type Flag = {
  __typename?: 'Flag';
  id: Scalars['Int'];
  state: FlagState;
};

/** Autogenerated input type of FlagEntity */
export type FlagEntityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the problem you observed with this entity. */
  comment: Scalars['String'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The entity to flag, specified by its ID and type. */
  subject: FlaggableInput;
};

/** Autogenerated return type of FlagEntity */
export type FlagEntityPayload = {
  __typename?: 'FlagEntityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created Flag. */
  flag?: Maybe<Flag>;
};

export enum FlagState {
  Open = 'open',
  Resolved = 'resolved'
}

/** Enumeration of all entities in CIViC that can be flagged. */
export enum FlaggableEntities {
  Gene = 'GENE'
}

/** Entity to flag */
export type FlaggableInput = {
  /** The type of the entity to flag. */
  entityType: FlaggableEntities;
  /** The ID of the entity. */
  id: Scalars['Int'];
};

export type Gene = {
  __typename?: 'Gene';
  aliases?: Maybe<Array<GeneAlias>>;
  comments?: Maybe<CommentConnection>;
  description: Scalars['String'];
  entrezId: Scalars['Int'];
  events: EventConnection;
  id: Scalars['Int'];
  lifecycleActions: Lifecycle;
  myGeneInfoDetails?: Maybe<Scalars['JSON']>;
  name: Scalars['String'];
  officialName: Scalars['String'];
  revisions?: Maybe<RevisionConnection>;
  sources?: Maybe<Array<Source>>;
  variants?: Maybe<VariantConnection>;
};


export type GeneCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type GeneEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type GeneRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type GeneVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

export type GeneAlias = {
  __typename?: 'GeneAlias';
  name: Scalars['String'];
};

export type GeneFields = {
  /** The Gene's description/summary text. */
  description: Scalars['String'];
  /** Source IDs cited by the Gene's summary. */
  sourceIds: Array<Scalars['Int']>;
};

export type GeneSearchFilter = {
  alias?: Maybe<StringSearchInput>;
  booleanOperator?: Maybe<BooleanOperator>;
  description?: Maybe<StringSearchInput>;
  entrezId?: Maybe<IntSearchInput>;
  entrezSymbol?: Maybe<StringSearchInput>;
  hasAssertion?: Maybe<BooleanSearchInput>;
  id?: Maybe<IntSearchInput>;
  openRevisionCount?: Maybe<IntSearchInput>;
  subFilters?: Maybe<Array<GeneSearchFilter>>;
};

export type GenesSort = {
  /** Available columns for sorting */
  column: GenesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum GenesSortColumns {
  AssertionCount = 'assertionCount',
  DiseaseName = 'diseaseName',
  DrugName = 'drugName',
  EntrezSymbol = 'entrezSymbol',
  EvidenceItemCount = 'evidenceItemCount',
  GeneAlias = 'geneAlias',
  VariantCount = 'variantCount'
}


export type IntSearchInput = {
  comparisonOperator: IntSearchOperator;
  value: Scalars['Int'];
};

export enum IntSearchOperator {
  /** Equal To */
  Eq = 'EQ',
  Ge = 'GE',
  Gt = 'GT',
  Le = 'LE',
  Lt = 'LT',
  Ne = 'NE'
}


export type Lifecycle = {
  __typename?: 'Lifecycle';
  lastCommentedOn?: Maybe<Event>;
  lastModified?: Maybe<Event>;
  lastReviewed?: Maybe<Event>;
};

export type LinkoutData = {
  __typename?: 'LinkoutData';
  currentValue: ModeratedField;
  diffValue: ModeratedFieldDiff;
  name: Scalars['String'];
  suggestedValue: ModeratedField;
};

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more Notification IDs. */
  ids: Array<Scalars['Int']>;
};

/** Autogenerated return type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadPayload = {
  __typename?: 'MarkNotificationsAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of the notifications in their new state. */
  notifications: Array<Notification>;
};

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedField = ObjectField | ScalarField;

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedFieldDiff = ObjectFieldDiff | ScalarField;

export type ModeratedObjectField = {
  __typename?: 'ModeratedObjectField';
  displayName: Scalars['String'];
  displayType: Scalars['String'];
  entityType: Scalars['String'];
  id: Scalars['Int'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /**
   * Accept a revision by ID. The accepting user must be an editor with a valid
   * conflict of interest statement on file and the revision must not be their own.
   */
  acceptRevision?: Maybe<AcceptRevisionPayload>;
  /** Add a comment to any commentable entity. */
  addComment?: Maybe<AddCommentPayload>;
  /** Flag an entity to signal to the editorial team that you believe there is an issue with it. */
  flagEntity?: Maybe<FlagEntityPayload>;
  /** Mark one or more of your notifications as read. The notification IDs provided must belong to the requesting user. */
  markNotificationsAsRead?: Maybe<MarkNotificationsAsReadPayload>;
  /**
   * Reject a revision by ID. Any user may reject a Revision that they submitted
   * themselves. Otherwise, the rejecting user must be an editor with valid
   * conflict of interest statement on file.
   */
  rejectRevision?: Maybe<RejectRevisionPayload>;
  /**
   * Resolve a flag on a CIViC entity indicating that it was either erronously flagged or the issue has been resolved.
   * Any user may resolve their own flag however only editors with valid conflict
   * of interest statements can resolve other flags.
   */
  resolveFlag?: Maybe<ResolveFlagPayload>;
  /** Subscribe to a CIViC entity in order to receive notifications about it. */
  subscribe?: Maybe<SubscribePayload>;
  /** Suggest a Revision to a Gene entity. */
  suggestGeneRevision?: Maybe<SuggestGeneRevisionPayload>;
  /** Unsubscribe from a CIViC entity to stop receiving notifications about it. */
  unsubscribe?: Maybe<UnsubscribePayload>;
};


export type MutationAcceptRevisionArgs = {
  input: AcceptRevisionInput;
};


export type MutationAddCommentArgs = {
  input: AddCommentInput;
};


export type MutationFlagEntityArgs = {
  input: FlagEntityInput;
};


export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput;
};


export type MutationRejectRevisionArgs = {
  input: RejectRevisionInput;
};


export type MutationResolveFlagArgs = {
  input: ResolveFlagInput;
};


export type MutationSubscribeArgs = {
  input: SubscribeInput;
};


export type MutationSuggestGeneRevisionArgs = {
  input: SuggestGeneRevisionInput;
};


export type MutationUnsubscribeArgs = {
  input: UnsubscribeInput;
};

export type Notification = {
  __typename?: 'Notification';
  createdAt: Scalars['ISO8601DateTime'];
  event: Event;
  id: Scalars['Int'];
  notifiedUser: User;
  originatingUser: User;
  seen: Scalars['Boolean'];
  subscription?: Maybe<Subscription>;
  type: NotificationReason;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename?: 'NotificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Notification>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename?: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

export enum NotificationReason {
  Mention = 'MENTION',
  Subscription = 'SUBSCRIPTION'
}

export type ObjectField = {
  __typename?: 'ObjectField';
  objects: Array<ModeratedObjectField>;
};

export type ObjectFieldDiff = {
  __typename?: 'ObjectFieldDiff';
  addedObjects: Array<ModeratedObjectField>;
  keptObjects: Array<ModeratedObjectField>;
  removedObjects: Array<ModeratedObjectField>;
};

export type Organization = {
  __typename?: 'Organization';
  description: Scalars['String'];
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
  profileImagePath?: Maybe<Scalars['String']>;
  url: Scalars['String'];
};


export type OrganizationEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type OrganizationProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  browseEvents: EventConnection;
  browseGenes: BrowseGeneConnection;
  /** Find a disease by CIViC ID */
  disease?: Maybe<Disease>;
  /** Find a drug by CIViC ID */
  drug?: Maybe<Drug>;
  /** Find a gene by CIViC ID */
  gene?: Maybe<Gene>;
  searchByPermalink: AdvancedSearchResult;
  searchGenes: AdvancedSearchResult;
  /** Find a source by CIViC ID */
  source?: Maybe<Source>;
  user?: Maybe<User>;
  viewer?: Maybe<User>;
};


export type QueryBrowseEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  subject?: Maybe<SubscribableInput>;
};


export type QueryBrowseGenesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneAlias?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<GenesSort>;
};


export type QueryDiseaseArgs = {
  id: Scalars['ID'];
};


export type QueryDrugArgs = {
  id: Scalars['ID'];
};


export type QueryGeneArgs = {
  id: Scalars['ID'];
};


export type QuerySearchByPermalinkArgs = {
  permalinkId: Scalars['String'];
};


export type QuerySearchGenesArgs = {
  createPermalink?: Maybe<Scalars['Boolean']>;
  query: GeneSearchFilter;
};


export type QuerySourceArgs = {
  id: Scalars['ID'];
};


export type QueryUserArgs = {
  userId: Scalars['Int'];
};

/** Autogenerated input type of RejectRevision */
export type RejectRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text explaining the reasoning for rejecting this Revision. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the Revision to reject. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of RejectRevision */
export type RejectRevisionPayload = {
  __typename?: 'RejectRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The rejected Revision. */
  revision: Revision;
};

/** Autogenerated input type of ResolveFlag */
export type ResolveFlagInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for resolving the flag. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the flag to resolve. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of ResolveFlag */
export type ResolveFlagPayload = {
  __typename?: 'ResolveFlagPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  flag?: Maybe<Flag>;
};

export type Revision = {
  __typename?: 'Revision';
  comments: Array<Comment>;
  createdAt: Scalars['ISO8601DateTime'];
  currentValue: Scalars['JSON'];
  fieldName: Scalars['String'];
  id: Scalars['Int'];
  linkoutData: LinkoutData;
  revisionsetId: Scalars['String'];
  revisor: User;
  status: RevisionStatus;
  suggestedValue: Scalars['JSON'];
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Revision. */
export type RevisionConnection = {
  __typename?: 'RevisionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RevisionEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Revision>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type RevisionEdge = {
  __typename?: 'RevisionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Revision>;
};

export type RevisionResult = {
  __typename?: 'RevisionResult';
  /** Name of the field on the moderated entity that the Revision pertains to. */
  fieldName: Scalars['String'];
  /** ID of the Revision. */
  id: Scalars['Int'];
  /** Was this Revision newly created as a result of this request? */
  newlyCreated: Scalars['Boolean'];
  /** An identifier that can be used to group Revisions proposed at the same time. */
  revisionsetId: Scalars['String'];
};

export enum RevisionStatus {
  Accepted = 'accepted',
  New = 'new',
  Rejected = 'rejected',
  Superseded = 'superseded'
}

export type ScalarField = {
  __typename?: 'ScalarField';
  value?: Maybe<Scalars['String']>;
};

export enum SortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type Source = {
  __typename?: 'Source';
  ascoAbstractId?: Maybe<Scalars['Int']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials?: Maybe<Array<ClinicalTrial>>;
  fullJournalTitle: Scalars['String'];
  id: Scalars['Int'];
  journal: Scalars['String'];
  name: Scalars['String'];
  publicationDay?: Maybe<Scalars['Int']>;
  publicationMonth: Scalars['Int'];
  publicationYear: Scalars['Int'];
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
  status: SourceStatus;
};

export enum SourceSource {
  Asco = 'ASCO',
  PubMed = 'PubMed'
}

export enum SourceStatus {
  FullyCurated = 'FullyCurated',
  PartiallyCurated = 'PartiallyCurated',
  Submitted = 'Submitted'
}

export type StringSearchInput = {
  comparisonOperator: StringSearchOperator;
  value: Scalars['String'];
};

export enum StringSearchOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  Eq = 'EQ',
  Ne = 'NE',
  StartsWith = 'STARTS_WITH'
}

export type Subscribable = {
  __typename?: 'Subscribable';
  entityType: SubscribableEntities;
  id: Scalars['Int'];
};

/** Enumeration of all subscribable CIViC entities. */
export enum SubscribableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  Variant = 'VARIANT'
}

/** Entity to subscribe to. */
export type SubscribableInput = {
  /** Type of subscribable entity. */
  entityType: SubscribableEntities;
  /** ID of subscribable entity. */
  id: Scalars['Int'];
};

/** Autogenerated input type of Subscribe */
export type SubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to subscribe to, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you want to subscribe to related child entities of the subscribed entities?
   * IE: If you subscribe to a Gene, do you want to receive notifications for its Variants as well?
   */
  subscribeToChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Subscribe */
export type SubscribePayload = {
  __typename?: 'SubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created subscription objects. */
  subscriptions: Array<Subscription>;
};

export type Subscription = {
  __typename?: 'Subscription';
  id: Scalars['Int'];
};

/** Autogenerated input type of SuggestGeneRevision */
export type SuggestGeneRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Gene's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: GeneFields;
  /** The ID of the Gene to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestGeneRevision */
export type SuggestGeneRevisionPayload = {
  __typename?: 'SuggestGeneRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Gene the user has proposed a Revision to. */
  gene: Gene;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of Unsubscribe */
export type UnsubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to unsubscribe from, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you also wish to stop receiving notifications from child entities?
   * IE: If you unsubscribe from a Gene do you want to stop receiving notifications for its Variants as well?
   */
  unsubscribeFromChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Unsubscribe */
export type UnsubscribePayload = {
  __typename?: 'UnsubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The entities that were unsubscribed from. */
  unsubscribedEntities: Array<Subscribable>;
};

export type User = {
  __typename?: 'User';
  bio?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
  /** Filterable list of notifications for the logged in user. */
  notifications?: Maybe<NotificationConnection>;
  organizations?: Maybe<Array<Organization>>;
  profileImagePath?: Maybe<Scalars['String']>;
  role: Scalars['String'];
  url?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};


export type UserEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type UserNotificationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  includeSeen?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  notificationType?: Maybe<NotificationReason>;
  subscriptionId?: Maybe<Scalars['Int']>;
};


export type UserProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

export type Variant = {
  __typename?: 'Variant';
  description: Scalars['String'];
  events: EventConnection;
  evidenceItems?: Maybe<EvidenceItemConnection>;
  gene: Gene;
  id: Scalars['Int'];
  name: Scalars['String'];
};


export type VariantEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type VariantEvidenceItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for Variant. */
export type VariantConnection = {
  __typename?: 'VariantConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VariantEdge>>>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Variant>>>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type VariantEdge = {
  __typename?: 'VariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Variant>;
};

export type ViewerBaseQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerBaseQuery = (
  { __typename?: 'Query' }
  & { viewer?: Maybe<(
    { __typename?: 'User' }
    & Pick<User, 'id' | 'username' | 'role' | 'profileImagePath'>
    & { organizations?: Maybe<Array<(
      { __typename?: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )>> }
  )> }
);

export type ViewerFullQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerFullQuery = (
  { __typename?: 'Query' }
  & { viewer?: Maybe<(
    { __typename?: 'User' }
    & Pick<User, 'id' | 'username' | 'name' | 'email' | 'bio' | 'url' | 'role' | 'profileImagePath'>
    & { organizations?: Maybe<Array<(
      { __typename?: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )>> }
  )> }
);

export type BrowseGenesQueryVariables = Exact<{
  entrezSymbol?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  geneAlias?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<GenesSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type BrowseGenesQuery = (
  { __typename?: 'Query' }
  & { browseGenes: (
    { __typename?: 'BrowseGeneConnection' }
    & Pick<BrowseGeneConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'BrowseGene' }
      & Pick<BrowseGene, 'id' | 'name'>
    )>>>, edges?: Maybe<Array<Maybe<(
      { __typename?: 'BrowseGeneEdge' }
      & Pick<BrowseGeneEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename?: 'BrowseGene' }
        & Pick<BrowseGene, 'id' | 'entrezId' | 'name' | 'variantCount' | 'evidenceItemCount' | 'assertionCount'>
        & { aliases?: Maybe<Array<(
          { __typename?: 'GeneAlias' }
          & Pick<GeneAlias, 'name'>
        )>>, diseases?: Maybe<Array<(
          { __typename?: 'Disease' }
          & Pick<Disease, 'name'>
        )>>, drugs?: Maybe<Array<(
          { __typename?: 'Drug' }
          & Pick<Drug, 'name'>
        )>> }
      )> }
    )>>>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ) }
  ) }
);

export type GeneDetailQueryVariables = Exact<{
  geneId: Scalars['ID'];
}>;


export type GeneDetailQuery = (
  { __typename?: 'Query' }
  & { gene?: Maybe<(
    { __typename?: 'Gene' }
    & Pick<Gene, 'description' | 'entrezId' | 'id' | 'name' | 'officialName' | 'myGeneInfoDetails'>
    & { aliases?: Maybe<Array<(
      { __typename?: 'GeneAlias' }
      & Pick<GeneAlias, 'name'>
    )>>, lifecycleActions: (
      { __typename?: 'Lifecycle' }
      & { lastCommentedOn?: Maybe<(
        { __typename?: 'Event' }
        & Pick<Event, 'createdAt' | 'id'>
        & { organization: (
          { __typename?: 'Organization' }
          & Pick<Organization, 'id' | 'name'>
        ), originatingUser: (
          { __typename?: 'User' }
          & Pick<User, 'id' | 'name'>
        ) }
      )>, lastModified?: Maybe<(
        { __typename?: 'Event' }
        & Pick<Event, 'createdAt' | 'id'>
        & { organization: (
          { __typename?: 'Organization' }
          & Pick<Organization, 'id' | 'name'>
        ), originatingUser: (
          { __typename?: 'User' }
          & Pick<User, 'id' | 'name'>
        ) }
      )>, lastReviewed?: Maybe<(
        { __typename?: 'Event' }
        & Pick<Event, 'createdAt' | 'id'>
        & { organization: (
          { __typename?: 'Organization' }
          & Pick<Organization, 'id' | 'name'>
        ), originatingUser: (
          { __typename?: 'User' }
          & Pick<User, 'id' | 'name'>
        ) }
      )> }
    ), sources?: Maybe<Array<(
      { __typename?: 'Source' }
      & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'sourceType'>
    )>>, variants?: Maybe<(
      { __typename?: 'VariantConnection' }
      & { edges?: Maybe<Array<Maybe<(
        { __typename?: 'VariantEdge' }
        & { node?: Maybe<(
          { __typename?: 'Variant' }
          & Pick<Variant, 'id' | 'name' | 'description'>
        )> }
      )>>> }
    )>, comments?: Maybe<(
      { __typename?: 'CommentConnection' }
      & { edges?: Maybe<Array<Maybe<(
        { __typename?: 'CommentEdge' }
        & { node?: Maybe<(
          { __typename?: 'Comment' }
          & Pick<Comment, 'id' | 'createdAt' | 'title' | 'comment'>
          & { commentor: (
            { __typename?: 'User' }
            & Pick<User, 'id' | 'name' | 'profileImagePath' | 'role'>
            & { organizations?: Maybe<Array<(
              { __typename?: 'Organization' }
              & Pick<Organization, 'id' | 'name'>
            )>> }
          ) }
        )> }
      )>>> }
    )>, revisions?: Maybe<(
      { __typename?: 'RevisionConnection' }
      & { edges?: Maybe<Array<Maybe<(
        { __typename?: 'RevisionEdge' }
        & { node?: Maybe<(
          { __typename?: 'Revision' }
          & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
          & { linkoutData: (
            { __typename?: 'LinkoutData' }
            & Pick<LinkoutData, 'name'>
            & { diffValue: (
              { __typename?: 'ObjectFieldDiff' }
              & { addedObjects: Array<(
                { __typename?: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, removedObjects: Array<(
                { __typename?: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, keptObjects: Array<(
                { __typename?: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )> }
            ) | (
              { __typename?: 'ScalarField' }
              & Pick<ScalarField, 'value'>
            ) }
          ), revisor: (
            { __typename?: 'User' }
            & Pick<User, 'id' | 'name'>
          ) }
        )> }
      )>>> }
    )> }
  )> }
);

export const ViewerBaseDocument = gql`
    query ViewerBase {
  viewer {
    id
    username
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class ViewerBaseGQL extends Apollo.Query<ViewerBaseQuery, ViewerBaseQueryVariables> {
    document = ViewerBaseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerFullDocument = gql`
    query ViewerFull {
  viewer {
    id
    username
    name
    email
    bio
    url
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class ViewerFullGQL extends Apollo.Query<ViewerFullQuery, ViewerFullQueryVariables> {
    document = ViewerFullDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseGenesDocument = gql`
    query BrowseGenes($entrezSymbol: String, $drugName: String, $geneAlias: String, $diseaseName: String, $sortBy: GenesSort, $first: Int, $last: Int, $before: String, $after: String) {
  browseGenes(
    entrezSymbol: $entrezSymbol
    drugName: $drugName
    geneAlias: $geneAlias
    diseaseName: $diseaseName
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    nodes {
      id
      name
    }
    edges {
      cursor
      node {
        id
        entrezId
        name
        aliases {
          name
        }
        diseases {
          name
        }
        drugs {
          name
        }
        variantCount
        evidenceItemCount
        assertionCount
      }
    }
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    totalCount
    filteredCount
    pageCount
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class BrowseGenesGQL extends Apollo.Query<BrowseGenesQuery, BrowseGenesQueryVariables> {
    document = BrowseGenesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneDetailDocument = gql`
    query GeneDetail($geneId: ID!) {
  gene(id: $geneId) {
    description
    entrezId
    aliases {
      name
    }
    id
    lifecycleActions {
      lastCommentedOn {
        createdAt
        id
        organization {
          id
          name
        }
        originatingUser {
          id
          name
        }
      }
      lastModified {
        createdAt
        id
        organization {
          id
          name
        }
        originatingUser {
          id
          name
        }
      }
      lastReviewed {
        createdAt
        id
        organization {
          id
          name
        }
        originatingUser {
          id
          name
        }
      }
    }
    name
    officialName
    sources {
      id
      citation
      sourceUrl
      sourceType
    }
    variants {
      edges {
        node {
          id
          name
          description
        }
      }
    }
    comments {
      edges {
        node {
          id
          createdAt
          title
          comment
          commentor {
            id
            name
            profileImagePath(size: 32)
            organizations {
              id
              name
            }
            role
          }
        }
      }
    }
    revisions {
      edges {
        node {
          id
          revisionsetId
          createdAt
          fieldName
          currentValue
          suggestedValue
          linkoutData {
            name
            diffValue {
              ... on ObjectFieldDiff {
                addedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                removedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                keptObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
              }
              ... on ScalarField {
                value
              }
            }
          }
          revisor {
            id
            name
          }
          status
        }
      }
    }
    myGeneInfoDetails
  }
}
    `;

  @Injectable({
    providedIn: AppModule
  })
  export class GeneDetailGQL extends Apollo.Query<GeneDetailQuery, GeneDetailQueryVariables> {
    document = GeneDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }