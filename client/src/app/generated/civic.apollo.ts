/* eslint-disable */
import { gql } from 'apollo-angular';
import { Injectable } from '@angular/core';
import * as Apollo from 'apollo-angular';
export type Maybe<T> = T | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};



/** Autogenerated input type of AcceptRevisions */
export type AcceptRevisionsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Body of an optional comment to attach to the revision on acceptance. */
  comment?: Maybe<Scalars['String']>;
  /** A list of IDs of the Revisions to accept. */
  ids?: Maybe<Array<Scalars['Int']>>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The ID of a revision set. */
  revisionSetId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of AcceptRevisions */
export type AcceptRevisionsPayload = {
  __typename: 'AcceptRevisionsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of  newly accepted Revisions. */
  revisions: Array<Revision>;
  /** A list of any revisions that were superseded by the acceptance of this one. */
  supersededRevisions: Array<Revision>;
};

export type AcmgCode = {
  __typename: 'AcmgCode';
  code: Scalars['String'];
  description: Scalars['String'];
  id: Scalars['Int'];
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** Text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The commentable to attach the comment to. Specified by ID and Type. */
  subject: CommentableInput;
  /** Optional title for the comment. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddComment */
export type AddCommentPayload = {
  __typename: 'AddCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<Comment>;
};

/** Autogenerated input type of AddDisease */
export type AddDiseaseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The DOID of the disease, if the disease is present in the Disease Ontology. */
  doid?: Maybe<Scalars['Int']>;
  /** The name of the disease. */
  name: Scalars['String'];
};

/** Autogenerated return type of AddDisease */
export type AddDiseasePayload = {
  __typename: 'AddDiseasePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created disease. */
  disease: Disease;
  /** True if the disease was newly created. False if the returned disease was already in the database. */
  new: Scalars['Boolean'];
};

/** Autogenerated input type of AddDrug */
export type AddDrugInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The name of the drug. */
  name: Scalars['String'];
  /** The NCIt ID of the drug, if the drug is present in the NCIthesaurus. */
  ncitId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddDrug */
export type AddDrugPayload = {
  __typename: 'AddDrugPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created drug. */
  drug: Drug;
  /** True if the drug was newly created. False if the returned drug was already in the database. */
  new: Scalars['Boolean'];
};

/** Autogenerated input type of AddRemoteCitation */
export type AddRemoteCitationInput = {
  /** The external id for the source to add. */
  citationId: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The origin of the external source. */
  sourceType: SourceSource;
};

/** Autogenerated return type of AddRemoteCitation */
export type AddRemoteCitationPayload = {
  __typename: 'AddRemoteCitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The stubbed in record for the newly created source. */
  newSource: SourceStub;
};

/** Autogenerated input type of AddVariant */
export type AddVariantInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The CIViC ID of the Gene to which the new variant belongs. */
  geneId: Scalars['Int'];
  /** The name of the variant to add. */
  name: Scalars['String'];
};

/** Autogenerated return type of AddVariant */
export type AddVariantPayload = {
  __typename: 'AddVariantPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** True if the variant was newly created. False if the returned variant was already in the database. */
  new: Scalars['Boolean'];
  /** The newly created Variant. */
  variant: Variant;
};

export type AdvancedSearchResult = {
  __typename: 'AdvancedSearchResult';
  permalinkId?: Maybe<Scalars['String']>;
  resultIds: Array<Scalars['Int']>;
  searchEndpoint: Scalars['String'];
};

export enum AmpLevel {
  Na = 'NA',
  TierIii = 'TIER_III',
  TierIiLevelC = 'TIER_II_LEVEL_C',
  TierIiLevelD = 'TIER_II_LEVEL_D',
  TierIv = 'TIER_IV',
  TierILevelA = 'TIER_I_LEVEL_A',
  TierILevelB = 'TIER_I_LEVEL_B'
}

export enum AreaOfExpertise {
  ClinicalScientist = 'CLINICAL_SCIENTIST',
  PatientAdvocate = 'PATIENT_ADVOCATE',
  ResearchScientist = 'RESEARCH_SCIENTIST'
}

export type Assertion = Commentable & EventOriginObject & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Assertion';
  acceptanceEvent?: Maybe<Event>;
  acmgCodes: Array<AcmgCode>;
  ampLevel?: Maybe<AmpLevel>;
  assertionDirection: AssertionDirection;
  assertionType: AssertionType;
  clinicalSignificance: AssertionClinicalSignificance;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  disease?: Maybe<Disease>;
  drugInteractionType?: Maybe<DrugInteraction>;
  drugs: Array<Drug>;
  /** List and filter events for an object */
  events: EventConnection;
  evidenceItems: Array<EvidenceItem>;
  fdaCompanionTest?: Maybe<Scalars['Boolean']>;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  name: Scalars['String'];
  nccnGuideline?: Maybe<Scalars['String']>;
  nccnGuidelineVersion?: Maybe<Scalars['String']>;
  phenotypes: Array<Phenotype>;
  regulatoryApproval?: Maybe<Scalars['Boolean']>;
  rejectionEvent?: Maybe<Event>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  status: EvidenceStatus;
  submissionEvent: Event;
  summary: Scalars['String'];
  variant: Variant;
  variantOrigin: VariantOrigin;
};


export type AssertionCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type AssertionEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type AssertionFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type AssertionRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

export enum AssertionClinicalSignificance {
  AdverseResponse = 'ADVERSE_RESPONSE',
  Benign = 'BENIGN',
  BetterOutcome = 'BETTER_OUTCOME',
  LikelyBenign = 'LIKELY_BENIGN',
  LikelyPathogenic = 'LIKELY_PATHOGENIC',
  Na = 'NA',
  Negative = 'NEGATIVE',
  Pathogenic = 'PATHOGENIC',
  PoorOutcome = 'POOR_OUTCOME',
  Positive = 'POSITIVE',
  ReducedSensitivity = 'REDUCED_SENSITIVITY',
  Resistance = 'RESISTANCE',
  Sensitivityresponse = 'SENSITIVITYRESPONSE',
  UncertainSignificance = 'UNCERTAIN_SIGNIFICANCE'
}

/** The connection type for Assertion. */
export type AssertionConnection = {
  __typename: 'AssertionConnection';
  /** A list of edges. */
  edges: Array<AssertionEdge>;
  /** A list of nodes. */
  nodes: Array<Assertion>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

export enum AssertionDirection {
  DoesNotSupport = 'DOES_NOT_SUPPORT',
  Supports = 'SUPPORTS'
}

/** An edge in a connection. */
export type AssertionEdge = {
  __typename: 'AssertionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Assertion>;
};

/** Fields on an Assertion that curators may propose revisions to. */
export type AssertionFields = {
  /** List of CIViC IDs for the ACMG/AMP codes associated with this Assertion */
  acmgCodeIds: Array<Scalars['Int']>;
  /** The AMP/ASCO/CAP Category for this assertion. */
  ampLevel: NullableAmpLevelTypeInput;
  /** The evidence direction for this Assertion. */
  assertionDirection: AssertionDirection;
  /** The Type of the Assertion */
  assertionType: AssertionType;
  /** The Clinical Significance of the Assertion */
  clinicalSignificance: AssertionClinicalSignificance;
  /** A detailed description of the Assertion including practice guidelines and approved tests. */
  description: NullableStringInput;
  /** The ID of the disease (if applicable) for this Assertion */
  diseaseId: NullableIntInput;
  /** List of IDs of CIViC Drug entries for this Assertion. An empty list indicates none. */
  drugIds: Array<Scalars['Int']>;
  /** Drug interaction type for cases where more than one drug ID is provided. */
  drugInteractionType: NullableDrugInteractionTypeInput;
  /** IDs of evidence items that are included in this Assertion. */
  evidenceItemIds: Array<Scalars['Int']>;
  /** Is an FDA companion test available that pertains to this Assertion. */
  fdaCompanionTest: Scalars['Boolean'];
  /** Does the Assertion have FDA regulatory approval. */
  fdaRegulatoryApproval: Scalars['Boolean'];
  /** The ID of the Gene to which this Assertion belongs */
  geneId: Scalars['Int'];
  /** The internal CIViC ID of the NCCN guideline associated with this Assertion */
  nccnGuidelineId: NullableIntInput;
  /** The version of the NCCN Guideline specified */
  nccnGuidelineVersion: NullableStringInput;
  /** List of IDs of CIViC Phenotype entries for this Assertion. An empty list indicates none. */
  phenotypeIds: Array<Scalars['Int']>;
  /** A brief single sentence statement summarizing the clinical significance of this Assertion. */
  summary: NullableStringInput;
  /** The ID of the Variant to which this Assertion belongs */
  variantId: Scalars['Int'];
  /** The Variant Origin for this Assertion. */
  variantOrigin: VariantOrigin;
};

export type AssertionSort = {
  /** Available columns for sorting */
  column: AssertionSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum AssertionSortColumns {
  AmpLevel = 'AMP_LEVEL',
  AssertionDirection = 'ASSERTION_DIRECTION',
  AssertionType = 'ASSERTION_TYPE',
  ClinicalSignificance = 'CLINICAL_SIGNIFICANCE',
  DiseaseName = 'DISEASE_NAME',
  DrugName = 'DRUG_NAME',
  GeneName = 'GENE_NAME',
  Id = 'ID',
  Status = 'STATUS',
  Summary = 'SUMMARY',
  VariantName = 'VARIANT_NAME'
}

export enum AssertionType {
  Diagnostic = 'DIAGNOSTIC',
  Predictive = 'PREDICTIVE',
  Predisposing = 'PREDISPOSING',
  Prognostic = 'PROGNOSTIC'
}

export enum BooleanOperator {
  And = 'AND',
  Or = 'OR'
}

export type BooleanSearchInput = {
  value: Scalars['Boolean'];
};

export type BrowseClinicalTrial = {
  __typename: 'BrowseClinicalTrial';
  evidenceCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nctId?: Maybe<Scalars['String']>;
  sourceCount: Scalars['Int'];
  url?: Maybe<Scalars['String']>;
};

/** The connection type for BrowseClinicalTrial. */
export type BrowseClinicalTrialConnection = {
  __typename: 'BrowseClinicalTrialConnection';
  /** A list of edges. */
  edges: Array<BrowseClinicalTrialEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseClinicalTrial>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseClinicalTrialEdge = {
  __typename: 'BrowseClinicalTrialEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseClinicalTrial>;
};

export type BrowseDisease = {
  __typename: 'BrowseDisease';
  assertionCount: Scalars['Int'];
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['String']>;
  evidenceItemCount: Scalars['Int'];
  geneCount: Scalars['Int'];
  geneNames: Array<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseDisease. */
export type BrowseDiseaseConnection = {
  __typename: 'BrowseDiseaseConnection';
  /** A list of edges. */
  edges: Array<BrowseDiseaseEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseDisease>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseDiseaseEdge = {
  __typename: 'BrowseDiseaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseDisease>;
};

export type BrowseDrug = {
  __typename: 'BrowseDrug';
  assertionCount: Scalars['Int'];
  drugUrl?: Maybe<Scalars['String']>;
  evidenceCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

/** The connection type for BrowseDrug. */
export type BrowseDrugConnection = {
  __typename: 'BrowseDrugConnection';
  /** A list of edges. */
  edges: Array<BrowseDrugEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseDrug>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseDrugEdge = {
  __typename: 'BrowseDrugEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseDrug>;
};

export type BrowseGene = {
  __typename: 'BrowseGene';
  assertionCount: Scalars['Int'];
  description: Scalars['String'];
  diseases?: Maybe<Array<Disease>>;
  drugs?: Maybe<Array<Drug>>;
  entrezId: Scalars['Int'];
  evidenceItemCount: Scalars['Int'];
  geneAliases?: Maybe<Array<Scalars['String']>>;
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseGene. */
export type BrowseGeneConnection = {
  __typename: 'BrowseGeneConnection';
  /** A list of edges. */
  edges: Array<BrowseGeneEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseGene>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseGeneEdge = {
  __typename: 'BrowseGeneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseGene>;
};

export type BrowsePhenotype = {
  __typename: 'BrowsePhenotype';
  assertionCount: Scalars['Int'];
  evidenceCount: Scalars['Int'];
  hpoId: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  url: Scalars['String'];
};

/** The connection type for BrowsePhenotype. */
export type BrowsePhenotypeConnection = {
  __typename: 'BrowsePhenotypeConnection';
  /** A list of edges. */
  edges: Array<BrowsePhenotypeEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowsePhenotype>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowsePhenotypeEdge = {
  __typename: 'BrowsePhenotypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowsePhenotype>;
};

export type BrowseSource = {
  __typename: 'BrowseSource';
  authors: Array<Scalars['String']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials: Array<ClinicalTrial>;
  displayType: Scalars['String'];
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  journal?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  publicationYear?: Maybe<Scalars['Int']>;
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
};

/** The connection type for BrowseSource. */
export type BrowseSourceConnection = {
  __typename: 'BrowseSourceConnection';
  /** A list of edges. */
  edges: Array<BrowseSourceEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseSource>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseSourceEdge = {
  __typename: 'BrowseSourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseSource>;
};

export type BrowseVariant = {
  __typename: 'BrowseVariant';
  aliases: Array<VariantAlias>;
  assertionCount: Scalars['Int'];
  diseases: Array<Disease>;
  drugs: Array<Drug>;
  evidenceItemCount: Scalars['Int'];
  evidenceScore: Scalars['Float'];
  geneId: Scalars['Int'];
  geneName: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** The connection type for BrowseVariant. */
export type BrowseVariantConnection = {
  __typename: 'BrowseVariantConnection';
  /** A list of edges. */
  edges: Array<BrowseVariantEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseVariant>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseVariantEdge = {
  __typename: 'BrowseVariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseVariant>;
};

export type BrowseVariantGroup = {
  __typename: 'BrowseVariantGroup';
  evidenceItemCount: Scalars['Int'];
  geneNames: Array<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
  variantNames: Array<Scalars['String']>;
};

/** The connection type for BrowseVariantGroup. */
export type BrowseVariantGroupConnection = {
  __typename: 'BrowseVariantGroupConnection';
  /** A list of edges. */
  edges: Array<BrowseVariantGroupEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseVariantGroup>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseVariantGroupEdge = {
  __typename: 'BrowseVariantGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseVariantGroup>;
};

export type BrowseVariantType = {
  __typename: 'BrowseVariantType';
  id: Scalars['Int'];
  name: Scalars['String'];
  soid: Scalars['String'];
  url?: Maybe<Scalars['String']>;
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseVariantType. */
export type BrowseVariantTypeConnection = {
  __typename: 'BrowseVariantTypeConnection';
  /** A list of edges. */
  edges: Array<BrowseVariantTypeEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseVariantType>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseVariantTypeEdge = {
  __typename: 'BrowseVariantTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseVariantType>;
};

/** Counts of CIViC activity over time, used for the homepage */
export type CivicTimepointStats = {
  __typename: 'CivicTimepointStats';
  assertions: TimePointCounts;
  comments: TimePointCounts;
  diseases: TimePointCounts;
  drugs: TimePointCounts;
  evidenceItems: TimePointCounts;
  genes: TimePointCounts;
  revisions: TimePointCounts;
  sources: TimePointCounts;
  users: TimePointCounts;
  variants: TimePointCounts;
};

export type ClinicalTrial = {
  __typename: 'ClinicalTrial';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nctId: Scalars['String'];
  url?: Maybe<Scalars['String']>;
};

export type ClinicalTrialSort = {
  /** Available columns for sorting */
  column: ClinicalTrialSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum ClinicalTrialSortColumns {
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  Name = 'NAME',
  NctId = 'NCT_ID',
  SourceCount = 'SOURCE_COUNT'
}

/**
 * An input object representing possible ClinVar ID states.
 * You may specify either one or more Integer IDs OR either none found or not applicable.
 */
export type ClinvarInput = {
  /** The ClinVar ID(s) */
  ids?: Maybe<Array<Scalars['Int']>>;
  noneFound?: Maybe<Scalars['Boolean']>;
  notApplicable?: Maybe<Scalars['Boolean']>;
};

export type Coi = {
  __typename: 'Coi';
  coiPresent: Scalars['Boolean'];
  coiStatement?: Maybe<Scalars['String']>;
  coiStatus: CoiStatus;
  createdAt?: Maybe<Scalars['ISO8601DateTime']>;
  expiresAt: Scalars['ISO8601DateTime'];
  id: Scalars['Int'];
};

export enum CoiStatus {
  Conflict = 'CONFLICT',
  Expired = 'EXPIRED',
  Missing = 'MISSING',
  Valid = 'VALID'
}

export type Comment = EventOriginObject & {
  __typename: 'Comment';
  comment: Scalars['String'];
  commentable: Commentable;
  commenter: User;
  createdAt: Scalars['ISO8601DateTime'];
  creationEvent?: Maybe<Event>;
  id: Scalars['Int'];
  name: Scalars['String'];
  parsedComment: Array<CommentBodySegment>;
  title?: Maybe<Scalars['String']>;
};

/** Segment of a comment that can either be text or an object to be rendered as a tag */
export type CommentBodySegment = CommentTagSegment | CommentTextSegment | User;

/** The connection type for Comment. */
export type CommentConnection = {
  __typename: 'CommentConnection';
  /** A list of edges. */
  edges: Array<CommentEdge>;
  /** List of entities mentioned in this comment thread. */
  mentionedEntities: Array<CommentTagSegment>;
  /** List of roles mentioned in this comment thread */
  mentionedRoles: Array<CommentTagSegment>;
  /** List of users mentioned in this comment thread. */
  mentionedUsers: Array<User>;
  /** A list of nodes. */
  nodes: Array<Comment>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /**
   * When filtered on a subject, the total number of comments for that subject,
   * irregardless of other filters. Returns null when there is no subject.
   */
  unfilteredCountForSubject?: Maybe<Scalars['Int']>;
  /** List of all users that have commented on this entity. */
  uniqueCommenters: Array<User>;
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

export type CommentTagSegment = {
  __typename: 'CommentTagSegment';
  displayName: Scalars['String'];
  entityId: Scalars['Int'];
  status?: Maybe<EvidenceStatus>;
  tagType: TaggableEntity;
};

export type CommentTextSegment = {
  __typename: 'CommentTextSegment';
  text: Scalars['String'];
};

/** A CIViC entity that can have comments on it. */
export type Commentable = {
  /** List and filter comments. */
  comments: CommentConnection;
  id: Scalars['Int'];
  lastCommentEvent?: Maybe<Event>;
  name: Scalars['String'];
};


/** A CIViC entity that can have comments on it. */
export type CommentableCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum CommentableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Entity to comment on */
export type CommentableInput = {
  /** The type of the entity to comment on. */
  entityType: CommentableEntities;
  /** ID of the entity to comment on. */
  id: Scalars['Int'];
};

/** A user with all the unique kinds of actions they've performed on a given entity */
export type ContributingUser = {
  __typename: 'ContributingUser';
  lastActionDate: Scalars['ISO8601DateTime'];
  totalActionCount: Scalars['Int'];
  uniqueActions: Array<Contribution>;
  user: User;
};

export type ContributingUsersSummary = {
  __typename: 'ContributingUsersSummary';
  curators: Array<ContributingUser>;
  editors: Array<ContributingUser>;
};

export type Contribution = {
  __typename: 'Contribution';
  action: EventAction;
  count: Scalars['Int'];
};

export type Coordinate = {
  __typename: 'Coordinate';
  chromosome?: Maybe<Scalars['String']>;
  referenceBases?: Maybe<Scalars['String']>;
  representativeTranscript?: Maybe<Scalars['String']>;
  start?: Maybe<Scalars['Int']>;
  stop?: Maybe<Scalars['Int']>;
  variantBases?: Maybe<Scalars['String']>;
};

export type CoordinateInput = {
  chromosome?: Maybe<Scalars['String']>;
  representativeTranscript?: Maybe<Scalars['String']>;
  start?: Maybe<Scalars['Int']>;
  stop?: Maybe<Scalars['Int']>;
};

export type Country = {
  __typename: 'Country';
  id: Scalars['Int'];
  iso: Scalars['String'];
  name: Scalars['String'];
};

export type DataRelease = {
  __typename: 'DataRelease';
  acceptedAndSubmittedVariantsVcf?: Maybe<DownloadableFile>;
  acceptedVariantsVcf?: Maybe<DownloadableFile>;
  assertionTsv?: Maybe<DownloadableFile>;
  evidenceTsv?: Maybe<DownloadableFile>;
  geneTsv?: Maybe<DownloadableFile>;
  name: Scalars['String'];
  variantGroupTsv?: Maybe<DownloadableFile>;
  variantTsv?: Maybe<DownloadableFile>;
};

export type DateSort = {
  /** Value to sort by. */
  column: DateSortColumns;
  /** Sort direction. */
  direction: SortDirection;
};

export enum DateSortColumns {
  Created = 'CREATED',
  LastModified = 'LAST_MODIFIED'
}

export type Disease = {
  __typename: 'Disease';
  diseaseAliases: Array<Scalars['String']>;
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  name: Scalars['String'];
};

export type DiseasePopover = {
  __typename: 'DiseasePopover';
  assertionCount: Scalars['Int'];
  diseaseAliases: Array<Scalars['String']>;
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['Int']>;
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

export type DiseasesSort = {
  /** Available columns for sorting */
  column: DiseasesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum DiseasesSortColumns {
  AssertionCount = 'ASSERTION_COUNT',
  Doid = 'DOID',
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  GeneCount = 'GENE_COUNT',
  Name = 'NAME',
  VariantCount = 'VARIANT_COUNT'
}

export type DownloadableFile = {
  __typename: 'DownloadableFile';
  filename: Scalars['String'];
  path: Scalars['String'];
};

export type Drug = {
  __typename: 'Drug';
  drugAliases: Array<Scalars['String']>;
  drugUrl?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

export enum DrugInteraction {
  Combination = 'COMBINATION',
  Sequential = 'SEQUENTIAL',
  Substitutes = 'SUBSTITUTES'
}

export type DrugPopover = {
  __typename: 'DrugPopover';
  assertionCount: Scalars['Int'];
  drugAliases: Array<Scalars['String']>;
  drugUrl?: Maybe<Scalars['String']>;
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

export type DrugSort = {
  /** Available columns for sorting */
  column: DrugSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum DrugSortColumns {
  AssertionCount = 'ASSERTION_COUNT',
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  Name = 'NAME',
  NcitId = 'NCIT_ID'
}

/** Autogenerated input type of EditUser */
export type EditUserInput = {
  /** The user's area of expertise */
  areaOfExpertise: NullableAreaOfExpertiseTypeInput;
  /**
   * A short biography describing the user's interests, accomplishments,
   * associations, and/or anything else about they would like to share with the
   * CIViC community.
   */
  bio: NullableStringInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The internal CIViC ID of the country the user resides or studies in. */
  countryId: NullableIntInput;
  /** The user's email address */
  email: Scalars['String'];
  /** The user's Facebook profile handle */
  facebookProfile: NullableStringInput;
  /** The user's LinkedIn username */
  linkedinProfile: NullableStringInput;
  /** The user's full name */
  name: NullableStringInput;
  /** The the user's ORCID (Open Research and Contributor ID) identifier */
  orcid: NullableIdInput;
  /** The user's twitter handle */
  twitterHandle: NullableStringInput;
  /** The user's personal website URL, omitting the https:// protocol part */
  url: NullableStringInput;
  /** The user's desired username */
  username: Scalars['String'];
};

/** Autogenerated return type of EditUser */
export type EditUserPayload = {
  __typename: 'EditUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

export type Event = {
  __typename: 'Event';
  action: EventAction;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['Int'];
  organization?: Maybe<Organization>;
  originatingObject?: Maybe<EventOriginObject>;
  originatingUser: User;
  subject?: Maybe<EventSubject>;
};

export enum EventAction {
  Accepted = 'ACCEPTED',
  AssertionAccepted = 'ASSERTION_ACCEPTED',
  AssertionRejected = 'ASSERTION_REJECTED',
  AssertionReverted = 'ASSERTION_REVERTED',
  AssertionSubmitted = 'ASSERTION_SUBMITTED',
  Commented = 'COMMENTED',
  CuratedSourceSuggestion = 'CURATED_SOURCE_SUGGESTION',
  Flagged = 'FLAGGED',
  FlagResolved = 'FLAG_RESOLVED',
  PublicationSuggested = 'PUBLICATION_SUGGESTED',
  Rejected = 'REJECTED',
  RejectedSourceSuggestion = 'REJECTED_SOURCE_SUGGESTION',
  RequeuedSourceSuggestion = 'REQUEUED_SOURCE_SUGGESTION',
  Reverted = 'REVERTED',
  RevisionAccepted = 'REVISION_ACCEPTED',
  RevisionRejected = 'REVISION_REJECTED',
  RevisionSuggested = 'REVISION_SUGGESTED',
  RevisionSuperseded = 'REVISION_SUPERSEDED',
  Submitted = 'SUBMITTED'
}

/** The connection type for Event. */
export type EventConnection = {
  __typename: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** List of event types that have occured on this entity. */
  eventTypes: Array<EventAction>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** List of all organizations who are involved in this event stream. */
  participatingOrganizations: Array<Organization>;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have generated an event on the subject entity. */
  uniqueParticipants: Array<User>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/**
 * The originating object for an event.
 * This is useful when the subject of an event is not the actual origin of the event.
 * For instance when you suggest a revision, the subject of the Event will be the entity being revised,
 * while the originating object will be the Revision itself.
 */
export type EventOriginObject = {
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** The subject of an event log event. */
export type EventSubject = {
  /** List and filter events for an object */
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
};


/** The subject of an event log event. */
export type EventSubjectEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** An event subject paired with a count of how many times that subject has appeared */
export type EventSubjectWithCount = {
  __typename: 'EventSubjectWithCount';
  occuranceCount: Scalars['Int'];
  subject: EventSubject;
};

export enum EvidenceClinicalSignificance {
  AdverseResponse = 'ADVERSE_RESPONSE',
  Benign = 'BENIGN',
  BetterOutcome = 'BETTER_OUTCOME',
  DominantNegative = 'DOMINANT_NEGATIVE',
  GainOfFunction = 'GAIN_OF_FUNCTION',
  LikelyBenign = 'LIKELY_BENIGN',
  LikelyPathogenic = 'LIKELY_PATHOGENIC',
  LossOfFunction = 'LOSS_OF_FUNCTION',
  Na = 'NA',
  Negative = 'NEGATIVE',
  Neomorphic = 'NEOMORPHIC',
  Pathogenic = 'PATHOGENIC',
  PoorOutcome = 'POOR_OUTCOME',
  Positive = 'POSITIVE',
  ReducedSensitivity = 'REDUCED_SENSITIVITY',
  Resistance = 'RESISTANCE',
  Sensitivityresponse = 'SENSITIVITYRESPONSE',
  UnalteredFunction = 'UNALTERED_FUNCTION',
  UncertainSignificance = 'UNCERTAIN_SIGNIFICANCE',
  Unknown = 'UNKNOWN'
}

export enum EvidenceDirection {
  DoesNotSupport = 'DOES_NOT_SUPPORT',
  Na = 'NA',
  Supports = 'SUPPORTS'
}

export type EvidenceItem = Commentable & EventOriginObject & EventSubject & Flaggable & WithRevisions & {
  __typename: 'EvidenceItem';
  acceptanceEvent?: Maybe<Event>;
  assertions: Array<Assertion>;
  clinicalSignificance: EvidenceClinicalSignificance;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  disease?: Maybe<Disease>;
  drugInteractionType?: Maybe<DrugInteraction>;
  drugs: Array<Drug>;
  /** List and filter events for an object */
  events: EventConnection;
  evidenceDirection: EvidenceDirection;
  evidenceLevel: EvidenceLevel;
  evidenceRating?: Maybe<Scalars['Int']>;
  evidenceType: EvidenceType;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  name: Scalars['String'];
  phenotypes: Array<Phenotype>;
  rejectionEvent?: Maybe<Event>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  source: Source;
  status: EvidenceStatus;
  submissionEvent: Event;
  variant: Variant;
  variantHgvs: Scalars['String'];
  variantOrigin: VariantOrigin;
};


export type EvidenceItemCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type EvidenceItemEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type EvidenceItemFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type EvidenceItemRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

/** The connection type for EvidenceItem. */
export type EvidenceItemConnection = {
  __typename: 'EvidenceItemConnection';
  /** A list of edges. */
  edges: Array<EvidenceItemEdge>;
  /** A list of nodes. */
  nodes: Array<EvidenceItem>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type EvidenceItemEdge = {
  __typename: 'EvidenceItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EvidenceItem>;
};

/** Fields on an EvidenceItem that curators may propose revisions to. */
export type EvidenceItemFields = {
  /** The Clinical Significance of the EvidenceItem */
  clinicalSignificance: EvidenceClinicalSignificance;
  /** The Evidence Items's description/summary text. */
  description: NullableStringInput;
  /** The ID of the disease (if applicable) for this EvidenceItem */
  diseaseId: NullableIntInput;
  /** List of IDs of CIViC Drug entries for this EvidenceItem. An empty list indicates none. */
  drugIds: Array<Scalars['Int']>;
  /** Drug interaction type for cases where more than one drug ID is provided. */
  drugInteractionType: NullableDrugInteractionTypeInput;
  /** The evidence direction for this EvidenceItem. */
  evidenceDirection: EvidenceDirection;
  /** The evidence level of the EvidenceItem */
  evidenceLevel: EvidenceLevel;
  /** The Type of the EvidenceItem */
  evidenceType: EvidenceType;
  /** List of IDs of CIViC Phenotype entries for this EvidenceItem. An empty list indicates none. */
  phenotypeIds: Array<Scalars['Int']>;
  /** The rating for this EvidenceItem */
  rating: Scalars['Int'];
  /** The ID of the Source from which this EvidenceItem was curated. */
  sourceId: Scalars['Int'];
  /** The ID of the Variant to which this EvidenceItem belongs */
  variantId: Scalars['Int'];
  /** The Variant Origin for this EvidenceItem. */
  variantOrigin: VariantOrigin;
};

export enum EvidenceLevel {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  E = 'E'
}

export type EvidenceSort = {
  /** Available columns for sorting */
  column: EvidenceSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum EvidenceSortColumns {
  ClinicalSignificance = 'CLINICAL_SIGNIFICANCE',
  Description = 'DESCRIPTION',
  DiseaseName = 'DISEASE_NAME',
  DrugName = 'DRUG_NAME',
  EvidenceDirection = 'EVIDENCE_DIRECTION',
  EvidenceLevel = 'EVIDENCE_LEVEL',
  EvidenceRating = 'EVIDENCE_RATING',
  EvidenceType = 'EVIDENCE_TYPE',
  GeneSymbol = 'GENE_SYMBOL',
  Id = 'ID',
  Status = 'STATUS',
  VariantName = 'VARIANT_NAME',
  VariantOrigin = 'VARIANT_ORIGIN'
}

export enum EvidenceStatus {
  Accepted = 'ACCEPTED',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export enum EvidenceType {
  Diagnostic = 'DIAGNOSTIC',
  Functional = 'FUNCTIONAL',
  Oncogenic = 'ONCOGENIC',
  Predictive = 'PREDICTIVE',
  Predisposing = 'PREDISPOSING',
  Prognostic = 'PROGNOSTIC'
}

export type FieldName = {
  __typename: 'FieldName';
  /** The user facing representation of the field name. */
  displayName: Scalars['String'];
  /** The internal server representation of the field name. */
  name: Scalars['String'];
};

export type FieldValidationError = {
  __typename: 'FieldValidationError';
  error: Scalars['String'];
  fieldName: Scalars['String'];
};

export type Flag = Commentable & EventOriginObject & {
  __typename: 'Flag';
  /** List and filter comments. */
  comments: CommentConnection;
  createdAt: Scalars['ISO8601DateTime'];
  flaggable: Flaggable;
  flaggingUser: User;
  id: Scalars['Int'];
  lastCommentEvent?: Maybe<Event>;
  name: Scalars['String'];
  openComment: Comment;
  resolutionComment?: Maybe<Comment>;
  resolvedAt?: Maybe<Scalars['ISO8601DateTime']>;
  resolvingUser?: Maybe<User>;
  state: FlagState;
};


export type FlagCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** The connection type for Flag. */
export type FlagConnection = {
  __typename: 'FlagConnection';
  /** A list of edges. */
  edges: Array<FlagEdge>;
  /** A list of nodes. */
  nodes: Array<Flag>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /**
   * When filtered on a subject, the total number of flags for that subject,
   * irregardless of other filters. Returns null when there is no subject.
   */
  unfilteredCountForSubject?: Maybe<Scalars['Int']>;
  /** List of all users that have flagged this entity. */
  uniqueFlaggingUsers: Array<User>;
  /** List of all users that have resolved a flag on this entity. */
  uniqueResolvingUsers?: Maybe<Array<User>>;
};

/** An edge in a connection. */
export type FlagEdge = {
  __typename: 'FlagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Flag>;
};

/** Autogenerated input type of FlagEntity */
export type FlagEntityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the problem you observed with this entity. */
  comment: Scalars['String'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The entity to flag, specified by its ID and type. */
  subject: FlaggableInput;
};

/** Autogenerated return type of FlagEntity */
export type FlagEntityPayload = {
  __typename: 'FlagEntityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created Flag. */
  flag?: Maybe<Flag>;
};

export enum FlagState {
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

/** A CIViC entity that can be flagged for editor attention. */
export type Flaggable = {
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
};


/** A CIViC entity that can be flagged for editor attention. */
export type FlaggableFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};

/** Enumeration of all entities in CIViC that can be flagged. */
export enum FlaggableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Entity to flag */
export type FlaggableInput = {
  /** The type of the entity to flag. */
  entityType: FlaggableEntities;
  /** The ID of the entity. */
  id: Scalars['Int'];
};

export type Gene = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Gene';
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  entrezId: Scalars['Int'];
  /** List and filter events for an object */
  events: EventConnection;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  geneAliases: Array<Scalars['String']>;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  myGeneInfoDetails?: Maybe<Scalars['JSON']>;
  name: Scalars['String'];
  officialName: Scalars['String'];
  /** List and filter revisions. */
  revisions: RevisionConnection;
  sources: Array<Source>;
  /** List and filter variants. */
  variants: VariantConnection;
};


export type GeneCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type GeneEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type GeneFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type GeneRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};


export type GeneVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

/** Fields on a Gene that curators may propose revisions to. */
export type GeneFields = {
  /** The Gene's description/summary text. */
  description: NullableStringInput;
  /** Source IDs cited by the Gene's summary. */
  sourceIds: Array<Scalars['Int']>;
};

export type GeneSearchFilter = {
  alias?: Maybe<StringSearchInput>;
  booleanOperator?: Maybe<BooleanOperator>;
  description?: Maybe<StringSearchInput>;
  entrezId?: Maybe<IntSearchInput>;
  entrezSymbol?: Maybe<StringSearchInput>;
  hasAssertion?: Maybe<BooleanSearchInput>;
  id?: Maybe<IntSearchInput>;
  openRevisionCount?: Maybe<IntSearchInput>;
  subFilters?: Maybe<Array<GeneSearchFilter>>;
};

export type GenesSort = {
  /** Available columns for sorting */
  column: GenesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum GenesSortColumns {
  AssertionCount = 'assertionCount',
  DiseaseName = 'diseaseName',
  DrugName = 'drugName',
  EntrezSymbol = 'entrezSymbol',
  EvidenceItemCount = 'evidenceItemCount',
  GeneAlias = 'geneAlias',
  VariantCount = 'variantCount'
}


export type IntSearchInput = {
  comparisonOperator: IntSearchOperator;
  value: Scalars['Int'];
};

export enum IntSearchOperator {
  /** Equal To */
  Eq = 'EQ',
  Ge = 'GE',
  Gt = 'GT',
  Le = 'LE',
  Lt = 'LT',
  Ne = 'NE'
}


export type LinkoutData = {
  __typename: 'LinkoutData';
  currentValue: ModeratedField;
  diffValue: ModeratedFieldDiff;
  name: Scalars['String'];
  suggestedValue: ModeratedField;
};

/** Autogenerated input type of ModerateAssertion */
export type ModerateAssertionInput = {
  /** ID of the Assertion to moderate */
  assertionId: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The desired status of the Assertion */
  newStatus: EvidenceStatus;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of ModerateAssertion */
export type ModerateAssertionPayload = {
  __typename: 'ModerateAssertionPayload';
  /** The moderated Assertion */
  assertion: Assertion;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ModerateEvidenceItem */
export type ModerateEvidenceItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** ID of the Evidence Item to moderate */
  evidenceItemId: Scalars['Int'];
  /** The desired status of the Evidence Item */
  newStatus: EvidenceStatus;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of ModerateEvidenceItem */
export type ModerateEvidenceItemPayload = {
  __typename: 'ModerateEvidenceItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The moderated Evidence Item */
  evidenceItem: EvidenceItem;
};

/** Enumeration of all moderated CIViC entities. */
export enum ModeratedEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedField = ObjectField | ScalarField;

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedFieldDiff = ObjectFieldDiff | ScalarFieldDiff;

/** Entity to moderate. */
export type ModeratedInput = {
  /** Type of moderated entity. */
  entityType: ModeratedEntities;
  /** ID of moderated entity. */
  id: Scalars['Int'];
};

export type ModeratedObjectField = {
  __typename: 'ModeratedObjectField';
  displayName: Scalars['String'];
  displayType?: Maybe<Scalars['String']>;
  entityType: Scalars['String'];
  id: Scalars['Int'];
};

export type Mutation = {
  __typename: 'Mutation';
  /**
   * Accept multiple revisions by ID. The accepting user must be an editor with a
   * valid conflict of interest statement on file and the revisions must not be
   * their own. The revisions must be for the same subject. The revisions may not
   * conflict, i.e. be for the same field.
   */
  acceptRevisions?: Maybe<AcceptRevisionsPayload>;
  /** Add a comment to any commentable entity. */
  addComment?: Maybe<AddCommentPayload>;
  /** Add a new disease to the database. */
  addDisease?: Maybe<AddDiseasePayload>;
  /** Add a new drug to the database. */
  addDrug?: Maybe<AddDrugPayload>;
  /**
   * Add a stub record for an external source that is not yet in CiVIC.
   * This is for adding a new Source inline while performing other curation activities
   * such as adding new evidence items and is distinct from suggesting a source for curation.
   */
  addRemoteCitation?: Maybe<AddRemoteCitationPayload>;
  /** Add a new Variant to the database. */
  addVariant?: Maybe<AddVariantPayload>;
  /** Updated currently logged in Users's profile */
  editUser?: Maybe<EditUserPayload>;
  /** Flag an entity to signal to the editorial team that you believe there is an issue with it. */
  flagEntity?: Maybe<FlagEntityPayload>;
  /** Perform moderation actions on an assertion such as accepting, rejecting, or reverting. */
  moderateAssertion?: Maybe<ModerateAssertionPayload>;
  /** Perform moderation actions on an evidence item such as accepting, rejecting, or reverting. */
  moderateEvidenceItem?: Maybe<ModerateEvidenceItemPayload>;
  /**
   * Reject one or more revisions by ID or revision set ID. Any user may reject a
   * Revision that they submitted themselves. Otherwise, the rejecting user must be
   * an editor with valid conflict of interest statement on file.
   */
  rejectRevisions?: Maybe<RejectRevisionsPayload>;
  /**
   * Resolve a flag on a CIViC entity indicating that it was either erronously flagged or the issue has been resolved.
   * Any user may resolve their own flag however only editors with valid conflict
   * of interest statements can resolve other flags.
   */
  resolveFlag?: Maybe<ResolveFlagPayload>;
  /** Propose adding a new Assertion to the CIViC database. */
  submitAssertion?: Maybe<SubmitAssertionPayload>;
  /** Propose adding a new EvidenceItem to the CIViC database. */
  submitEvidence?: Maybe<SubmitEvidenceItemPayload>;
  /** Subscribe to a CIViC entity in order to receive notifications about it. */
  subscribe?: Maybe<SubscribePayload>;
  /** Suggest a Revision to an Assertion entity. */
  suggestAssertionRevision?: Maybe<SuggestAssertionRevisionPayload>;
  /** Suggest a Revision to an EvidenceItem entity. */
  suggestEvidenceItemRevision?: Maybe<SuggestEvidenceItemRevisionPayload>;
  /** Suggest a Revision to a Gene entity. */
  suggestGeneRevision?: Maybe<SuggestGeneRevisionPayload>;
  /** Suggest a source for curation in CIViC. */
  suggestSource?: Maybe<SuggestSourcePayload>;
  /** Suggest a Revision to a Variant entity. */
  suggestVariantRevision?: Maybe<SuggestVariantRevisionPayload>;
  /** Unsubscribe from a CIViC entity to stop receiving notifications about it. */
  unsubscribe?: Maybe<UnsubscribePayload>;
  /** Update the currentlly logged in User's Conflict of Interest statement */
  updateCoi?: Maybe<UpdateCoiPayload>;
  /** Mark one or more notifications as read/unread. The notification IDs provided must belong to the requesting user. */
  updateNotificationStatus?: Maybe<UpdateNotificationStatusPayload>;
  /** Update the status of a SourceSuggestion by ID. The user updating the SourceSuggestion must be signed in. */
  updateSourceSuggestionStatus?: Maybe<UpdateSourceSuggestionStatusPayload>;
};


export type MutationAcceptRevisionsArgs = {
  input: AcceptRevisionsInput;
};


export type MutationAddCommentArgs = {
  input: AddCommentInput;
};


export type MutationAddDiseaseArgs = {
  input: AddDiseaseInput;
};


export type MutationAddDrugArgs = {
  input: AddDrugInput;
};


export type MutationAddRemoteCitationArgs = {
  input: AddRemoteCitationInput;
};


export type MutationAddVariantArgs = {
  input: AddVariantInput;
};


export type MutationEditUserArgs = {
  input: EditUserInput;
};


export type MutationFlagEntityArgs = {
  input: FlagEntityInput;
};


export type MutationModerateAssertionArgs = {
  input: ModerateAssertionInput;
};


export type MutationModerateEvidenceItemArgs = {
  input: ModerateEvidenceItemInput;
};


export type MutationRejectRevisionsArgs = {
  input: RejectRevisionsInput;
};


export type MutationResolveFlagArgs = {
  input: ResolveFlagInput;
};


export type MutationSubmitAssertionArgs = {
  input: SubmitAssertionInput;
};


export type MutationSubmitEvidenceArgs = {
  input: SubmitEvidenceItemInput;
};


export type MutationSubscribeArgs = {
  input: SubscribeInput;
};


export type MutationSuggestAssertionRevisionArgs = {
  input: SuggestAssertionRevisionInput;
};


export type MutationSuggestEvidenceItemRevisionArgs = {
  input: SuggestEvidenceItemRevisionInput;
};


export type MutationSuggestGeneRevisionArgs = {
  input: SuggestGeneRevisionInput;
};


export type MutationSuggestSourceArgs = {
  input: SuggestSourceInput;
};


export type MutationSuggestVariantRevisionArgs = {
  input: SuggestVariantRevisionInput;
};


export type MutationUnsubscribeArgs = {
  input: UnsubscribeInput;
};


export type MutationUpdateCoiArgs = {
  input: UpdateCoiInput;
};


export type MutationUpdateNotificationStatusArgs = {
  input: UpdateNotificationStatusInput;
};


export type MutationUpdateSourceSuggestionStatusArgs = {
  input: UpdateSourceSuggestionStatusInput;
};

export type MyVariantInfo = {
  __typename: 'MyVariantInfo';
  caddConsequence: Array<Scalars['String']>;
  caddDetail: Array<Scalars['String']>;
  caddScore?: Maybe<Scalars['Float']>;
  clinvarClinicalSignificance: Array<Scalars['String']>;
  clinvarHgvsCoding: Array<Scalars['String']>;
  clinvarHgvsGenomic: Array<Scalars['String']>;
  clinvarHgvsNonCoding: Array<Scalars['String']>;
  clinvarHgvsProtein: Array<Scalars['String']>;
  clinvarId?: Maybe<Scalars['Int']>;
  clinvarOmim?: Maybe<Scalars['String']>;
  cosmicId?: Maybe<Scalars['String']>;
  dbnsfpInterproDomain: Array<Scalars['String']>;
  dbsnpRsid?: Maybe<Scalars['String']>;
  eglClass?: Maybe<Scalars['String']>;
  eglHgvs: Array<Scalars['String']>;
  eglProtein?: Maybe<Scalars['String']>;
  eglTranscript?: Maybe<Scalars['String']>;
  exacAlleleCount?: Maybe<Scalars['Int']>;
  exacAlleleFrequency?: Maybe<Scalars['Float']>;
  exacAlleleNumber?: Maybe<Scalars['Int']>;
  fathmmMklPrediction?: Maybe<Scalars['String']>;
  fathmmMklScore?: Maybe<Scalars['Float']>;
  fathmmPrediction: Array<Scalars['String']>;
  fathmmScore: Array<Scalars['Float']>;
  fitconsScore?: Maybe<Scalars['Float']>;
  gerp?: Maybe<Scalars['Float']>;
  gnomadExomeAlleleCount?: Maybe<Scalars['Int']>;
  gnomadExomeAlleleFrequency?: Maybe<Scalars['Float']>;
  gnomadExomeAlleleNumber?: Maybe<Scalars['Int']>;
  gnomadExomeFilter?: Maybe<Scalars['String']>;
  gnomadGenomeAlleleCount?: Maybe<Scalars['Int']>;
  gnomadGenomeAlleleFrequency?: Maybe<Scalars['Float']>;
  gnomadGenomeAlleleNumber?: Maybe<Scalars['Int']>;
  gnomadGenomeFilter?: Maybe<Scalars['String']>;
  lrtPrediction?: Maybe<Scalars['String']>;
  lrtScore?: Maybe<Scalars['Float']>;
  metalrPrediction?: Maybe<Scalars['String']>;
  metalrScore?: Maybe<Scalars['Float']>;
  metasvmPrediction?: Maybe<Scalars['String']>;
  metasvmScore?: Maybe<Scalars['Float']>;
  mutationassessorPrediction: Array<Scalars['String']>;
  mutationassessorScore: Array<Scalars['Float']>;
  mutationtasterPrediction: Array<Scalars['String']>;
  mutationtasterScore: Array<Scalars['Float']>;
  myVariantInfoId: Scalars['String'];
  phastcons100way?: Maybe<Scalars['Float']>;
  phastcons30way?: Maybe<Scalars['Float']>;
  phyloP100way?: Maybe<Scalars['Float']>;
  phyloP30way?: Maybe<Scalars['Float']>;
  polyphen2HdivPrediction: Array<Scalars['String']>;
  polyphen2HdivScore: Array<Scalars['Float']>;
  polyphen2HvarPrediction: Array<Scalars['String']>;
  polyphen2HvarScore: Array<Scalars['Float']>;
  proveanPrediction: Array<Scalars['String']>;
  proveanScore: Array<Scalars['Float']>;
  revelScore?: Maybe<Scalars['Float']>;
  siftPrediction: Array<Scalars['String']>;
  siftScore: Array<Scalars['Float']>;
  siphy?: Maybe<Scalars['Float']>;
  snpeffSnpEffect: Array<Scalars['String']>;
  snpeffSnpImpact: Array<Scalars['String']>;
};

export type NccnGuideline = {
  __typename: 'NccnGuideline';
  id: Scalars['Int'];
  name: Scalars['String'];
};

export type Notification = {
  __typename: 'Notification';
  createdAt: Scalars['ISO8601DateTime'];
  event: Event;
  id: Scalars['Int'];
  notifiedUser: User;
  originatingUser: User;
  seen: Scalars['Boolean'];
  subscription?: Maybe<Subscription>;
  type: NotificationReason;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename: 'NotificationConnection';
  /** A list of edges. */
  edges: Array<NotificationEdge>;
  /** List of event types that have occured on this entity. */
  eventTypes: Array<EventAction>;
  /** Users who have mentioned you. */
  mentioningUsers: Array<User>;
  /** A list of nodes. */
  nodes: Array<Notification>;
  /** List of subjects of the notifications in the stream */
  notificationSubjects: Array<EventSubjectWithCount>;
  /** List of all organizations who are involved in this notification stream. */
  organizations: Array<Organization>;
  /** Users who have performed an action (other than a mention) that created a notification. */
  originatingUsers: Array<User>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** Count of unread notifications */
  unreadCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

export enum NotificationReason {
  Mention = 'MENTION',
  Subscription = 'SUBSCRIPTION'
}

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableAmpLevelTypeInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<AmpLevel>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableAreaOfExpertiseTypeInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<AreaOfExpertise>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableDrugInteractionTypeInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<DrugInteraction>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableIdInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<Scalars['ID']>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableIntInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<Scalars['Int']>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableReferenceBuildTypeInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<ReferenceBuild>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableStringInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<Scalars['String']>;
};

export type ObjectField = {
  __typename: 'ObjectField';
  objects: Array<ModeratedObjectField>;
};

export type ObjectFieldDiff = {
  __typename: 'ObjectFieldDiff';
  addedObjects: Array<ModeratedObjectField>;
  currentObjects: Array<ModeratedObjectField>;
  keptObjects: Array<ModeratedObjectField>;
  removedObjects: Array<ModeratedObjectField>;
  suggestedObjects: Array<ModeratedObjectField>;
};

export type Organization = {
  __typename: 'Organization';
  description: Scalars['String'];
  eventCount: Scalars['Int'];
  events: EventConnection;
  id: Scalars['Int'];
  memberCount: Scalars['Int'];
  members: UserConnection;
  mostRecentEvent?: Maybe<Event>;
  name: Scalars['String'];
  orgAndSuborgsStatsHash: Stats;
  orgStatsHash: Stats;
  profileImagePath?: Maybe<Scalars['String']>;
  subGroups: Array<Organization>;
  url: Scalars['String'];
};


export type OrganizationEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type OrganizationMembersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type OrganizationProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** The connection type for Organization. */
export type OrganizationConnection = {
  __typename: 'OrganizationConnection';
  /** A list of edges. */
  edges: Array<OrganizationEdge>;
  /** A list of nodes. */
  nodes: Array<Organization>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename: 'OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

/** Filter on organization id and whether or not to include the organization's subgroups */
export type OrganizationFilter = {
  /** The organization ID. */
  id?: Maybe<Scalars['Int']>;
  /** Whether or not to include the organization's subgroup. */
  includeSubgroups?: Maybe<Scalars['Boolean']>;
  /** The organization name. */
  name: Scalars['String'];
};

export type OrganizationSort = {
  /** Available columns for sorting */
  column: OrganizationSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum OrganizationSortColumns {
  Id = 'ID',
  Name = 'NAME'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Phenotype = {
  __typename: 'Phenotype';
  hpoId: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  url: Scalars['String'];
};

export type PhenotypePopover = {
  __typename: 'PhenotypePopover';
  assertionCount: Scalars['Int'];
  evidenceItemCount: Scalars['Int'];
  hpoId: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  url: Scalars['String'];
};

export type PhenotypeSort = {
  /** Available columns for sorting */
  column: PhenotypeSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum PhenotypeSortColumns {
  AssertionCount = 'ASSERTION_COUNT',
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  HpoId = 'HPO_ID',
  Name = 'NAME'
}

export type Query = {
  __typename: 'Query';
  /** Retrieve ACMG Code options as a typeahead */
  acmgCodesTypeahead: Array<AcmgCode>;
  /** Find an assertion by CIViC ID */
  assertion?: Maybe<Assertion>;
  /** List and filter assertions. */
  assertions: AssertionConnection;
  browseDiseases: BrowseDiseaseConnection;
  browseGenes: BrowseGeneConnection;
  browseSources: BrowseSourceConnection;
  browseVariantGroups: BrowseVariantGroupConnection;
  browseVariants: BrowseVariantConnection;
  /** Find a clinical trial by CIViC ID */
  clinicalTrial?: Maybe<ClinicalTrial>;
  /** List and filter Clinical Trials from ClinicalTrials.gov. */
  clinicalTrials: BrowseClinicalTrialConnection;
  /** Find a comment by CIViC ID */
  comment?: Maybe<Comment>;
  /** List and filter comments. */
  comments: CommentConnection;
  contributors: ContributingUsersSummary;
  /** Fetch a list of countries for user profiles. */
  countries: Array<Country>;
  dataReleases: Array<DataRelease>;
  /** Find a disease by CIViC ID */
  disease?: Maybe<Disease>;
  /** Retrieve popover fields for a specific disease. */
  diseasePopover?: Maybe<DiseasePopover>;
  /** Retrieve disease typeahead fields for a search term. */
  diseaseTypeahead: Array<Disease>;
  /** Find a drug by CIViC ID */
  drug?: Maybe<Drug>;
  /** Retrieve popover fields for a specific drug. */
  drugPopover?: Maybe<DrugPopover>;
  /** Retrieve drug typeahead fields for a search term. */
  drugTypeahead: Array<Drug>;
  /** List and filter Drugs from the NCI Thesaurus. */
  drugs: BrowseDrugConnection;
  /** Retrieve entity type typeahead fields for a entity mention search term. */
  entityTypeahead: Array<CommentTagSegment>;
  /** List and filter events for an object */
  events: EventConnection;
  /** Find an evidence item by CIViC ID */
  evidenceItem?: Maybe<EvidenceItem>;
  /** List and filter evidence items. */
  evidenceItems: EvidenceItemConnection;
  /** Find a flag by CIViC ID */
  flag?: Maybe<Flag>;
  /** List and filter flags. */
  flags: FlagConnection;
  /** Find a gene by CIViC ID */
  gene?: Maybe<Gene>;
  /** Retrieve gene typeahead fields for a search term. */
  geneTypeahead: Array<Gene>;
  /** Retrieve NCCN Guideline options as a typeahead */
  nccnGuidelinesTypeahead: Array<NccnGuideline>;
  /** List and filter notifications for the logged in user. */
  notifications: NotificationConnection;
  /** Find an organization by CIViC ID */
  organization?: Maybe<Organization>;
  /** List and filter organizations. */
  organizations: OrganizationConnection;
  /** Find a phenotype by CIViC ID */
  phenotype?: Maybe<Phenotype>;
  /** Retrieve popover fields for a specific phenotype. */
  phenotypePopover?: Maybe<PhenotypePopover>;
  /** Retrieve phenotype typeahead fields for a search term. */
  phenotypeTypeahead: Array<Phenotype>;
  /** List and filter Phenotypes from the Human Phenotype Ontology. */
  phenotypes: BrowsePhenotypeConnection;
  previewCommentText: Array<CommentBodySegment>;
  /** Check to see if a citation ID for a source not already in CIViC exists in an external database. */
  remoteCitation?: Maybe<Scalars['String']>;
  /** Find a revision by CIViC ID */
  revision?: Maybe<Revision>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  search: Array<SearchResult>;
  searchByPermalink: AdvancedSearchResult;
  searchGenes: AdvancedSearchResult;
  /** Find a source by CIViC ID */
  source?: Maybe<Source>;
  /** Retrieve popover fields for a specific source. */
  sourcePopover?: Maybe<SourcePopover>;
  sourceSuggestions: SourceSuggestionConnection;
  /** Provide suggestions for sources based on a partial citation ID */
  sourceTypeahead: Array<Source>;
  /** Get the active subscription for the entity and logged in user, if any */
  subscriptionForEntity?: Maybe<Subscription>;
  timepointStats: CivicTimepointStats;
  user?: Maybe<User>;
  /** Retrieve user type typeahead fields for a search term. */
  userTypeahead: Array<User>;
  /** List and filter users. */
  users: UserConnection;
  validateRevisionsForAcceptance: ValidationErrors;
  /** Find a variant by CIViC ID */
  variant?: Maybe<Variant>;
  /** Find a variant group by CIViC ID */
  variantGroup?: Maybe<VariantGroup>;
  /** Find a variant type by CIViC ID */
  variantType?: Maybe<VariantType>;
  /** Retrieve popover fields for a specific variant type. */
  variantTypePopover?: Maybe<VariantTypePopover>;
  /** Retrieve variant type typeahead fields for a search term. */
  variantTypeTypeahead: Array<VariantType>;
  /** List and filter Variant Types from the Sequence Ontology. */
  variantTypes: BrowseVariantTypeConnection;
  /** List and filter variants. */
  variants: VariantConnection;
  viewer?: Maybe<User>;
};


export type QueryAcmgCodesTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryAssertionArgs = {
  id: Scalars['Int'];
};


export type QueryAssertionsArgs = {
  after?: Maybe<Scalars['String']>;
  ampLevel?: Maybe<AmpLevel>;
  assertionDirection?: Maybe<EvidenceDirection>;
  assertionType?: Maybe<EvidenceType>;
  before?: Maybe<Scalars['String']>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  diseaseId?: Maybe<Scalars['Int']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugId?: Maybe<Scalars['Int']>;
  drugName?: Maybe<Scalars['String']>;
  evidenceId?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  geneName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  phenotypeId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<AssertionSort>;
  summary?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
  variantId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
};


export type QueryBrowseDiseasesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  doid?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneNames?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DiseasesSort>;
};


export type QueryBrowseGenesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneAlias?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<GenesSort>;
};


export type QueryBrowseSourcesArgs = {
  after?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  citationId?: Maybe<Scalars['Int']>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  journal?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<SourcesSort>;
  sourceType?: Maybe<SourceSource>;
  year?: Maybe<Scalars['Int']>;
};


export type QueryBrowseVariantGroupsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneNames?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantGroupsSort>;
  variantNames?: Maybe<Scalars['String']>;
};


export type QueryBrowseVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<VariantsSort>;
  variantAlias?: Maybe<Scalars['String']>;
  variantGroupId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
  variantTypeId?: Maybe<Scalars['Int']>;
};


export type QueryClinicalTrialArgs = {
  id: Scalars['Int'];
};


export type QueryClinicalTrialsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nctId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<ClinicalTrialSort>;
};


export type QueryCommentArgs = {
  id: Scalars['Int'];
};


export type QueryCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  subject?: Maybe<CommentableInput>;
};


export type QueryContributorsArgs = {
  subscribable: SubscribableInput;
};


export type QueryDiseaseArgs = {
  id: Scalars['Int'];
};


export type QueryDiseasePopoverArgs = {
  id: Scalars['Int'];
};


export type QueryDiseaseTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryDrugArgs = {
  id: Scalars['Int'];
};


export type QueryDrugPopoverArgs = {
  id: Scalars['Int'];
};


export type QueryDrugTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryDrugsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  ncitId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DrugSort>;
};


export type QueryEntityTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  subject?: Maybe<SubscribableQueryInput>;
};


export type QueryEvidenceItemArgs = {
  id: Scalars['Int'];
};


export type QueryEvidenceItemsArgs = {
  after?: Maybe<Scalars['String']>;
  assertionId?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  diseaseId?: Maybe<Scalars['Int']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugId?: Maybe<Scalars['Int']>;
  drugName?: Maybe<Scalars['String']>;
  evidenceDirection?: Maybe<EvidenceDirection>;
  evidenceLevel?: Maybe<EvidenceLevel>;
  evidenceRating?: Maybe<Scalars['Int']>;
  evidenceType?: Maybe<EvidenceType>;
  first?: Maybe<Scalars['Int']>;
  geneSymbol?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  phenotypeId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<EvidenceSort>;
  sourceId?: Maybe<Scalars['Int']>;
  status?: Maybe<EvidenceStatus>;
  userId?: Maybe<Scalars['Int']>;
  variantId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
  variantOrigin?: Maybe<VariantOrigin>;
};


export type QueryFlagArgs = {
  id: Scalars['Int'];
};


export type QueryFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggable?: Maybe<FlaggableInput>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type QueryGeneArgs = {
  id: Scalars['Int'];
};


export type QueryGeneTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryNccnGuidelinesTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryNotificationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  includeRead?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  notificationReason?: Maybe<NotificationReason>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingObject?: Maybe<SubscribableInput>;
  originatingUserId?: Maybe<Scalars['Int']>;
  subscriptionId?: Maybe<Scalars['Int']>;
};


export type QueryOrganizationArgs = {
  id: Scalars['Int'];
};


export type QueryOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<OrganizationSort>;
};


export type QueryPhenotypeArgs = {
  id: Scalars['Int'];
};


export type QueryPhenotypePopoverArgs = {
  id: Scalars['Int'];
};


export type QueryPhenotypeTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryPhenotypesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  hpoId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<PhenotypeSort>;
};


export type QueryPreviewCommentTextArgs = {
  commentText: Scalars['String'];
};


export type QueryRemoteCitationArgs = {
  citationId: Scalars['Int'];
  sourceType: SourceSource;
};


export type QueryRevisionArgs = {
  id: Scalars['Int'];
};


export type QueryRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
  subject?: Maybe<ModeratedInput>;
};


export type QuerySearchArgs = {
  query: Scalars['String'];
};


export type QuerySearchByPermalinkArgs = {
  permalinkId: Scalars['String'];
};


export type QuerySearchGenesArgs = {
  createPermalink?: Maybe<Scalars['Boolean']>;
  query: GeneSearchFilter;
};


export type QuerySourceArgs = {
  id: Scalars['Int'];
};


export type QuerySourcePopoverArgs = {
  id: Scalars['Int'];
};


export type QuerySourceSuggestionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  citation?: Maybe<Scalars['String']>;
  citationId?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneName?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<SourceSuggestionsSort>;
  sourceId?: Maybe<Scalars['Int']>;
  sourceType?: Maybe<SourceSource>;
  status?: Maybe<SourceSuggestionStatus>;
  submitter?: Maybe<Scalars['String']>;
  submitterId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
};


export type QuerySourceTypeaheadArgs = {
  citationId: Scalars['Int'];
  sourceType: SourceSource;
};


export type QuerySubscriptionForEntityArgs = {
  subscribable: SubscribableInput;
};


export type QueryUserArgs = {
  id: Scalars['Int'];
};


export type QueryUserTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  organization?: Maybe<OrganizationFilter>;
  role?: Maybe<UserRole>;
  sortBy?: Maybe<UsersSort>;
  username?: Maybe<Scalars['String']>;
};


export type QueryValidateRevisionsForAcceptanceArgs = {
  revisionIds: Array<Scalars['Int']>;
};


export type QueryVariantArgs = {
  id: Scalars['Int'];
};


export type QueryVariantGroupArgs = {
  id: Scalars['Int'];
};


export type QueryVariantTypeArgs = {
  id: Scalars['Int'];
};


export type QueryVariantTypePopoverArgs = {
  id: Scalars['Int'];
};


export type QueryVariantTypeTypeaheadArgs = {
  queryTerm: Scalars['String'];
};


export type QueryVariantTypesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  soid?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantTypeSort>;
};


export type QueryVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  geneId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

export enum ReadStatus {
  Read = 'READ',
  Unread = 'UNREAD'
}

export enum ReferenceBuild {
  Grch37 = 'GRCH37',
  Grch38 = 'GRCH38',
  Ncbi36 = 'NCBI36'
}

/** Autogenerated input type of RejectRevisions */
export type RejectRevisionsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text explaining the reasoning for rejecting this Revision. Will be attached as a comment. */
  comment: Scalars['String'];
  /** A list of IDs of the Revisions to reject. */
  ids?: Maybe<Array<Scalars['Int']>>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The ID of a revision set. */
  revisionSetId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of RejectRevisions */
export type RejectRevisionsPayload = {
  __typename: 'RejectRevisionsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The rejected Revisions. */
  revisions: Array<Revision>;
};

/** Autogenerated input type of ResolveFlag */
export type ResolveFlagInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for resolving the flag. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the flag to resolve. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of ResolveFlag */
export type ResolveFlagPayload = {
  __typename: 'ResolveFlagPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  flag?: Maybe<Flag>;
};

export type Revision = EventOriginObject & EventSubject & {
  __typename: 'Revision';
  comments: Array<Comment>;
  createdAt: Scalars['ISO8601DateTime'];
  creationComment?: Maybe<Comment>;
  creationEvent?: Maybe<Event>;
  currentValue?: Maybe<Scalars['JSON']>;
  /** List and filter events for an object */
  events: EventConnection;
  fieldName: Scalars['String'];
  id: Scalars['Int'];
  linkoutData: LinkoutData;
  name: Scalars['String'];
  resolutionComment?: Maybe<Comment>;
  resolvedAt?: Maybe<Scalars['ISO8601DateTime']>;
  resolver?: Maybe<User>;
  resolvingEvent?: Maybe<Event>;
  revisionsetId: Scalars['String'];
  revisor?: Maybe<User>;
  status: RevisionStatus;
  suggestedValue?: Maybe<Scalars['JSON']>;
  updatedAt: Scalars['ISO8601DateTime'];
};


export type RevisionEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** The connection type for Revision. */
export type RevisionConnection = {
  __typename: 'RevisionConnection';
  /** A list of edges. */
  edges: Array<RevisionEdge>;
  /** A list of nodes. */
  nodes: Array<Revision>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** List of all fields that have at least one revision. */
  revisedFieldNames: Array<FieldName>;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /**
   * When filtered on a subject, the total number of revisions for that subject,
   * irregardless of other filters. Null when no subject provided.
   */
  unfilteredCountForSubject?: Maybe<Scalars['Int']>;
  /** List of all users that have accepted/rejected/superseded a revision to this entity. */
  uniqueResolvers: Array<User>;
  /** List of all users that have submitted a revision to this entity. */
  uniqueRevisors: Array<User>;
};

/** An edge in a connection. */
export type RevisionEdge = {
  __typename: 'RevisionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Revision>;
};

export type RevisionResult = {
  __typename: 'RevisionResult';
  /** Name of the field on the moderated entity that the Revision pertains to. */
  fieldName: Scalars['String'];
  /** ID of the Revision. */
  id: Scalars['Int'];
  /** Was this Revision newly created as a result of this request? */
  newlyCreated: Scalars['Boolean'];
  /** An identifier that can be used to group Revisions proposed at the same time. */
  revisionsetId: Scalars['String'];
};

export enum RevisionStatus {
  Accepted = 'ACCEPTED',
  New = 'NEW',
  Rejected = 'REJECTED',
  Superseded = 'SUPERSEDED'
}

export type ScalarField = {
  __typename: 'ScalarField';
  value?: Maybe<Scalars['String']>;
};

export type ScalarFieldDiff = {
  __typename: 'ScalarFieldDiff';
  left: Scalars['String'];
  right: Scalars['String'];
};

export type SearchResult = {
  __typename: 'SearchResult';
  id: Scalars['Int'];
  matchingText: Scalars['String'];
  name: Scalars['String'];
  resultType: SearchableEntities;
};

export enum SearchableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

export enum SortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type Source = EventSubject & {
  __typename: 'Source';
  abstract?: Maybe<Scalars['String']>;
  ascoAbstractId?: Maybe<Scalars['Int']>;
  authorString?: Maybe<Scalars['String']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials?: Maybe<Array<ClinicalTrial>>;
  displayType: Scalars['String'];
  /** List and filter events for an object */
  events: EventConnection;
  fullJournalTitle?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  journal: Scalars['String'];
  name: Scalars['String'];
  pmcId?: Maybe<Scalars['String']>;
  publicationDate?: Maybe<Scalars['String']>;
  publicationDay?: Maybe<Scalars['Int']>;
  publicationMonth: Scalars['Int'];
  publicationYear: Scalars['Int'];
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
  title?: Maybe<Scalars['String']>;
};


export type SourceEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export type SourcePopover = EventSubject & {
  __typename: 'SourcePopover';
  abstract?: Maybe<Scalars['String']>;
  ascoAbstractId?: Maybe<Scalars['Int']>;
  authorString?: Maybe<Scalars['String']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials?: Maybe<Array<ClinicalTrial>>;
  displayType: Scalars['String'];
  /** List and filter events for an object */
  events: EventConnection;
  evidenceItemCount: Scalars['Int'];
  fullJournalTitle?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  journal: Scalars['String'];
  name: Scalars['String'];
  pmcId?: Maybe<Scalars['String']>;
  publicationDate?: Maybe<Scalars['String']>;
  publicationDay?: Maybe<Scalars['Int']>;
  publicationMonth: Scalars['Int'];
  publicationYear: Scalars['Int'];
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
  title?: Maybe<Scalars['String']>;
};


export type SourcePopoverEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum SourceSource {
  Asco = 'ASCO',
  Pubmed = 'PUBMED'
}

export type SourceStub = {
  __typename: 'SourceStub';
  citationId: Scalars['Int'];
  id: Scalars['Int'];
  sourceType: SourceSource;
};

export type SourceSuggestion = EventOriginObject & EventSubject & {
  __typename: 'SourceSuggestion';
  diseaseName?: Maybe<Scalars['String']>;
  /** List and filter events for an object */
  events: EventConnection;
  geneName?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  initialComment: Scalars['String'];
  name: Scalars['String'];
  source: Source;
  status: SourceSuggestionStatus;
  user: User;
  variantName?: Maybe<Scalars['String']>;
};


export type SourceSuggestionEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** The connection type for SourceSuggestion. */
export type SourceSuggestionConnection = {
  __typename: 'SourceSuggestionConnection';
  /** A list of edges. */
  edges: Array<SourceSuggestionEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<SourceSuggestion>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SourceSuggestionEdge = {
  __typename: 'SourceSuggestionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SourceSuggestion>;
};

export enum SourceSuggestionStatus {
  Curated = 'CURATED',
  New = 'NEW',
  Rejected = 'REJECTED'
}

export type SourceSuggestionsSort = {
  /** Available columns for sorting */
  column: SourceSuggestionsSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum SourceSuggestionsSortColumns {
  Citation = 'CITATION',
  CitationId = 'CITATION_ID',
  DiseaseName = 'DISEASE_NAME',
  GeneName = 'GENE_NAME',
  SourceType = 'SOURCE_TYPE',
  Submitter = 'SUBMITTER',
  VariantName = 'VARIANT_NAME'
}

export type SourcesSort = {
  /** Available columns for sorting */
  column: SourcesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum SourcesSortColumns {
  Authors = 'AUTHORS',
  CitationId = 'CITATION_ID',
  EvidenceCount = 'EVIDENCE_COUNT',
  Journal = 'JOURNAL',
  Name = 'NAME',
  SourceType = 'SOURCE_TYPE',
  Year = 'YEAR'
}

export type Stats = {
  __typename: 'Stats';
  acceptedAssertions: Scalars['Int'];
  acceptedEvidenceItems: Scalars['Int'];
  appliedRevisions: Scalars['Int'];
  comments: Scalars['Int'];
  revisions: Scalars['Int'];
  submittedAssertions: Scalars['Int'];
  submittedEvidenceItems: Scalars['Int'];
  suggestedSources: Scalars['Int'];
};

export type StringSearchInput = {
  comparisonOperator: StringSearchOperator;
  value: Scalars['String'];
};

export enum StringSearchOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  Eq = 'EQ',
  Ne = 'NE',
  StartsWith = 'STARTS_WITH'
}

/** Autogenerated input type of SubmitAssertion */
export type SubmitAssertionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing any further context or details about your proposed Assertion. Will be attached as a comment. */
  comment?: Maybe<Scalars['String']>;
  /** The desired state of the Assertion's editable fields. */
  fields: AssertionFields;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SubmitAssertion */
export type SubmitAssertionPayload = {
  __typename: 'SubmitAssertionPayload';
  /** The newly created Assertion */
  assertion: Assertion;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of SubmitEvidenceItem */
export type SubmitEvidenceItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing any further context or details about your proposed EvidenceItem. Will be attached as a comment. */
  comment?: Maybe<Scalars['String']>;
  /** The desired state of the EvidenceItems's editable fields. */
  fields: EvidenceItemFields;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SubmitEvidenceItem */
export type SubmitEvidenceItemPayload = {
  __typename: 'SubmitEvidenceItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created EvidenceItem */
  evidenceItem: EvidenceItem;
};

export type Subscribable = {
  __typename: 'Subscribable';
  entityType: SubscribableEntities;
  id: Scalars['Int'];
};

/** Enumeration of all subscribable CIViC entities. */
export enum SubscribableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  SourceSuggestion = 'SOURCE_SUGGESTION',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Entity to subscribe to. */
export type SubscribableInput = {
  /** Type of subscribable entity. */
  entityType: SubscribableEntities;
  /** ID of subscribable entity. */
  id: Scalars['Int'];
};

/** Entity to subscribe to. */
export type SubscribableQueryInput = {
  /** Type of subscribable entity. */
  entityType: SubscribableEntities;
  /** ID of subscribable entity. */
  id: Scalars['Int'];
  /** Include child entities of the requested subscribable */
  includeChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of Subscribe */
export type SubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to subscribe to, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you want to subscribe to related child entities of the subscribed entities?
   * IE: If you subscribe to a Gene, do you want to receive notifications for its Variants as well?
   */
  subscribeToChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Subscribe */
export type SubscribePayload = {
  __typename: 'SubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created subscription objects. */
  subscriptions: Array<Subscription>;
};

export type Subscription = {
  __typename: 'Subscription';
  id: Scalars['Int'];
  subscribable: EventSubject;
};

/** Autogenerated input type of SuggestAssertionRevision */
export type SuggestAssertionRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Assertion's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: AssertionFields;
  /** The ID of the Assertion to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestAssertionRevision */
export type SuggestAssertionRevisionPayload = {
  __typename: 'SuggestAssertionRevisionPayload';
  /** The Assertion the user has proposed a Revision to. */
  assertion: Assertion;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of SuggestEvidenceItemRevision */
export type SuggestEvidenceItemRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the EvidenceItems's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: EvidenceItemFields;
  /** The ID of the EvidenceItem to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestEvidenceItemRevision */
export type SuggestEvidenceItemRevisionPayload = {
  __typename: 'SuggestEvidenceItemRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The EvidenceItem the user has proposed a Revision to. */
  evidenceItem: EvidenceItem;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of SuggestGeneRevision */
export type SuggestGeneRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Gene's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: GeneFields;
  /** The ID of the Gene to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestGeneRevision */
export type SuggestGeneRevisionPayload = {
  __typename: 'SuggestGeneRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Gene the user has proposed a Revision to. */
  gene: Gene;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of SuggestSource */
export type SuggestSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text explaining why this source should be curated for CIViC evidence. */
  comment: Scalars['String'];
  /** Internal CIViC ID for the applicable disease, if any. */
  diseaseId?: Maybe<Scalars['Int']>;
  /** Internal CIViC ID for the applicable gene, if any. */
  geneId?: Maybe<Scalars['Int']>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** Internal CIViC ID for the source to suggest. Use the AddRemoteCitation mutation to populate this if needed. */
  sourceId: Scalars['Int'];
  /** Name of the variant discussed in this source. */
  variantName?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of SuggestSource */
export type SuggestSourcePayload = {
  __typename: 'SuggestSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created Source Suggestion */
  sourceSuggestion: SourceSuggestion;
};

/** Autogenerated input type of SuggestVariantRevision */
export type SuggestVariantRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Variant's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: VariantFields;
  /** The ID of the Variant to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestVariantRevision */
export type SuggestVariantRevisionPayload = {
  __typename: 'SuggestVariantRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
  /** The Variant the user has proposed a Revision to. */
  variant: Variant;
};

export enum TaggableEntity {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  Role = 'ROLE',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Mentioned entity to filter comments on. */
export type TaggableEntityInput = {
  /** The type of the entity */
  entityType: TaggableEntity;
  /** ID of the mentioned entity */
  id: Scalars['Int'];
};

export type TimePointCounts = {
  __typename: 'TimePointCounts';
  allTime: Scalars['Int'];
  newThisMonth: Scalars['Int'];
  newThisWeek: Scalars['Int'];
  newThisYear: Scalars['Int'];
};

/** Autogenerated input type of Unsubscribe */
export type UnsubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to unsubscribe from, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you also wish to stop receiving notifications from child entities?
   * IE: If you unsubscribe from a Gene do you want to stop receiving notifications for its Variants as well?
   */
  unsubscribeFromChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Unsubscribe */
export type UnsubscribePayload = {
  __typename: 'UnsubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The entities that were unsubscribed from. */
  unsubscribedEntities: Array<Subscribable>;
};

/** Autogenerated input type of UpdateCoi */
export type UpdateCoiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Does the user report having a conflict of interest? Mark true if so. */
  coiPresent: Scalars['Boolean'];
  /** If the user reports a potential conflict of interest please provide a brief summary of it. */
  statement?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateCoi */
export type UpdateCoiPayload = {
  __typename: 'UpdateCoiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  coiStatement: Coi;
};

/** Autogenerated input type of UpdateNotificationStatus */
export type UpdateNotificationStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more Notification IDs. */
  ids: Array<Scalars['Int']>;
  /** The new status of the selected notifications. */
  newStatus: ReadStatus;
};

/** Autogenerated return type of UpdateNotificationStatus */
export type UpdateNotificationStatusPayload = {
  __typename: 'UpdateNotificationStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of the notifications in their new state. */
  notifications: Array<Notification>;
};

/** Autogenerated input type of UpdateSourceSuggestionStatus */
export type UpdateSourceSuggestionStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the SourceSuggestion to update. */
  id: Scalars['Int'];
  /** The desired status of the SourceSuggestion. */
  newStatus: SourceSuggestionStatus;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateSourceSuggestionStatus */
export type UpdateSourceSuggestionStatusPayload = {
  __typename: 'UpdateSourceSuggestionStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated SourceSuggestion. */
  sourceSuggestion: SourceSuggestion;
};

export type User = {
  __typename: 'User';
  areaOfExpertise?: Maybe<AreaOfExpertise>;
  bio?: Maybe<Scalars['String']>;
  country?: Maybe<Country>;
  displayName: Scalars['String'];
  email?: Maybe<Scalars['String']>;
  events: EventConnection;
  facebookProfile?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  linkedinProfile?: Maybe<Scalars['String']>;
  mostRecentActionTimestamp?: Maybe<Scalars['ISO8601DateTime']>;
  mostRecentConflictOfInterestStatement?: Maybe<Coi>;
  mostRecentEvent?: Maybe<Event>;
  mostRecentOrganizationId?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  /** Filterable list of notifications for the logged in user. */
  notifications?: Maybe<NotificationConnection>;
  orcid?: Maybe<Scalars['String']>;
  organizations: Array<Organization>;
  profileImagePath?: Maybe<Scalars['String']>;
  role: UserRole;
  statsHash: Stats;
  twitterHandle?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};


export type UserEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type UserNotificationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  includeSeen?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  notificationType?: Maybe<NotificationReason>;
  subscriptionId?: Maybe<Scalars['Int']>;
};


export type UserProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename: 'UserConnection';
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

export enum UserRole {
  Admin = 'ADMIN',
  Curator = 'CURATOR',
  Editor = 'EDITOR'
}

export type UsersSort = {
  /** Available columns for sorting */
  column: UsersSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum UsersSortColumns {
  Id = 'ID',
  LastAction = 'LAST_ACTION',
  Name = 'NAME',
  Role = 'ROLE'
}

export type ValidationErrors = {
  __typename: 'ValidationErrors';
  genericErrors: Array<Scalars['String']>;
  validationErrors: Array<FieldValidationError>;
};

export type Variant = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Variant';
  alleleRegistryId?: Maybe<Scalars['String']>;
  clinvarIds?: Maybe<Array<Scalars['String']>>;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  ensemblVersion?: Maybe<Scalars['Int']>;
  /** List and filter events for an object */
  events: EventConnection;
  evidenceItems: EvidenceItemConnection;
  evidenceScore: Scalars['Float'];
  fivePrimeCoordinates?: Maybe<Coordinate>;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  hgvsDescriptions?: Maybe<Array<Scalars['String']>>;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  myVariantInfo?: Maybe<MyVariantInfo>;
  name: Scalars['String'];
  referenceBuild?: Maybe<ReferenceBuild>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  sources: Array<Source>;
  threePrimeCoordinates?: Maybe<Coordinate>;
  variantAliases?: Maybe<Array<Scalars['String']>>;
  variantTypes?: Maybe<Array<VariantType>>;
};


export type VariantCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantEvidenceItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type VariantFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type VariantRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

export type VariantAlias = {
  __typename: 'VariantAlias';
  name: Scalars['String'];
};

/** The connection type for Variant. */
export type VariantConnection = {
  __typename: 'VariantConnection';
  /** A list of edges. */
  edges: Array<VariantEdge>;
  /** A list of nodes. */
  nodes: Array<Variant>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

export enum VariantDisplayFilter {
  /** Display all variants regardless of attached evience. */
  All = 'ALL',
  /** Display only variants which have at least one accepted evidence item. */
  WithAccepted = 'WITH_ACCEPTED',
  /** Display only variants which have evidence in either an accepted or submitted state. */
  WithAcceptedOrSubmitted = 'WITH_ACCEPTED_OR_SUBMITTED',
  /** Display variants which have at least one submited evidence item. */
  WithSubmitted = 'WITH_SUBMITTED'
}

/** An edge in a connection. */
export type VariantEdge = {
  __typename: 'VariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Variant>;
};

/** Fields on a Variant that curators may propose revisions to. */
export type VariantFields = {
  /** List of aliases or alternate names for the Variant. */
  aliases: Array<Scalars['String']>;
  /** List of ClinVar IDs for the Variant. */
  clinvarIds: ClinvarInput;
  /** The Variant's description/summary text. */
  description: NullableStringInput;
  /** The Ensembl database version. */
  ensemblVersion: Scalars['Int'];
  /** The ID of the Gene this Variant corresponds to. */
  geneId: Scalars['Int'];
  /** List of HGVS descriptions for the Variant. */
  hgvsDescriptions: Array<Scalars['String']>;
  /** The Variant's name. */
  name: Scalars['String'];
  /** The primary coordinates for this Variant. In the case of Fusions this will be the coordinates of the 5' partner. */
  primaryCoordinates: CoordinateInput;
  /** Reference bases for this variant */
  referenceBases: NullableStringInput;
  /** The reference build for the genomic coordinates of this Variant. */
  referenceBuild: NullableReferenceBuildTypeInput;
  /** In the case of Fusions these will be the coordinates of the 3' partner, otherwise set the values to null. */
  secondaryCoordinates: CoordinateInput;
  /** Source IDs cited by the Variant's summary. */
  sourceIds: Array<Scalars['Int']>;
  /** Variant bases for this variant */
  variantBases: NullableStringInput;
  /** List of IDs for the variant types for this Variant */
  variantTypeIds: Array<Scalars['Int']>;
};

export type VariantGroup = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'VariantGroup';
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  /** List and filter events for an object */
  events: EventConnection;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  name: Scalars['String'];
  /** List and filter revisions. */
  revisions: RevisionConnection;
  /** List and filter variants. */
  variants: VariantConnection;
};


export type VariantGroupCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  mentionedRole?: Maybe<UserRole>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantGroupEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantGroupFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type VariantGroupRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};


export type VariantGroupVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

export type VariantGroupsSort = {
  /** Available columns for sorting */
  column: VariantGroupsSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum VariantGroupsSortColumns {
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  GeneNames = 'GENE_NAMES',
  Name = 'NAME',
  VariantCount = 'VARIANT_COUNT',
  VariantNames = 'VARIANT_NAMES'
}

export enum VariantOrigin {
  CommonGermline = 'COMMON_GERMLINE',
  Na = 'NA',
  RareGermline = 'RARE_GERMLINE',
  Somatic = 'SOMATIC',
  Unknown = 'UNKNOWN'
}

export type VariantType = {
  __typename: 'VariantType';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  soid: Scalars['String'];
  url: Scalars['String'];
};

export type VariantTypePopover = {
  __typename: 'VariantTypePopover';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  soid: Scalars['String'];
  url: Scalars['String'];
  variantCount: Scalars['Int'];
};

export type VariantTypeSort = {
  /** Available columns for sorting */
  column: VariantTypeSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum VariantTypeSortColumns {
  Name = 'NAME',
  Soid = 'SOID',
  VariantCount = 'VARIANT_COUNT'
}

export type VariantsSort = {
  /** Available columns for sorting */
  column: VariantsSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum VariantsSortColumns {
  AssertionCount = 'assertionCount',
  DiseaseName = 'diseaseName',
  DrugName = 'drugName',
  EntrezSymbol = 'entrezSymbol',
  EvidenceItemCount = 'evidenceItemCount',
  EvidenceScore = 'evidenceScore',
  VariantName = 'variantName'
}

/** A CIViC entity that can have revisions proposed to it. */
export type WithRevisions = {
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
};


/** A CIViC entity that can have revisions proposed to it. */
export type WithRevisionsRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

export type AssertionPopoverQueryVariables = Exact<{
  assertionId: Scalars['Int'];
}>;


export type AssertionPopoverQuery = (
  { __typename: 'Query' }
  & { assertion?: Maybe<(
    { __typename: 'Assertion' }
    & AssertionPopoverFragment
  )> }
);

export type AssertionPopoverFragment = (
  { __typename: 'Assertion' }
  & Pick<Assertion, 'id' | 'name' | 'summary' | 'assertionType' | 'assertionDirection' | 'clinicalSignificance' | 'variantOrigin' | 'ampLevel' | 'nccnGuideline' | 'fdaCompanionTest' | 'regulatoryApproval' | 'drugInteractionType'>
  & { acmgCodes: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'code'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type AssertionsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  assertionDirection?: Maybe<EvidenceDirection>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  assertionType?: Maybe<EvidenceType>;
  variantId?: Maybe<Scalars['Int']>;
  evidenceId?: Maybe<Scalars['Int']>;
  geneName?: Maybe<Scalars['String']>;
  variantName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<AssertionSort>;
  ampLevel?: Maybe<AmpLevel>;
  organizationId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  phenotypeId?: Maybe<Scalars['Int']>;
  diseaseId?: Maybe<Scalars['Int']>;
  drugId?: Maybe<Scalars['Int']>;
  cardView: Scalars['Boolean'];
}>;


export type AssertionsBrowseQuery = (
  { __typename: 'Query' }
  & { assertions: (
    { __typename: 'AssertionConnection' }
    & Pick<AssertionConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'AssertionEdge' }
      & Pick<AssertionEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Assertion' }
        & AssertionBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type AssertionBrowseTableRowFieldsFragment = (
  { __typename: 'Assertion' }
  & MakeOptional<Pick<Assertion, 'id' | 'name' | 'drugInteractionType' | 'summary' | 'assertionType' | 'assertionDirection' | 'clinicalSignificance' | 'ampLevel' | 'fdaCompanionTest' | 'regulatoryApproval' | 'nccnGuideline' | 'variantOrigin'>, 'fdaCompanionTest' | 'regulatoryApproval' | 'nccnGuideline' | 'variantOrigin'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, acmgCodes: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'code'>
  )> }
);

export type ClinicalTrialPopoverQueryVariables = Exact<{
  clinicalTrialId: Scalars['Int'];
}>;


export type ClinicalTrialPopoverQuery = (
  { __typename: 'Query' }
  & { clinicalTrials: (
    { __typename: 'BrowseClinicalTrialConnection' }
    & { edges: Array<(
      { __typename: 'BrowseClinicalTrialEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowseClinicalTrial' }
        & ClinicalTrialPopoverFragment
      )> }
    )> }
  ) }
);

export type ClinicalTrialPopoverFragment = (
  { __typename: 'BrowseClinicalTrial' }
  & Pick<BrowseClinicalTrial, 'id' | 'name' | 'nctId' | 'url' | 'sourceCount' | 'evidenceCount'>
);

export type ClinicalTrialsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nctId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<ClinicalTrialSort>;
}>;


export type ClinicalTrialsBrowseQuery = (
  { __typename: 'Query' }
  & { clinicalTrials: (
    { __typename: 'BrowseClinicalTrialConnection' }
    & Pick<BrowseClinicalTrialConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowseClinicalTrialEdge' }
      & Pick<BrowseClinicalTrialEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseClinicalTrial' }
        & Pick<BrowseClinicalTrial, 'id' | 'name' | 'nctId' | 'evidenceCount' | 'sourceCount'>
      )> }
    )> }
  ) }
);

export type CommentListQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  mentionedUserId?: Maybe<Scalars['Int']>;
  mentionedRole?: Maybe<UserRole>;
  mentionedEntity?: Maybe<TaggableEntityInput>;
  subject?: Maybe<CommentableInput>;
  sortBy?: Maybe<DateSort>;
}>;


export type CommentListQuery = (
  { __typename: 'Query' }
  & { comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount' | 'unfilteredCountForSubject'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ), uniqueCommenters: Array<(
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    )>, mentionedUsers: Array<(
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    )>, mentionedRoles: Array<(
      { __typename: 'CommentTagSegment' }
      & Pick<CommentTagSegment, 'displayName' | 'entityId' | 'tagType'>
    )>, mentionedEntities: Array<(
      { __typename: 'CommentTagSegment' }
      & Pick<CommentTagSegment, 'displayName' | 'entityId' | 'tagType'>
    )>, edges: Array<(
      { __typename: 'CommentEdge' }
      & Pick<CommentEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Comment' }
        & CommentListNodeFragment
      )> }
    )> }
  ) }
);

export type CommentListNodeFragment = (
  { __typename: 'Comment' }
  & Pick<Comment, 'id' | 'title' | 'comment' | 'createdAt'>
  & { commenter: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'displayName' | 'name' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )> }
  ), parsedComment: Array<(
    { __typename: 'CommentTagSegment' }
    & Pick<CommentTagSegment, 'entityId' | 'displayName' | 'tagType' | 'status'>
  ) | (
    { __typename: 'CommentTextSegment' }
    & Pick<CommentTextSegment, 'text'>
  ) | (
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role'>
  )> }
);

export type CommentPopoverQueryVariables = Exact<{
  commentId: Scalars['Int'];
}>;


export type CommentPopoverQuery = (
  { __typename: 'Query' }
  & { comment?: Maybe<(
    { __typename: 'Comment' }
    & CommentPopoverFragment
  )> }
);

export type CommentPopoverFragment = (
  { __typename: 'Comment' }
  & Pick<Comment, 'id' | 'name' | 'createdAt' | 'title' | 'comment'>
  & { commenter: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  ), commentable: (
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'name'>
  ) | (
    { __typename: 'Flag' }
    & Pick<Flag, 'id' | 'name'>
  ) | (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ) | (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ) | (
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'id' | 'name'>
  ) }
);

export type DiseasePopoverQueryVariables = Exact<{
  diseaseId: Scalars['Int'];
}>;


export type DiseasePopoverQuery = (
  { __typename: 'Query' }
  & { diseasePopover?: Maybe<(
    { __typename: 'DiseasePopover' }
    & Pick<DiseasePopover, 'id' | 'name' | 'displayName' | 'doid' | 'diseaseUrl' | 'diseaseAliases' | 'assertionCount' | 'evidenceItemCount' | 'variantCount'>
  )> }
);

export type BrowseDiseasesQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DiseasesSort>;
  name?: Maybe<Scalars['String']>;
  doid?: Maybe<Scalars['String']>;
  geneNames?: Maybe<Scalars['String']>;
}>;


export type BrowseDiseasesQuery = (
  { __typename: 'Query' }
  & { browseDiseases: (
    { __typename: 'BrowseDiseaseConnection' }
    & Pick<BrowseDiseaseConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'hasPreviousPage' | 'startCursor'>
    ), edges: Array<(
      { __typename: 'BrowseDiseaseEdge' }
      & Pick<BrowseDiseaseEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseDisease' }
        & BrowseDiseaseRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseDiseaseRowFieldsFragment = (
  { __typename: 'BrowseDisease' }
  & Pick<BrowseDisease, 'id' | 'name' | 'doid' | 'diseaseUrl' | 'geneNames' | 'assertionCount' | 'evidenceItemCount' | 'variantCount' | 'geneCount'>
);

export type DrugPopoverQueryVariables = Exact<{
  drugId: Scalars['Int'];
}>;


export type DrugPopoverQuery = (
  { __typename: 'Query' }
  & { drugPopover?: Maybe<(
    { __typename: 'DrugPopover' }
    & Pick<DrugPopover, 'id' | 'name' | 'drugUrl' | 'ncitId' | 'drugAliases' | 'assertionCount' | 'evidenceItemCount'>
  )> }
);

export type DrugsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  ncitId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DrugSort>;
}>;


export type DrugsBrowseQuery = (
  { __typename: 'Query' }
  & { drugs: (
    { __typename: 'BrowseDrugConnection' }
    & Pick<BrowseDrugConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowseDrugEdge' }
      & Pick<BrowseDrugEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseDrug' }
        & DrugBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type DrugBrowseTableRowFieldsFragment = (
  { __typename: 'BrowseDrug' }
  & Pick<BrowseDrug, 'id' | 'name' | 'ncitId' | 'drugUrl' | 'assertionCount' | 'evidenceCount'>
);

export type EventFeedQueryVariables = Exact<{
  subject?: Maybe<SubscribableQueryInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  eventType?: Maybe<EventAction>;
}>;


export type EventFeedQuery = (
  { __typename: 'Query' }
  & { events: (
    { __typename: 'EventConnection' }
    & EventFeedFragment
  ) }
);

export type EventFeedFragment = (
  { __typename: 'EventConnection' }
  & Pick<EventConnection, 'eventTypes'>
  & { pageInfo: (
    { __typename: 'PageInfo' }
    & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
  ), uniqueParticipants: Array<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  )>, participatingOrganizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, edges: Array<(
    { __typename: 'EventEdge' }
    & Pick<EventEdge, 'cursor'>
    & { node?: Maybe<(
      { __typename: 'Event' }
      & EventFeedNodeFragment
    )> }
  )> }
);

export type EventFeedNodeFragment = (
  { __typename: 'Event' }
  & Pick<Event, 'id' | 'action' | 'createdAt'>
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, originatingUser: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'displayName' | 'role' | 'profileImagePath'>
  ), subject?: Maybe<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'status' | 'name' | 'id'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'status' | 'name' | 'id'>
  ) | (
    { __typename: 'Gene' }
    & Pick<Gene, 'name' | 'id'>
  ) | (
    { __typename: 'Revision' }
    & Pick<Revision, 'name' | 'id'>
  ) | (
    { __typename: 'Source' }
    & Pick<Source, 'citation' | 'sourceType' | 'name' | 'id'>
  ) | (
    { __typename: 'SourcePopover' }
    & Pick<SourcePopover, 'name' | 'id'>
  ) | (
    { __typename: 'SourceSuggestion' }
    & Pick<SourceSuggestion, 'name' | 'id'>
  ) | (
    { __typename: 'Variant' }
    & Pick<Variant, 'name' | 'id'>
  ) | (
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'name' | 'id'>
  )>, originatingObject?: Maybe<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  ) | (
    { __typename: 'Comment' }
    & Pick<Comment, 'id' | 'name'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'name'>
  ) | (
    { __typename: 'Flag' }
    & Pick<Flag, 'id' | 'name'>
  ) | (
    { __typename: 'Revision' }
    & Pick<Revision, 'id' | 'name'>
  ) | (
    { __typename: 'SourceSuggestion' }
    & Pick<SourceSuggestion, 'id' | 'name'>
  )> }
);

export type EvidencePopoverQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidencePopoverQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & EvidencePopoverFragment
  )> }
);

export type EvidencePopoverFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'description' | 'evidenceLevel' | 'evidenceType' | 'evidenceDirection' | 'clinicalSignificance' | 'variantOrigin' | 'drugInteractionType' | 'evidenceRating'>
  & { drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceType' | 'displayType'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type EvidenceBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  evidenceLevel?: Maybe<EvidenceLevel>;
  evidenceDirection?: Maybe<EvidenceDirection>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  evidenceType?: Maybe<EvidenceType>;
  rating?: Maybe<Scalars['Int']>;
  variantOrigin?: Maybe<VariantOrigin>;
  variantId?: Maybe<Scalars['Int']>;
  assertionId?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<EvidenceSort>;
  phenotypeId?: Maybe<Scalars['Int']>;
  diseaseId?: Maybe<Scalars['Int']>;
  drugId?: Maybe<Scalars['Int']>;
  sourceId?: Maybe<Scalars['Int']>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
  geneSymbol?: Maybe<Scalars['String']>;
  variantName?: Maybe<Scalars['String']>;
  cardView: Scalars['Boolean'];
}>;


export type EvidenceBrowseQuery = (
  { __typename: 'Query' }
  & { evidenceItems: (
    { __typename: 'EvidenceItemConnection' }
    & Pick<EvidenceItemConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'EvidenceItemEdge' }
      & Pick<EvidenceItemEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'EvidenceItem' }
        & EvidenceGridFieldsFragment
      )> }
    )> }
  ) }
);

export type EvidenceGridFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'status' | 'drugInteractionType' | 'description' | 'evidenceType' | 'evidenceDirection' | 'evidenceLevel' | 'evidenceRating' | 'clinicalSignificance' | 'variantOrigin'>
  & { disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'citationId' | 'sourceType' | 'sourceUrl'>
    & { clinicalTrials?: Maybe<Array<(
      { __typename: 'ClinicalTrial' }
      & Pick<ClinicalTrial, 'nctId' | 'id'>
    )>> }
  ), assertions: Array<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  )> }
);

export type FlagListQueryVariables = Exact<{
  flaggable?: Maybe<FlaggableInput>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  state?: Maybe<FlagState>;
  sortBy?: Maybe<DateSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type FlagListQuery = (
  { __typename: 'Query' }
  & { flags: (
    { __typename: 'FlagConnection' }
    & FlagListFragment
  ) }
);

export type FlagListFragment = (
  { __typename: 'FlagConnection' }
  & Pick<FlagConnection, 'totalCount' | 'unfilteredCountForSubject'>
  & { pageInfo: (
    { __typename: 'PageInfo' }
    & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
  ), uniqueFlaggingUsers: Array<(
    { __typename: 'User' }
    & Pick<User, 'username' | 'id' | 'profileImagePath'>
  )>, uniqueResolvingUsers?: Maybe<Array<(
    { __typename: 'User' }
    & Pick<User, 'username' | 'id' | 'profileImagePath'>
  )>>, edges: Array<(
    { __typename: 'FlagEdge' }
    & { node?: Maybe<(
      { __typename: 'Flag' }
      & FlagFragment
    )> }
  )> }
);

export type FlagFragment = (
  { __typename: 'Flag' }
  & Pick<Flag, 'id' | 'state' | 'createdAt' | 'resolvedAt'>
  & { flaggable: (
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'name'>
  ) | (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ) | (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ) | (
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'id' | 'name'>
  ), flaggingUser: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  ), resolvingUser?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  )>, openComment: (
    { __typename: 'Comment' }
    & { parsedComment: Array<(
      { __typename: 'CommentTagSegment' }
      & Pick<CommentTagSegment, 'entityId' | 'displayName' | 'tagType'>
    ) | (
      { __typename: 'CommentTextSegment' }
      & Pick<CommentTextSegment, 'text'>
    ) | (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role'>
    )> }
  ), resolutionComment?: Maybe<(
    { __typename: 'Comment' }
    & { parsedComment: Array<(
      { __typename: 'CommentTagSegment' }
      & Pick<CommentTagSegment, 'entityId' | 'displayName' | 'tagType'>
    ) | (
      { __typename: 'CommentTextSegment' }
      & Pick<CommentTextSegment, 'text'>
    ) | (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role'>
    )> }
  )> }
);

export type GenePopoverQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GenePopoverQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & GenePopoverFragment
  )> }
);

export type GenePopoverFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'name' | 'officialName' | 'geneAliases'>
  & { variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ) }
);

export type BrowseGenesQueryVariables = Exact<{
  entrezSymbol?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  geneAlias?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<GenesSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type BrowseGenesQuery = (
  { __typename: 'Query' }
  & { browseGenes: (
    { __typename: 'BrowseGeneConnection' }
    & Pick<BrowseGeneConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { edges: Array<(
      { __typename: 'BrowseGeneEdge' }
      & Pick<BrowseGeneEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseGene' }
        & Pick<BrowseGene, 'id' | 'entrezId' | 'name' | 'geneAliases' | 'variantCount' | 'evidenceItemCount' | 'assertionCount'>
        & { diseases?: Maybe<Array<(
          { __typename: 'Disease' }
          & Pick<Disease, 'name' | 'id'>
        )>>, drugs?: Maybe<Array<(
          { __typename: 'Drug' }
          & Pick<Drug, 'name' | 'id'>
        )>> }
      )> }
    )>, pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ) }
  ) }
);

export type QuicksearchQueryVariables = Exact<{
  query: Scalars['String'];
}>;


export type QuicksearchQuery = (
  { __typename: 'Query' }
  & { search: Array<(
    { __typename: 'SearchResult' }
    & QuicksearchResultFragment
  )> }
);

export type QuicksearchResultFragment = (
  { __typename: 'SearchResult' }
  & Pick<SearchResult, 'id' | 'resultType' | 'name' | 'matchingText'>
);

export type OrgPopoverQueryVariables = Exact<{
  orgId: Scalars['Int'];
}>;


export type OrgPopoverQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & OrgPopoverFragment
  )> }
);

export type OrgPopoverFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'profileImagePath' | 'name' | 'description' | 'url'>
);

export type OrganizationsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  orgName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<OrganizationSort>;
  cardView: Scalars['Boolean'];
}>;


export type OrganizationsBrowseQuery = (
  { __typename: 'Query' }
  & { organizations: (
    { __typename: 'OrganizationConnection' }
    & Pick<OrganizationConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'OrganizationEdge' }
      & Pick<OrganizationEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Organization' }
        & OrganizationBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type OrganizationBrowseTableRowFieldsFragment = (
  { __typename: 'Organization' }
  & MakeOptional<Pick<Organization, 'id' | 'name' | 'description' | 'profileImagePath' | 'url' | 'memberCount' | 'eventCount'>, 'description' | 'profileImagePath'>
  & { subGroups: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'name' | 'id'>
  )>, mostRecentEvent?: Maybe<(
    { __typename: 'Event' }
    & Pick<Event, 'createdAt'>
  )>, orgStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ) }
);

export type PhenotypePopoverQueryVariables = Exact<{
  phenotypeId: Scalars['Int'];
}>;


export type PhenotypePopoverQuery = (
  { __typename: 'Query' }
  & { phenotypePopover?: Maybe<(
    { __typename: 'PhenotypePopover' }
    & Pick<PhenotypePopover, 'id' | 'name' | 'url' | 'hpoId' | 'assertionCount' | 'evidenceItemCount'>
  )> }
);

export type PhenotypesBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  hpoId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<PhenotypeSort>;
}>;


export type PhenotypesBrowseQuery = (
  { __typename: 'Query' }
  & { phenotypes: (
    { __typename: 'BrowsePhenotypeConnection' }
    & Pick<BrowsePhenotypeConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowsePhenotypeEdge' }
      & Pick<BrowsePhenotypeEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowsePhenotype' }
        & PhenotypeBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type PhenotypeBrowseTableRowFieldsFragment = (
  { __typename: 'BrowsePhenotype' }
  & Pick<BrowsePhenotype, 'id' | 'name' | 'hpoId' | 'url' | 'assertionCount' | 'evidenceCount'>
);

export type AcceptRevisionMutationVariables = Exact<{
  input: AcceptRevisionsInput;
}>;


export type AcceptRevisionMutation = (
  { __typename: 'Mutation' }
  & { acceptRevisions?: Maybe<(
    { __typename: 'AcceptRevisionsPayload' }
    & { revisions: Array<(
      { __typename: 'Revision' }
      & Pick<Revision, 'id'>
    )> }
  )> }
);

export type RejectRevisionMutationVariables = Exact<{
  input: RejectRevisionsInput;
}>;


export type RejectRevisionMutation = (
  { __typename: 'Mutation' }
  & { rejectRevisions?: Maybe<(
    { __typename: 'RejectRevisionsPayload' }
    & { revisions: Array<(
      { __typename: 'Revision' }
      & Pick<Revision, 'id'>
    )> }
  )> }
);

export type ValidateRevisionsForAcceptanceQueryVariables = Exact<{
  ids: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type ValidateRevisionsForAcceptanceQuery = (
  { __typename: 'Query' }
  & { validateRevisionsForAcceptance: (
    { __typename: 'ValidationErrors' }
    & Pick<ValidationErrors, 'genericErrors'>
    & { validationErrors: Array<(
      { __typename: 'FieldValidationError' }
      & ValidationErrorFragment
    )> }
  ) }
);

export type ValidationErrorFragment = (
  { __typename: 'FieldValidationError' }
  & Pick<FieldValidationError, 'fieldName' | 'error'>
);

export type RevisionsQueryVariables = Exact<{
  subject?: Maybe<ModeratedInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  status?: Maybe<RevisionStatus>;
}>;


export type RevisionsQuery = (
  { __typename: 'Query' }
  & { revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount' | 'unfilteredCountForSubject'>
    & { uniqueRevisors: Array<(
      { __typename: 'User' }
      & Pick<User, 'username' | 'id' | 'profileImagePath'>
    )>, uniqueResolvers: Array<(
      { __typename: 'User' }
      & Pick<User, 'username' | 'id' | 'profileImagePath'>
    )>, revisedFieldNames: Array<(
      { __typename: 'FieldName' }
      & Pick<FieldName, 'name' | 'displayName'>
    )>, pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'endCursor' | 'startCursor'>
    ), edges: Array<(
      { __typename: 'RevisionEdge' }
      & { node?: Maybe<(
        { __typename: 'Revision' }
        & RevisionFragment
      )> }
    )> }
  ) }
);

export type RevisionFragment = (
  { __typename: 'Revision' }
  & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'resolvedAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
  & { linkoutData: (
    { __typename: 'LinkoutData' }
    & Pick<LinkoutData, 'name'>
    & { diffValue: (
      { __typename: 'ObjectFieldDiff' }
      & { currentObjects: Array<(
        { __typename: 'ModeratedObjectField' }
        & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
      )>, addedObjects: Array<(
        { __typename: 'ModeratedObjectField' }
        & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
      )>, removedObjects: Array<(
        { __typename: 'ModeratedObjectField' }
        & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
      )>, keptObjects: Array<(
        { __typename: 'ModeratedObjectField' }
        & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
      )>, suggestedObjects: Array<(
        { __typename: 'ModeratedObjectField' }
        & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
      )> }
    ) | (
      { __typename: 'ScalarFieldDiff' }
      & Pick<ScalarFieldDiff, 'left' | 'right'>
    ) }
  ), revisor?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role'>
  )>, resolver?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role'>
  )>, creationComment?: Maybe<(
    { __typename: 'Comment' }
    & { parsedComment: Array<(
      { __typename: 'CommentTagSegment' }
      & Pick<CommentTagSegment, 'entityId' | 'displayName' | 'tagType'>
    ) | (
      { __typename: 'CommentTextSegment' }
      & Pick<CommentTextSegment, 'text'>
    ) | (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role'>
    )> }
  )>, resolutionComment?: Maybe<(
    { __typename: 'Comment' }
    & { parsedComment: Array<(
      { __typename: 'CommentTagSegment' }
      & Pick<CommentTagSegment, 'entityId' | 'displayName' | 'tagType'>
    ) | (
      { __typename: 'CommentTextSegment' }
      & Pick<CommentTextSegment, 'text'>
    ) | (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role'>
    )> }
  )> }
);

export type ContributorAvatarsQueryVariables = Exact<{
  subscribable: SubscribableInput;
}>;


export type ContributorAvatarsQuery = (
  { __typename: 'Query' }
  & { contributors: (
    { __typename: 'ContributingUsersSummary' }
    & { editors: Array<(
      { __typename: 'ContributingUser' }
      & ContributorFieldsFragment
    )>, curators: Array<(
      { __typename: 'ContributingUser' }
      & ContributorFieldsFragment
    )> }
  ) }
);

export type ContributorFieldsFragment = (
  { __typename: 'ContributingUser' }
  & Pick<ContributingUser, 'lastActionDate' | 'totalActionCount'>
  & { user: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'profileImagePath'>
  ), uniqueActions: Array<(
    { __typename: 'Contribution' }
    & Pick<Contribution, 'action' | 'count'>
  )> }
);

export type SubscriptionForEntityQueryVariables = Exact<{
  subscribable: SubscribableInput;
}>;


export type SubscriptionForEntityQuery = (
  { __typename: 'Query' }
  & { subscriptionForEntity?: Maybe<(
    { __typename: 'Subscription' }
    & SubscriptionIdFragment
  )> }
);

export type SubscriptionIdFragment = (
  { __typename: 'Subscription' }
  & Pick<Subscription, 'id'>
);

export type ModerateEvidenceItemMutationVariables = Exact<{
  input: ModerateEvidenceItemInput;
}>;


export type ModerateEvidenceItemMutation = (
  { __typename: 'Mutation' }
  & { moderateEvidenceItem?: Maybe<(
    { __typename: 'ModerateEvidenceItemPayload' }
    & { evidenceItem: (
      { __typename: 'EvidenceItem' }
      & Pick<EvidenceItem, 'id'>
    ) }
  )> }
);

export type ModerateAssertionMutationVariables = Exact<{
  input: ModerateAssertionInput;
}>;


export type ModerateAssertionMutation = (
  { __typename: 'Mutation' }
  & { moderateAssertion?: Maybe<(
    { __typename: 'ModerateAssertionPayload' }
    & { assertion: (
      { __typename: 'Assertion' }
      & Pick<Assertion, 'id'>
    ) }
  )> }
);

export type CivicStatsQueryVariables = Exact<{ [key: string]: never; }>;


export type CivicStatsQuery = (
  { __typename: 'Query' }
  & { timepointStats: (
    { __typename: 'CivicTimepointStats' }
    & { assertions: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), diseases: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), comments: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), drugs: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), evidenceItems: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), genes: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), revisions: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), sources: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), users: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ), variants: (
      { __typename: 'TimePointCounts' }
      & TimepointCountFragment
    ) }
  ) }
);

export type TimepointCountFragment = (
  { __typename: 'TimePointCounts' }
  & Pick<TimePointCounts, 'allTime' | 'newThisMonth' | 'newThisWeek' | 'newThisYear'>
);

export type BrowseSourceSuggestionsQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<SourceSuggestionsSort>;
  sourceType?: Maybe<SourceSource>;
  citationId?: Maybe<Scalars['Int']>;
  sourceId?: Maybe<Scalars['Int']>;
  geneName?: Maybe<Scalars['String']>;
  variantName?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['String']>;
  submitter?: Maybe<Scalars['String']>;
  citation?: Maybe<Scalars['String']>;
  submitterId?: Maybe<Scalars['Int']>;
  status?: Maybe<SourceSuggestionStatus>;
}>;


export type BrowseSourceSuggestionsQuery = (
  { __typename: 'Query' }
  & { sourceSuggestions: (
    { __typename: 'SourceSuggestionConnection' }
    & Pick<SourceSuggestionConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'SourceSuggestionEdge' }
      & Pick<SourceSuggestionEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'SourceSuggestion' }
        & BrowseSourceSuggestionRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseSourceSuggestionRowFieldsFragment = (
  { __typename: 'SourceSuggestion' }
  & Pick<SourceSuggestion, 'id' | 'geneName' | 'variantName' | 'diseaseName' | 'initialComment' | 'status'>
  & { source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'citationId' | 'sourceType' | 'sourceUrl' | 'displayType'>
  ), user: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  ) }
);

export type UpdateSourceSuggestionStatusMutationVariables = Exact<{
  input: UpdateSourceSuggestionStatusInput;
}>;


export type UpdateSourceSuggestionStatusMutation = (
  { __typename: 'Mutation' }
  & { updateSourceSuggestionStatus?: Maybe<(
    { __typename: 'UpdateSourceSuggestionStatusPayload' }
    & { sourceSuggestion: (
      { __typename: 'SourceSuggestion' }
      & Pick<SourceSuggestion, 'id' | 'status'>
    ) }
  )> }
);

export type SourcePopoverQueryVariables = Exact<{
  sourceId: Scalars['Int'];
}>;


export type SourcePopoverQuery = (
  { __typename: 'Query' }
  & { sourcePopover?: Maybe<(
    { __typename: 'SourcePopover' }
    & SourcePopoverFragment
  )> }
);

export type SourcePopoverFragment = (
  { __typename: 'SourcePopover' }
  & Pick<SourcePopover, 'id' | 'name' | 'evidenceItemCount' | 'citation' | 'citationId' | 'displayType' | 'sourceUrl'>
  & { clinicalTrials?: Maybe<Array<(
    { __typename: 'ClinicalTrial' }
    & Pick<ClinicalTrial, 'id' | 'nctId'>
  )>> }
);

export type BrowseSourcesQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<SourcesSort>;
  name?: Maybe<Scalars['String']>;
  year?: Maybe<Scalars['Int']>;
  sourceType?: Maybe<SourceSource>;
  citationId?: Maybe<Scalars['Int']>;
  author?: Maybe<Scalars['String']>;
  journal?: Maybe<Scalars['String']>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
}>;


export type BrowseSourcesQuery = (
  { __typename: 'Query' }
  & { browseSources: (
    { __typename: 'BrowseSourceConnection' }
    & Pick<BrowseSourceConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'BrowseSourceEdge' }
      & Pick<BrowseSourceEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseSource' }
        & BrowseSourceRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseSourceRowFieldsFragment = (
  { __typename: 'BrowseSource' }
  & Pick<BrowseSource, 'id' | 'authors' | 'citationId' | 'evidenceItemCount' | 'journal' | 'name' | 'publicationYear' | 'sourceType' | 'citation' | 'displayType'>
);

export type UserPopoverQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type UserPopoverQuery = (
  { __typename: 'Query' }
  & { user?: Maybe<(
    { __typename: 'User' }
    & PopoverUserFragment
  )> }
);

export type PopoverUserFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'profileImagePath' | 'displayName' | 'bio' | 'role'>
  & { organizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name'>
  )> }
);

export type UsersBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  userName?: Maybe<Scalars['String']>;
  orgName?: Maybe<OrganizationFilter>;
  userRole?: Maybe<UserRole>;
  sortBy?: Maybe<UsersSort>;
}>;


export type UsersBrowseQuery = (
  { __typename: 'Query' }
  & { users: (
    { __typename: 'UserConnection' }
    & Pick<UserConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'hasPreviousPage' | 'startCursor'>
    ), edges: Array<(
      { __typename: 'UserEdge' }
      & Pick<UserEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'User' }
        & UserBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type UserBrowseTableRowFieldsFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'name' | 'displayName' | 'role' | 'mostRecentActionTimestamp'>
  & { organizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name'>
  )>, statsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'submittedEvidenceItems' | 'revisions'>
  ) }
);

export type BrowseVariantGroupsQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantGroupsSort>;
  name?: Maybe<Scalars['String']>;
  geneNames?: Maybe<Scalars['String']>;
  variantNames?: Maybe<Scalars['String']>;
}>;


export type BrowseVariantGroupsQuery = (
  { __typename: 'Query' }
  & { browseVariantGroups: (
    { __typename: 'BrowseVariantGroupConnection' }
    & Pick<BrowseVariantGroupConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'BrowseVariantGroupEdge' }
      & Pick<BrowseVariantGroupEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseVariantGroup' }
        & BrowseVariantGroupRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseVariantGroupRowFieldsFragment = (
  { __typename: 'BrowseVariantGroup' }
  & Pick<BrowseVariantGroup, 'id' | 'name' | 'geneNames' | 'variantNames' | 'variantCount' | 'evidenceItemCount'>
);

export type VariantTypePopoverQueryVariables = Exact<{
  variantTypeId: Scalars['Int'];
}>;


export type VariantTypePopoverQuery = (
  { __typename: 'Query' }
  & { variantTypePopover?: Maybe<(
    { __typename: 'VariantTypePopover' }
    & VariantTypePopoverFragment
  )> }
);

export type VariantTypePopoverFragment = (
  { __typename: 'VariantTypePopover' }
  & Pick<VariantTypePopover, 'id' | 'name' | 'url' | 'soid' | 'variantCount'>
);

export type VariantTypesBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  soid?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantTypeSort>;
}>;


export type VariantTypesBrowseQuery = (
  { __typename: 'Query' }
  & { variantTypes: (
    { __typename: 'BrowseVariantTypeConnection' }
    & Pick<BrowseVariantTypeConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowseVariantTypeEdge' }
      & Pick<BrowseVariantTypeEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseVariantType' }
        & VariantTypeBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type VariantTypeBrowseTableRowFieldsFragment = (
  { __typename: 'BrowseVariantType' }
  & Pick<BrowseVariantType, 'id' | 'name' | 'soid' | 'url' | 'variantCount'>
);

export type VariantPopoverQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantPopoverQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & VariantPopoverFieldsFragment
  )> }
);

export type VariantPopoverFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'description' | 'variantAliases' | 'alleleRegistryId'>
  & { evidenceItems: (
    { __typename: 'EvidenceItemConnection' }
    & Pick<EvidenceItemConnection, 'totalCount'>
  ), gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ) }
);

export type VariantsMenuQueryVariables = Exact<{
  geneId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type VariantsMenuQuery = (
  { __typename: 'Query' }
  & { variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ), edges: Array<(
      { __typename: 'VariantEdge' }
      & Pick<VariantEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Variant' }
        & MenuVariantFragment
      )> }
    )> }
  ) }
);

export type MenuVariantFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name'>
);

export type BrowseVariantsQueryVariables = Exact<{
  variantName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  variantAlias?: Maybe<Scalars['String']>;
  variantTypeId?: Maybe<Scalars['Int']>;
  variantGroupId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<VariantsSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type BrowseVariantsQuery = (
  { __typename: 'Query' }
  & { browseVariants: (
    { __typename: 'BrowseVariantConnection' }
    & Pick<BrowseVariantConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'BrowseVariantEdge' }
      & Pick<BrowseVariantEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseVariant' }
        & Pick<BrowseVariant, 'id' | 'name' | 'evidenceScore' | 'evidenceItemCount' | 'geneId' | 'geneName' | 'assertionCount'>
        & { diseases: Array<(
          { __typename: 'Disease' }
          & Pick<Disease, 'id' | 'name'>
        )>, drugs: Array<(
          { __typename: 'Drug' }
          & Pick<Drug, 'id' | 'name'>
        )>, aliases: Array<(
          { __typename: 'VariantAlias' }
          & Pick<VariantAlias, 'name'>
        )> }
      )> }
    )> }
  ) }
);

export type ViewerBaseQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerBaseQuery = (
  { __typename: 'Query' }
  & { viewer?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'role' | 'displayName' | 'profileImagePath' | 'mostRecentOrganizationId'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )>, mostRecentConflictOfInterestStatement?: Maybe<(
      { __typename: 'Coi' }
      & Pick<Coi, 'coiStatus'>
    )> }
  )> }
);

export type ViewerNotificationCountQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerNotificationCountQuery = (
  { __typename: 'Query' }
  & { notifications: (
    { __typename: 'NotificationConnection' }
    & Pick<NotificationConnection, 'unreadCount'>
  ) }
);

export type SubmitAssertionMutationVariables = Exact<{
  input: SubmitAssertionInput;
}>;


export type SubmitAssertionMutation = (
  { __typename: 'Mutation' }
  & { submitAssertion?: Maybe<(
    { __typename: 'SubmitAssertionPayload' }
    & Pick<SubmitAssertionPayload, 'clientMutationId'>
    & { assertion: (
      { __typename: 'Assertion' }
      & Pick<Assertion, 'id'>
    ) }
  )> }
);

export type AddCommentMutationVariables = Exact<{
  input: AddCommentInput;
}>;


export type AddCommentMutation = (
  { __typename: 'Mutation' }
  & { addComment?: Maybe<(
    { __typename: 'AddCommentPayload' }
    & Pick<AddCommentPayload, 'clientMutationId'>
    & { comment?: Maybe<(
      { __typename: 'Comment' }
      & CommentListNodeFragment
    )> }
  )> }
);

export type PreviewCommentQueryVariables = Exact<{
  commentText: Scalars['String'];
}>;


export type PreviewCommentQuery = (
  { __typename: 'Query' }
  & { previewCommentText: Array<(
    { __typename: 'CommentTagSegment' }
    & PreviewComment_CommentTagSegment_Fragment
  ) | (
    { __typename: 'CommentTextSegment' }
    & PreviewComment_CommentTextSegment_Fragment
  ) | (
    { __typename: 'User' }
    & PreviewComment_User_Fragment
  )> }
);

type PreviewComment_CommentTagSegment_Fragment = (
  { __typename: 'CommentTagSegment' }
  & Pick<CommentTagSegment, 'entityId' | 'displayName' | 'tagType' | 'status'>
);

type PreviewComment_CommentTextSegment_Fragment = (
  { __typename: 'CommentTextSegment' }
  & Pick<CommentTextSegment, 'text'>
);

type PreviewComment_User_Fragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'displayName' | 'role'>
);

export type PreviewCommentFragment = PreviewComment_CommentTagSegment_Fragment | PreviewComment_CommentTextSegment_Fragment | PreviewComment_User_Fragment;

export type UserTypeaheadQueryVariables = Exact<{
  queryTerm: Scalars['String'];
}>;


export type UserTypeaheadQuery = (
  { __typename: 'Query' }
  & { userTypeahead: Array<(
    { __typename: 'User' }
    & Pick<User, 'username'>
  )> }
);

export type EntityTypeaheadQueryVariables = Exact<{
  queryTerm: Scalars['String'];
}>;


export type EntityTypeaheadQuery = (
  { __typename: 'Query' }
  & { entityTypeahead: Array<(
    { __typename: 'CommentTagSegment' }
    & Pick<CommentTagSegment, 'entityId' | 'tagType' | 'displayName'>
  )> }
);

export type AcmgCodeTypeaheadQueryVariables = Exact<{
  code: Scalars['String'];
}>;


export type AcmgCodeTypeaheadQuery = (
  { __typename: 'Query' }
  & { acmgCodesTypeahead: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'id' | 'code' | 'description'>
  )> }
);

export type DiseaseTypeaheadQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type DiseaseTypeaheadQuery = (
  { __typename: 'Query' }
  & { diseaseTypeahead: Array<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name' | 'displayName' | 'doid' | 'diseaseAliases'>
  )> }
);

export type AddDiseaseMutationVariables = Exact<{
  name: Scalars['String'];
  doid?: Maybe<Scalars['Int']>;
}>;


export type AddDiseaseMutation = (
  { __typename: 'Mutation' }
  & { addDisease?: Maybe<(
    { __typename: 'AddDiseasePayload' }
    & AddDiseaseFieldsFragment
  )> }
);

export type AddDiseaseFieldsFragment = (
  { __typename: 'AddDiseasePayload' }
  & Pick<AddDiseasePayload, 'new'>
  & { disease: (
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name' | 'displayName'>
  ) }
);

export type DrugTypeaheadQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type DrugTypeaheadQuery = (
  { __typename: 'Query' }
  & { drugTypeahead: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name' | 'ncitId' | 'drugAliases'>
  )> }
);

export type AddDrugMutationVariables = Exact<{
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
}>;


export type AddDrugMutation = (
  { __typename: 'Mutation' }
  & { addDrug?: Maybe<(
    { __typename: 'AddDrugPayload' }
    & AddDrugFieldsFragment
  )> }
);

export type AddDrugFieldsFragment = (
  { __typename: 'AddDrugPayload' }
  & Pick<AddDrugPayload, 'new'>
  & { drug: (
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'ncitId' | 'name'>
  ) }
);

export type EvidenceTypeaheadQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type EvidenceTypeaheadQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'status' | 'name'>
  )> }
);

export type EvidenceTransferSearchQueryVariables = Exact<{
  id?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
}>;


export type EvidenceTransferSearchQuery = (
  { __typename: 'Query' }
  & { evidenceItems: (
    { __typename: 'EvidenceItemConnection' }
    & Pick<EvidenceItemConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'EvidenceItemEdge' }
      & Pick<EvidenceItemEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'EvidenceItem' }
        & EvidenceTransferSearchFieldsFragment
      )> }
    )> }
  ) }
);

export type EvidenceTransferSearchFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name'>
);

export type GeneTypeaheadQueryVariables = Exact<{
  entrezSymbol: Scalars['String'];
}>;


export type GeneTypeaheadQuery = (
  { __typename: 'Query' }
  & { geneTypeahead: Array<(
    { __typename: 'Gene' }
    & GeneTypeaheadFieldsFragment
  )> }
);

export type GeneTypeaheadFieldsFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'name' | 'geneAliases' | 'entrezId'>
);

export type NccnGuidelineTypeaheadQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type NccnGuidelineTypeaheadQuery = (
  { __typename: 'Query' }
  & { nccnGuidelinesTypeahead: Array<(
    { __typename: 'NccnGuideline' }
    & Pick<NccnGuideline, 'id' | 'name'>
  )> }
);

export type PhenotypeTypeaheadQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type PhenotypeTypeaheadQuery = (
  { __typename: 'Query' }
  & { phenotypeTypeahead: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'hpoId' | 'id' | 'name'>
  )> }
);

export type CitationTypeaheadQueryVariables = Exact<{
  partialCitationId: Scalars['Int'];
  sourceType: SourceSource;
}>;


export type CitationTypeaheadQuery = (
  { __typename: 'Query' }
  & { sourceTypeahead: Array<(
    { __typename: 'Source' }
    & SourceTypeaheadResultFragment
  )> }
);

export type SourceTypeaheadResultFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'id' | 'name' | 'citation' | 'citationId' | 'sourceType'>
);

export type CitationExistenceCheckQueryVariables = Exact<{
  sourceType: SourceSource;
  citationId: Scalars['Int'];
}>;


export type CitationExistenceCheckQuery = (
  { __typename: 'Query' }
  & Pick<Query, 'remoteCitation'>
);

export type CreateSourceStubMutationVariables = Exact<{
  input: AddRemoteCitationInput;
}>;


export type CreateSourceStubMutation = (
  { __typename: 'Mutation' }
  & { addRemoteCitation?: Maybe<(
    { __typename: 'AddRemoteCitationPayload' }
    & { newSource: (
      { __typename: 'SourceStub' }
      & Pick<SourceStub, 'id' | 'citationId' | 'sourceType'>
    ) }
  )> }
);

export type CheckRemoteCitationQueryVariables = Exact<{
  sourceType: SourceSource;
  citationId: Scalars['Int'];
}>;


export type CheckRemoteCitationQuery = (
  { __typename: 'Query' }
  & Pick<Query, 'remoteCitation'>
);

export type AddRemoteCitationMutationVariables = Exact<{
  input: AddRemoteCitationInput;
}>;


export type AddRemoteCitationMutation = (
  { __typename: 'Mutation' }
  & { addRemoteCitation?: Maybe<(
    { __typename: 'AddRemoteCitationPayload' }
    & { newSource: (
      { __typename: 'SourceStub' }
      & SourceStubFieldsFragment
    ) }
  )> }
);

export type SourceStubFieldsFragment = (
  { __typename: 'SourceStub' }
  & Pick<SourceStub, 'id' | 'citationId' | 'sourceType'>
);

export type SourceTypeaheadQueryVariables = Exact<{
  partialCitationId: Scalars['Int'];
  sourceType: SourceSource;
}>;


export type SourceTypeaheadQuery = (
  { __typename: 'Query' }
  & { sourceTypeahead: Array<(
    { __typename: 'Source' }
    & SourceTypeaheadResultFragment
  )> }
);

export type SourceTypeaheadFieldsFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'id' | 'name' | 'citation' | 'citationId' | 'sourceType'>
);

export type VariantTypeaheadQueryVariables = Exact<{
  name: Scalars['String'];
  geneId?: Maybe<Scalars['Int']>;
}>;


export type VariantTypeaheadQuery = (
  { __typename: 'Query' }
  & { variants: (
    { __typename: 'VariantConnection' }
    & { nodes: Array<(
      { __typename: 'Variant' }
      & VariantTypeaheadFieldsFragment
    )> }
  ) }
);

export type VariantTypeaheadFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name'>
);

export type AddVariantMutationVariables = Exact<{
  name: Scalars['String'];
  geneId: Scalars['Int'];
}>;


export type AddVariantMutation = (
  { __typename: 'Mutation' }
  & { addVariant?: Maybe<(
    { __typename: 'AddVariantPayload' }
    & AddVariantFieldsFragment
  )> }
);

export type AddVariantFieldsFragment = (
  { __typename: 'AddVariantPayload' }
  & Pick<AddVariantPayload, 'new'>
  & { variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ) }
);

export type VariantSelectQueryVariables = Exact<{
  name: Scalars['String'];
  geneId?: Maybe<Scalars['Int']>;
}>;


export type VariantSelectQuery = (
  { __typename: 'Query' }
  & { variants: (
    { __typename: 'VariantConnection' }
    & { nodes: Array<(
      { __typename: 'Variant' }
      & VariantTypeaheadFieldsFragment
    )> }
  ) }
);

export type VariantSelectFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name'>
);

export type VariantTypeTypeaheadQueryVariables = Exact<{
  name: Scalars['String'];
}>;


export type VariantTypeTypeaheadQuery = (
  { __typename: 'Query' }
  & { variantTypeTypeahead: Array<(
    { __typename: 'VariantType' }
    & Pick<VariantType, 'name' | 'soid' | 'id'>
  )> }
);

export type EvidenceItemRevisableFieldsQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidenceItemRevisableFieldsQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & RevisableEvidenceFieldsFragment
  )> }
);

export type RevisableEvidenceFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'variantOrigin' | 'description' | 'clinicalSignificance' | 'drugInteractionType' | 'evidenceDirection' | 'evidenceLevel' | 'evidenceType' | 'evidenceRating'>
  & { variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'doid' | 'name' | 'displayName'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'ncitId' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'hpoId' | 'name'>
  )>, source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'sourceType' | 'citationId' | 'citation'>
  ) }
);

export type SuggestEvidenceItemRevisionMutationVariables = Exact<{
  input: SuggestEvidenceItemRevisionInput;
}>;


export type SuggestEvidenceItemRevisionMutation = (
  { __typename: 'Mutation' }
  & { suggestEvidenceItemRevision?: Maybe<(
    { __typename: 'SuggestEvidenceItemRevisionPayload' }
    & Pick<SuggestEvidenceItemRevisionPayload, 'clientMutationId'>
    & { evidenceItem: (
      { __typename: 'EvidenceItem' }
      & Pick<EvidenceItem, 'id'>
      & { revisions: (
        { __typename: 'RevisionConnection' }
        & Pick<RevisionConnection, 'totalCount'>
        & { edges: Array<(
          { __typename: 'RevisionEdge' }
          & { node?: Maybe<(
            { __typename: 'Revision' }
            & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
            & { linkoutData: (
              { __typename: 'LinkoutData' }
              & Pick<LinkoutData, 'name'>
              & { diffValue: (
                { __typename: 'ObjectFieldDiff' }
                & { addedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, removedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, keptObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )> }
              ) | (
                { __typename: 'ScalarFieldDiff' }
                & Pick<ScalarFieldDiff, 'left' | 'right'>
              ) }
            ), revisor?: Maybe<(
              { __typename: 'User' }
              & Pick<User, 'id' | 'name'>
            )> }
          )> }
        )> }
      ) }
    ), results: Array<(
      { __typename: 'RevisionResult' }
      & Pick<RevisionResult, 'id' | 'fieldName'>
    )> }
  )> }
);

export type EvidenceSubmittableFieldsQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidenceSubmittableFieldsQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & SubmittableEvidenceFieldsFragment
  )> }
);

export type SubmittableEvidenceFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'description' | 'variantOrigin' | 'evidenceType' | 'clinicalSignificance' | 'evidenceLevel' | 'evidenceDirection' | 'evidenceRating' | 'drugInteractionType'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceType'>
  ), phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )> }
);

export type SubmitEvidenceItemMutationVariables = Exact<{
  input: SubmitEvidenceItemInput;
}>;


export type SubmitEvidenceItemMutation = (
  { __typename: 'Mutation' }
  & { submitEvidence?: Maybe<(
    { __typename: 'SubmitEvidenceItemPayload' }
    & Pick<SubmitEvidenceItemPayload, 'clientMutationId'>
    & { evidenceItem: (
      { __typename: 'EvidenceItem' }
      & Pick<EvidenceItem, 'id'>
    ) }
  )> }
);

export type FlagEntityMutationVariables = Exact<{
  input: FlagEntityInput;
}>;


export type FlagEntityMutation = (
  { __typename: 'Mutation' }
  & { flagEntity?: Maybe<(
    { __typename: 'FlagEntityPayload' }
    & { flag?: Maybe<(
      { __typename: 'Flag' }
      & Pick<Flag, 'id'>
    )> }
  )> }
);

export type ResolveFlagMutationVariables = Exact<{
  input: ResolveFlagInput;
}>;


export type ResolveFlagMutation = (
  { __typename: 'Mutation' }
  & { resolveFlag?: Maybe<(
    { __typename: 'ResolveFlagPayload' }
    & { flag?: Maybe<(
      { __typename: 'Flag' }
      & Pick<Flag, 'id'>
    )> }
  )> }
);

export type GeneRevisableFieldsQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GeneRevisableFieldsQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & RevisableGeneFieldsFragment
  )> }
);

export type RevisableGeneFieldsFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'description'>
  & { sources: Array<(
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'sourceType' | 'citation' | 'citationId'>
  )> }
);

export type SuggestGeneRevisionMutationVariables = Exact<{
  input: SuggestGeneRevisionInput;
}>;


export type SuggestGeneRevisionMutation = (
  { __typename: 'Mutation' }
  & { suggestGeneRevision?: Maybe<(
    { __typename: 'SuggestGeneRevisionPayload' }
    & Pick<SuggestGeneRevisionPayload, 'clientMutationId'>
    & { gene: (
      { __typename: 'Gene' }
      & Pick<Gene, 'id'>
      & { revisions: (
        { __typename: 'RevisionConnection' }
        & Pick<RevisionConnection, 'totalCount'>
        & { edges: Array<(
          { __typename: 'RevisionEdge' }
          & { node?: Maybe<(
            { __typename: 'Revision' }
            & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
            & { linkoutData: (
              { __typename: 'LinkoutData' }
              & Pick<LinkoutData, 'name'>
              & { diffValue: (
                { __typename: 'ObjectFieldDiff' }
                & { addedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, removedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, keptObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )> }
              ) | (
                { __typename: 'ScalarFieldDiff' }
                & Pick<ScalarFieldDiff, 'left' | 'right'>
              ) }
            ), revisor?: Maybe<(
              { __typename: 'User' }
              & Pick<User, 'id' | 'name'>
            )> }
          )> }
        )> }
      ) }
    ), results: Array<(
      { __typename: 'RevisionResult' }
      & Pick<RevisionResult, 'id' | 'fieldName'>
    )> }
  )> }
);

export type SuggestSourceMutationVariables = Exact<{
  input: SuggestSourceInput;
}>;


export type SuggestSourceMutation = (
  { __typename: 'Mutation' }
  & { suggestSource?: Maybe<(
    { __typename: 'SuggestSourcePayload' }
    & Pick<SuggestSourcePayload, 'clientMutationId'>
    & { sourceSuggestion: (
      { __typename: 'SourceSuggestion' }
      & Pick<SourceSuggestion, 'id'>
    ) }
  )> }
);

export type UpdateCoiMutationVariables = Exact<{
  input: UpdateCoiInput;
}>;


export type UpdateCoiMutation = (
  { __typename: 'Mutation' }
  & { updateCoi?: Maybe<(
    { __typename: 'UpdateCoiPayload' }
    & { coiStatement: (
      { __typename: 'Coi' }
      & Pick<Coi, 'coiPresent' | 'coiStatus' | 'createdAt' | 'id'>
    ) }
  )> }
);

export type UpdateUserProfileMutationVariables = Exact<{
  input: EditUserInput;
}>;


export type UpdateUserProfileMutation = (
  { __typename: 'Mutation' }
  & { editUser?: Maybe<(
    { __typename: 'EditUserPayload' }
    & { user: (
      { __typename: 'User' }
      & Pick<User, 'id'>
    ) }
  )> }
);

export type CountriesQueryVariables = Exact<{ [key: string]: never; }>;


export type CountriesQuery = (
  { __typename: 'Query' }
  & { countries: Array<(
    { __typename: 'Country' }
    & Pick<Country, 'id' | 'name'>
  )> }
);

export type VariantRevisableFieldsQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantRevisableFieldsQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & RevisableVariantFieldsFragment
  )> }
);

export type RevisableVariantFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'description' | 'variantAliases' | 'alleleRegistryId' | 'clinvarIds' | 'ensemblVersion' | 'hgvsDescriptions' | 'referenceBuild'>
  & { sources: Array<(
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'sourceType' | 'citation' | 'citationId'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variantTypes?: Maybe<Array<(
    { __typename: 'VariantType' }
    & Pick<VariantType, 'id' | 'name' | 'soid'>
  )>>, fivePrimeCoordinates?: Maybe<(
    { __typename: 'Coordinate' }
    & CoordinateFieldsFragment
  )>, threePrimeCoordinates?: Maybe<(
    { __typename: 'Coordinate' }
    & CoordinateFieldsFragment
  )> }
);

export type CoordinateFieldsFragment = (
  { __typename: 'Coordinate' }
  & Pick<Coordinate, 'chromosome' | 'referenceBases' | 'representativeTranscript' | 'start' | 'stop' | 'variantBases'>
);

export type SuggestVariantRevisionMutationVariables = Exact<{
  input: SuggestVariantRevisionInput;
}>;


export type SuggestVariantRevisionMutation = (
  { __typename: 'Mutation' }
  & { suggestVariantRevision?: Maybe<(
    { __typename: 'SuggestVariantRevisionPayload' }
    & Pick<SuggestVariantRevisionPayload, 'clientMutationId'>
    & { variant: (
      { __typename: 'Variant' }
      & Pick<Variant, 'id'>
      & { revisions: (
        { __typename: 'RevisionConnection' }
        & Pick<RevisionConnection, 'totalCount'>
        & { edges: Array<(
          { __typename: 'RevisionEdge' }
          & { node?: Maybe<(
            { __typename: 'Revision' }
            & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
            & { linkoutData: (
              { __typename: 'LinkoutData' }
              & Pick<LinkoutData, 'name'>
              & { diffValue: (
                { __typename: 'ObjectFieldDiff' }
                & { addedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, removedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, keptObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )> }
              ) | (
                { __typename: 'ScalarFieldDiff' }
                & Pick<ScalarFieldDiff, 'left' | 'right'>
              ) }
            ), revisor?: Maybe<(
              { __typename: 'User' }
              & Pick<User, 'id' | 'name'>
            )> }
          )> }
        )> }
      ) }
    ), results: Array<(
      { __typename: 'RevisionResult' }
      & Pick<RevisionResult, 'id' | 'fieldName'>
    )> }
  )> }
);

export type AssertionDetailQueryVariables = Exact<{
  assertionId: Scalars['Int'];
}>;


export type AssertionDetailQuery = (
  { __typename: 'Query' }
  & { assertion?: Maybe<(
    { __typename: 'Assertion' }
    & AssertionDetailFieldsFragment
  )> }
);

export type AssertionDetailFieldsFragment = (
  { __typename: 'Assertion' }
  & Pick<Assertion, 'id' | 'name' | 'status'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type AssertionSummaryQueryVariables = Exact<{
  assertionId: Scalars['Int'];
}>;


export type AssertionSummaryQuery = (
  { __typename: 'Query' }
  & { assertion?: Maybe<(
    { __typename: 'Assertion' }
    & AssertionSummaryFieldsFragment
  )> }
);

export type AssertionSummaryFieldsFragment = (
  { __typename: 'Assertion' }
  & Pick<Assertion, 'id' | 'name' | 'summary' | 'description' | 'status' | 'variantOrigin' | 'assertionType' | 'assertionDirection' | 'clinicalSignificance' | 'drugInteractionType' | 'ampLevel' | 'nccnGuideline' | 'nccnGuidelineVersion' | 'regulatoryApproval' | 'fdaCompanionTest'>
  & { disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name' | 'alleleRegistryId'>
  ), drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'ncitId' | 'name' | 'id'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, acmgCodes: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'code' | 'description'>
  )>, flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), acceptanceEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )>, submissionEvent: (
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  ), rejectionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )> }
);

export type ClinicalTrialDetailQueryVariables = Exact<{
  clinicalTrialId: Scalars['Int'];
}>;


export type ClinicalTrialDetailQuery = (
  { __typename: 'Query' }
  & { clinicalTrial?: Maybe<(
    { __typename: 'ClinicalTrial' }
    & Pick<ClinicalTrial, 'id' | 'name' | 'nctId' | 'description' | 'url'>
  )> }
);

export type DiseaseDetailQueryVariables = Exact<{
  diseaseId: Scalars['Int'];
}>;


export type DiseaseDetailQuery = (
  { __typename: 'Query' }
  & { disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name' | 'doid' | 'diseaseUrl' | 'displayName' | 'diseaseAliases'>
  )> }
);

export type DrugDetailQueryVariables = Exact<{
  drugId: Scalars['Int'];
}>;


export type DrugDetailQuery = (
  { __typename: 'Query' }
  & { drug?: Maybe<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name' | 'ncitId' | 'drugUrl' | 'drugAliases'>
  )> }
);

export type EvidenceDetailQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidenceDetailQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & EvidenceDetailFieldsFragment
  )> }
);

export type EvidenceDetailFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'status'>
  & { variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), assertions: Array<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  )>, flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type EvidenceSummaryQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidenceSummaryQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & EvidenceSummaryFieldsFragment
  )> }
);

export type EvidenceSummaryFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'description' | 'status' | 'evidenceLevel' | 'evidenceType' | 'evidenceDirection' | 'clinicalSignificance' | 'variantOrigin' | 'drugInteractionType' | 'evidenceRating'>
  & { drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'citationId' | 'sourceType' | 'displayType' | 'sourceUrl' | 'ascoAbstractId'>
    & { clinicalTrials?: Maybe<Array<(
      { __typename: 'ClinicalTrial' }
      & Pick<ClinicalTrial, 'nctId' | 'id'>
    )>> }
  ), gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), acceptanceEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )>, submissionEvent: (
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  ), rejectionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )> }
);

export type GeneDetailQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GeneDetailQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & GeneDetailFieldsFragment
  )> }
);

export type GeneDetailFieldsFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'name' | 'officialName' | 'entrezId'>
  & { flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type GenesSummaryQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GenesSummaryQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & GeneSummaryFieldsFragment
  )> }
);

export type GeneSummaryFieldsFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'description' | 'entrezId' | 'geneAliases' | 'id' | 'name' | 'officialName' | 'myGeneInfoDetails'>
  & { sources: Array<(
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'displayType' | 'sourceType'>
  )>, variants: (
    { __typename: 'VariantConnection' }
    & { edges: Array<(
      { __typename: 'VariantEdge' }
      & { node?: Maybe<(
        { __typename: 'Variant' }
        & Pick<Variant, 'id' | 'name' | 'description'>
      )> }
    )> }
  ), lastSubmittedRevisionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )>, lastAcceptedRevisionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )> }
);

export type OrganizationDetailQueryVariables = Exact<{
  organizationId: Scalars['Int'];
}>;


export type OrganizationDetailQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & OrganizationDetailFieldsFragment
  )> }
);

export type OrganizationDetailFieldsFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'name' | 'url' | 'description' | 'profileImagePath'>
  & { subGroups: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, orgStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ), orgAndSuborgsStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ) }
);

export type OrganizationGroupsQueryVariables = Exact<{
  organizationId: Scalars['Int'];
}>;


export type OrganizationGroupsQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & { subGroups: Array<(
      { __typename: 'Organization' }
      & OrganizationGroupsFieldsFragment
    )> }
  )> }
);

export type OrganizationGroupsFieldsFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'name' | 'description' | 'profileImagePath'>
  & { orgStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ) }
);

export type OrganizationMembersQueryVariables = Exact<{
  organizationId: Scalars['Int'];
}>;


export type OrganizationMembersQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & { members: (
      { __typename: 'UserConnection' }
      & { edges: Array<(
        { __typename: 'UserEdge' }
        & Pick<UserEdge, 'cursor'>
        & { node?: Maybe<(
          { __typename: 'User' }
          & OrganizationMembersFieldsFragment
        )> }
      )> }
    ) }
  )> }
);

export type OrganizationMembersFieldsFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'name' | 'displayName' | 'username' | 'profileImagePath' | 'role' | 'url' | 'areaOfExpertise' | 'orcid' | 'twitterHandle' | 'facebookProfile' | 'linkedinProfile'>
);

export type PhenotypeDetailQueryVariables = Exact<{
  phenotypeId: Scalars['Int'];
}>;


export type PhenotypeDetailQuery = (
  { __typename: 'Query' }
  & { phenotype?: Maybe<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name' | 'hpoId' | 'url'>
  )> }
);

export type DataReleasesQueryVariables = Exact<{ [key: string]: never; }>;


export type DataReleasesQuery = (
  { __typename: 'Query' }
  & { dataReleases: Array<(
    { __typename: 'DataRelease' }
    & ReleaseFragment
  )> }
);

export type ReleaseFragment = (
  { __typename: 'DataRelease' }
  & Pick<DataRelease, 'name'>
  & { geneTsv?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )>, variantTsv?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )>, variantGroupTsv?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )>, evidenceTsv?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )>, assertionTsv?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )>, acceptedVariantsVcf?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )>, acceptedAndSubmittedVariantsVcf?: Maybe<(
    { __typename: 'DownloadableFile' }
    & Pick<DownloadableFile, 'filename' | 'path'>
  )> }
);

export type SourceDetailQueryVariables = Exact<{
  sourceId: Scalars['Int'];
}>;


export type SourceDetailQuery = (
  { __typename: 'Query' }
  & { source?: Maybe<(
    { __typename: 'Source' }
    & SourceDetailFieldsFragment
  )> }
);

export type SourceDetailFieldsFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'displayType' | 'citationId'>
);

export type SourceSummaryQueryVariables = Exact<{
  sourceId: Scalars['Int'];
}>;


export type SourceSummaryQuery = (
  { __typename: 'Query' }
  & { source?: Maybe<(
    { __typename: 'Source' }
    & SourceSummaryFieldsFragment
  )> }
);

export type SourceSummaryFieldsFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'displayType' | 'title' | 'abstract' | 'publicationDate' | 'citationId' | 'fullJournalTitle' | 'pmcId' | 'authorString'>
  & { clinicalTrials?: Maybe<Array<(
    { __typename: 'ClinicalTrial' }
    & Pick<ClinicalTrial, 'nctId' | 'id'>
  )>> }
);

export type UserDetailQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type UserDetailQuery = (
  { __typename: 'Query' }
  & { user?: Maybe<(
    { __typename: 'User' }
    & UserDetailFieldsFragment
  )> }
);

export type UserDetailFieldsFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'name' | 'displayName' | 'username' | 'email' | 'profileImagePath' | 'role' | 'url' | 'bio' | 'areaOfExpertise' | 'orcid' | 'twitterHandle' | 'facebookProfile' | 'linkedinProfile'>
  & { organizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name'>
  )>, country?: Maybe<(
    { __typename: 'Country' }
    & Pick<Country, 'id' | 'name'>
  )>, statsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ), mostRecentConflictOfInterestStatement?: Maybe<(
    { __typename: 'Coi' }
    & Pick<Coi, 'id' | 'coiPresent' | 'coiStatement' | 'coiStatus' | 'createdAt' | 'expiresAt'>
  )> }
);

export type UserNotificationsQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  notificationReason?: Maybe<NotificationReason>;
  subscriptionId?: Maybe<Scalars['Int']>;
  originatingObject?: Maybe<SubscribableInput>;
  eventType?: Maybe<EventAction>;
  originatingUserId?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  includeRead?: Maybe<Scalars['Boolean']>;
}>;


export type UserNotificationsQuery = (
  { __typename: 'Query' }
  & { notifications: (
    { __typename: 'NotificationConnection' }
    & Pick<NotificationConnection, 'eventTypes'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
    ), notificationSubjects: Array<(
      { __typename: 'EventSubjectWithCount' }
      & NotificationFeedSubjectsFragment
    )>, originatingUsers: Array<(
      { __typename: 'User' }
      & NotificationOriginatingUsersFragment
    )>, organizations: Array<(
      { __typename: 'Organization' }
      & NotificationOrganizationFragment
    )>, edges: Array<(
      { __typename: 'NotificationEdge' }
      & { node?: Maybe<(
        { __typename: 'Notification' }
        & NotificationNodeFragment
      )> }
    )> }
  ) }
);

export type NotificationOrganizationFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'name'>
);

export type NotificationOriginatingUsersFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'displayName'>
);

export type NotificationFeedSubjectsFragment = (
  { __typename: 'EventSubjectWithCount' }
  & Pick<EventSubjectWithCount, 'occuranceCount'>
  & { subject: (
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'name'>
  ) | (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ) | (
    { __typename: 'Revision' }
    & Pick<Revision, 'id' | 'name'>
  ) | (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'name'>
  ) | (
    { __typename: 'SourcePopover' }
    & Pick<SourcePopover, 'id' | 'name'>
  ) | (
    { __typename: 'SourceSuggestion' }
    & Pick<SourceSuggestion, 'id' | 'name'>
  ) | (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ) | (
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'id' | 'name'>
  ) }
);

export type NotificationNodeFragment = (
  { __typename: 'Notification' }
  & Pick<Notification, 'id' | 'type' | 'seen'>
  & { event: (
    { __typename: 'Event' }
    & EventFeedNodeFragment
  ), subscription?: Maybe<(
    { __typename: 'Subscription' }
    & Pick<Subscription, 'id'>
    & { subscribable: (
      { __typename: 'Assertion' }
      & Pick<Assertion, 'id' | 'name'>
    ) | (
      { __typename: 'EvidenceItem' }
      & Pick<EvidenceItem, 'id' | 'name'>
    ) | (
      { __typename: 'Gene' }
      & Pick<Gene, 'id' | 'name'>
    ) | (
      { __typename: 'Revision' }
      & Pick<Revision, 'id' | 'name'>
    ) | (
      { __typename: 'Source' }
      & Pick<Source, 'id' | 'name'>
    ) | (
      { __typename: 'SourcePopover' }
      & Pick<SourcePopover, 'id' | 'name'>
    ) | (
      { __typename: 'SourceSuggestion' }
      & Pick<SourceSuggestion, 'id' | 'name'>
    ) | (
      { __typename: 'Variant' }
      & Pick<Variant, 'id' | 'name'>
    ) | (
      { __typename: 'VariantGroup' }
      & Pick<VariantGroup, 'id' | 'name'>
    ) }
  )> }
);

export type UpdateNotificationStatusMutationVariables = Exact<{
  input: UpdateNotificationStatusInput;
}>;


export type UpdateNotificationStatusMutation = (
  { __typename: 'Mutation' }
  & { updateNotificationStatus?: Maybe<(
    { __typename: 'UpdateNotificationStatusPayload' }
    & { notifications: Array<(
      { __typename: 'Notification' }
      & NotificationNodeFragment
    )> }
  )> }
);

export type UnsubscribeMutationVariables = Exact<{
  input: UnsubscribeInput;
}>;


export type UnsubscribeMutation = (
  { __typename: 'Mutation' }
  & { unsubscribe?: Maybe<(
    { __typename: 'UnsubscribePayload' }
    & { unsubscribedEntities: Array<(
      { __typename: 'Subscribable' }
      & SubscribableFragment
    )> }
  )> }
);

export type SubscribeMutationVariables = Exact<{
  input: SubscribeInput;
}>;


export type SubscribeMutation = (
  { __typename: 'Mutation' }
  & { subscribe?: Maybe<(
    { __typename: 'SubscribePayload' }
    & { subscriptions: Array<(
      { __typename: 'Subscription' }
      & Pick<Subscription, 'id'>
    )> }
  )> }
);

export type SubscribableFragment = (
  { __typename: 'Subscribable' }
  & Pick<Subscribable, 'id' | 'entityType'>
);

export type VariantGroupDetailQueryVariables = Exact<{
  variantGroupId: Scalars['Int'];
}>;


export type VariantGroupDetailQuery = (
  { __typename: 'Query' }
  & { variantGroup?: Maybe<(
    { __typename: 'VariantGroup' }
    & VariantGroupDetailFieldsFragment
  )> }
);

export type VariantGroupDetailFieldsFragment = (
  { __typename: 'VariantGroup' }
  & Pick<VariantGroup, 'id' | 'name'>
  & { variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type VariantGroupRevisionsQueryVariables = Exact<{
  variantGroupId: Scalars['Int'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
}>;


export type VariantGroupRevisionsQuery = (
  { __typename: 'Query' }
  & { variantGroup?: Maybe<(
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'id'>
    & { revisions: (
      { __typename: 'RevisionConnection' }
      & Pick<RevisionConnection, 'totalCount'>
      & { uniqueRevisors: Array<(
        { __typename: 'User' }
        & Pick<User, 'username' | 'id' | 'profileImagePath'>
      )>, revisedFieldNames: Array<(
        { __typename: 'FieldName' }
        & Pick<FieldName, 'name' | 'displayName'>
      )>, edges: Array<(
        { __typename: 'RevisionEdge' }
        & { node?: Maybe<(
          { __typename: 'Revision' }
          & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
          & { linkoutData: (
            { __typename: 'LinkoutData' }
            & Pick<LinkoutData, 'name'>
            & { diffValue: (
              { __typename: 'ObjectFieldDiff' }
              & { addedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, removedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, keptObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )> }
            ) | (
              { __typename: 'ScalarFieldDiff' }
              & Pick<ScalarFieldDiff, 'left' | 'right'>
            ) }
          ), revisor?: Maybe<(
            { __typename: 'User' }
            & Pick<User, 'id' | 'name'>
          )> }
        )> }
      )> }
    ) }
  )> }
);

export type VariantGroupsSummaryQueryVariables = Exact<{
  variantGroupId: Scalars['Int'];
}>;


export type VariantGroupsSummaryQuery = (
  { __typename: 'Query' }
  & { variantGroup?: Maybe<(
    { __typename: 'VariantGroup' }
    & VariantGroupSummaryFieldsFragment
  )> }
);

export type VariantGroupSummaryFieldsFragment = (
  { __typename: 'VariantGroup' }
  & Pick<VariantGroup, 'id' | 'name' | 'description'>
);

export type VariantTypeDetailQueryVariables = Exact<{
  variantTypeId: Scalars['Int'];
}>;


export type VariantTypeDetailQuery = (
  { __typename: 'Query' }
  & { variantType?: Maybe<(
    { __typename: 'VariantType' }
    & Pick<VariantType, 'id' | 'name' | 'soid' | 'description' | 'url'>
  )> }
);

export type VariantDetailQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantDetailQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & VariantDetailFieldsFragment
  )> }
);

export type VariantDetailFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'variantAliases'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type VariantSummaryQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantSummaryQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & VariantSummaryFieldsFragment
  )> }
);

export type VariantSummaryFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'description' | 'variantAliases' | 'alleleRegistryId' | 'hgvsDescriptions' | 'clinvarIds' | 'evidenceScore' | 'referenceBuild' | 'ensemblVersion'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), sources: Array<(
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'displayType' | 'sourceType'>
  )>, variantTypes?: Maybe<Array<(
    { __typename: 'VariantType' }
    & Pick<VariantType, 'soid' | 'name'>
  )>>, fivePrimeCoordinates?: Maybe<(
    { __typename: 'Coordinate' }
    & Pick<Coordinate, 'representativeTranscript' | 'chromosome' | 'start' | 'stop' | 'referenceBases' | 'variantBases'>
  )>, threePrimeCoordinates?: Maybe<(
    { __typename: 'Coordinate' }
    & Pick<Coordinate, 'representativeTranscript' | 'chromosome' | 'start' | 'stop' | 'referenceBases' | 'variantBases'>
  )>, flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), myVariantInfo?: Maybe<(
    { __typename: 'MyVariantInfo' }
    & MyVariantInfoFieldsFragment
  )>, lastSubmittedRevisionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )>, lastAcceptedRevisionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )> }
);

export type MyVariantInfoFieldsFragment = (
  { __typename: 'MyVariantInfo' }
  & Pick<MyVariantInfo, 'myVariantInfoId' | 'caddConsequence' | 'caddDetail' | 'caddScore' | 'clinvarClinicalSignificance' | 'clinvarHgvsCoding' | 'clinvarHgvsGenomic' | 'clinvarHgvsNonCoding' | 'clinvarHgvsProtein' | 'clinvarId' | 'clinvarOmim' | 'cosmicId' | 'dbnsfpInterproDomain' | 'dbsnpRsid' | 'eglClass' | 'eglHgvs' | 'eglProtein' | 'eglTranscript' | 'exacAlleleCount' | 'exacAlleleFrequency' | 'exacAlleleNumber' | 'fathmmMklPrediction' | 'fathmmMklScore' | 'fathmmPrediction' | 'fathmmScore' | 'fitconsScore' | 'gerp' | 'gnomadExomeAlleleCount' | 'gnomadExomeAlleleFrequency' | 'gnomadExomeAlleleNumber' | 'gnomadExomeFilter' | 'gnomadGenomeAlleleCount' | 'gnomadGenomeAlleleFrequency' | 'gnomadGenomeAlleleNumber' | 'gnomadGenomeFilter' | 'lrtPrediction' | 'lrtScore' | 'metalrPrediction' | 'metalrScore' | 'metasvmPrediction' | 'metasvmScore' | 'mutationassessorPrediction' | 'mutationassessorScore' | 'mutationtasterPrediction' | 'mutationtasterScore' | 'phastcons100way' | 'phastcons30way' | 'phyloP100way' | 'phyloP30way' | 'polyphen2HdivPrediction' | 'polyphen2HdivScore' | 'polyphen2HvarPrediction' | 'polyphen2HvarScore' | 'proveanPrediction' | 'proveanScore' | 'revelScore' | 'siftPrediction' | 'siftScore' | 'siphy' | 'snpeffSnpEffect' | 'snpeffSnpImpact'>
);

export const AssertionPopoverFragmentDoc = gql`
    fragment assertionPopover on Assertion {
  id
  name
  summary
  assertionType
  assertionDirection
  clinicalSignificance
  variantOrigin
  ampLevel
  acmgCodes {
    code
  }
  nccnGuideline
  fdaCompanionTest
  regulatoryApproval
  drugs {
    id
    name
  }
  drugInteractionType
  disease {
    id
    name
  }
  phenotypes {
    id
    name
  }
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const AssertionBrowseTableRowFieldsFragmentDoc = gql`
    fragment AssertionBrowseTableRowFields on Assertion {
  id
  name
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  disease {
    id
    name
  }
  drugs {
    id
    name
  }
  phenotypes @include(if: $cardView) {
    id
    name
  }
  drugInteractionType
  summary
  assertionType
  assertionDirection
  clinicalSignificance
  ampLevel
  acmgCodes @include(if: $cardView) {
    code
  }
  fdaCompanionTest @include(if: $cardView)
  regulatoryApproval @include(if: $cardView)
  nccnGuideline @include(if: $cardView)
  variantOrigin @include(if: $cardView)
}
    `;
export const ClinicalTrialPopoverFragmentDoc = gql`
    fragment clinicalTrialPopover on BrowseClinicalTrial {
  id
  name
  nctId
  url
  sourceCount
  evidenceCount
}
    `;
export const CommentListNodeFragmentDoc = gql`
    fragment commentListNode on Comment {
  id
  title
  comment
  createdAt
  commenter {
    id
    username
    displayName
    name
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
  parsedComment {
    __typename
    ... on CommentTagSegment {
      entityId
      displayName
      tagType
      status
      __typename
    }
    ... on CommentTextSegment {
      text
    }
    ... on User {
      id
      displayName
      role
    }
  }
}
    `;
export const CommentPopoverFragmentDoc = gql`
    fragment commentPopover on Comment {
  id
  name
  createdAt
  title
  comment
  commenter {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  commentable {
    id
    name
    __typename
  }
}
    `;
export const BrowseDiseaseRowFieldsFragmentDoc = gql`
    fragment BrowseDiseaseRowFields on BrowseDisease {
  id
  name
  doid
  diseaseUrl
  geneNames
  assertionCount
  evidenceItemCount
  variantCount
  geneCount
}
    `;
export const DrugBrowseTableRowFieldsFragmentDoc = gql`
    fragment DrugBrowseTableRowFields on BrowseDrug {
  id
  name
  ncitId
  drugUrl
  assertionCount
  evidenceCount
}
    `;
export const EventFeedNodeFragmentDoc = gql`
    fragment eventFeedNode on Event {
  id
  action
  createdAt
  organization {
    id
    name
    profileImagePath(size: 32)
  }
  originatingUser {
    id
    username
    displayName
    role
    profileImagePath(size: 32)
  }
  subject {
    name
    id
    ... on Source {
      citation
      sourceType
    }
    ... on EvidenceItem {
      status
    }
    ... on Assertion {
      status
    }
    __typename
  }
  originatingObject {
    id
    name
    __typename
    ... on Revision {
      id
    }
    ... on Comment {
      id
    }
    ... on Flag {
      id
    }
  }
}
    `;
export const EventFeedFragmentDoc = gql`
    fragment eventFeed on EventConnection {
  pageInfo {
    startCursor
    endCursor
    hasNextPage
    hasPreviousPage
  }
  eventTypes
  uniqueParticipants {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  participatingOrganizations {
    id
    name
    profileImagePath(size: 32)
  }
  edges {
    cursor
    node {
      ...eventFeedNode
    }
  }
}
    ${EventFeedNodeFragmentDoc}`;
export const EvidencePopoverFragmentDoc = gql`
    fragment evidencePopover on EvidenceItem {
  id
  name
  description
  evidenceLevel
  evidenceType
  evidenceDirection
  clinicalSignificance
  variantOrigin
  drugs {
    id
    name
  }
  drugInteractionType
  disease {
    id
    name
  }
  phenotypes {
    id
    name
  }
  evidenceRating
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  source {
    id
    citation
    sourceType
    displayType
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const EvidenceGridFieldsFragmentDoc = gql`
    fragment EvidenceGridFields on EvidenceItem {
  id
  name
  disease {
    id
    name
  }
  drugs {
    id
    name
  }
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  phenotypes @include(if: $cardView) {
    id
    name
  }
  source @include(if: $cardView) {
    id
    citation
    citationId
    sourceType
    sourceUrl
    clinicalTrials {
      nctId
      id
    }
  }
  assertions @include(if: $cardView) {
    id
    name
  }
  status
  drugInteractionType
  description
  evidenceType
  evidenceDirection
  evidenceLevel
  evidenceRating
  clinicalSignificance
  variantOrigin
}
    `;
export const FlagFragmentDoc = gql`
    fragment flag on Flag {
  id
  state
  createdAt
  resolvedAt
  flaggable {
    id
    name
  }
  flaggingUser {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  resolvingUser {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  openComment {
    __typename
    parsedComment {
      __typename
      ... on CommentTagSegment {
        entityId
        displayName
        tagType
        __typename
      }
      ... on CommentTextSegment {
        text
      }
      ... on User {
        id
        displayName
        role
      }
    }
  }
  resolutionComment {
    __typename
    parsedComment {
      __typename
      ... on CommentTagSegment {
        entityId
        displayName
        tagType
        __typename
      }
      ... on CommentTextSegment {
        text
      }
      ... on User {
        id
        displayName
        role
      }
    }
  }
}
    `;
export const FlagListFragmentDoc = gql`
    fragment flagList on FlagConnection {
  pageInfo {
    startCursor
    endCursor
    hasNextPage
    hasPreviousPage
  }
  totalCount
  unfilteredCountForSubject
  uniqueFlaggingUsers {
    username
    id
    profileImagePath(size: 32)
  }
  uniqueResolvingUsers {
    username
    id
    profileImagePath(size: 32)
  }
  edges {
    node {
      ...flag
    }
  }
}
    ${FlagFragmentDoc}`;
export const GenePopoverFragmentDoc = gql`
    fragment genePopover on Gene {
  id
  name
  officialName
  geneAliases
  variants {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  flags(state: OPEN) {
    totalCount
  }
}
    `;
export const QuicksearchResultFragmentDoc = gql`
    fragment QuicksearchResult on SearchResult {
  id
  resultType
  name
  matchingText
}
    `;
export const OrgPopoverFragmentDoc = gql`
    fragment orgPopover on Organization {
  id
  profileImagePath(size: 64)
  name
  description
  url
}
    `;
export const OrganizationBrowseTableRowFieldsFragmentDoc = gql`
    fragment OrganizationBrowseTableRowFields on Organization {
  id
  name
  description @include(if: $cardView)
  profileImagePath(size: 256) @include(if: $cardView)
  url
  memberCount
  eventCount
  subGroups {
    name
    id
  }
  mostRecentEvent {
    createdAt
  }
  orgStatsHash @include(if: $cardView) {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
}
    `;
export const PhenotypeBrowseTableRowFieldsFragmentDoc = gql`
    fragment PhenotypeBrowseTableRowFields on BrowsePhenotype {
  id
  name
  hpoId
  url
  assertionCount
  evidenceCount
}
    `;
export const ValidationErrorFragmentDoc = gql`
    fragment validationError on FieldValidationError {
  fieldName
  error
}
    `;
export const RevisionFragmentDoc = gql`
    fragment revision on Revision {
  id
  revisionsetId
  createdAt
  resolvedAt
  fieldName
  currentValue
  suggestedValue
  linkoutData {
    name
    diffValue {
      ... on ObjectFieldDiff {
        currentObjects {
          id
          displayName
          displayType
          entityType
        }
        addedObjects {
          id
          displayName
          displayType
          entityType
        }
        removedObjects {
          id
          displayName
          displayType
          entityType
        }
        keptObjects {
          id
          displayName
          displayType
          entityType
        }
        suggestedObjects {
          id
          displayName
          displayType
          entityType
        }
      }
      ... on ScalarFieldDiff {
        left
        right
      }
    }
  }
  revisor {
    id
    displayName
    role
  }
  resolver {
    id
    displayName
    role
  }
  creationComment {
    parsedComment {
      __typename
      ... on CommentTagSegment {
        entityId
        displayName
        tagType
        __typename
      }
      ... on CommentTextSegment {
        text
      }
      ... on User {
        id
        displayName
        role
      }
    }
  }
  resolutionComment {
    parsedComment {
      __typename
      ... on CommentTagSegment {
        entityId
        displayName
        tagType
        __typename
      }
      ... on CommentTextSegment {
        text
      }
      ... on User {
        id
        displayName
        role
      }
    }
  }
  status
}
    `;
export const ContributorFieldsFragmentDoc = gql`
    fragment ContributorFields on ContributingUser {
  user {
    id
    profileImagePath(size: 12)
  }
  uniqueActions {
    action
    count
  }
  lastActionDate
  totalActionCount
}
    `;
export const SubscriptionIdFragmentDoc = gql`
    fragment subscriptionId on Subscription {
  id
  __typename
}
    `;
export const TimepointCountFragmentDoc = gql`
    fragment TimepointCount on TimePointCounts {
  allTime
  newThisMonth
  newThisWeek
  newThisYear
}
    `;
export const BrowseSourceSuggestionRowFieldsFragmentDoc = gql`
    fragment BrowseSourceSuggestionRowFields on SourceSuggestion {
  id
  geneName
  variantName
  diseaseName
  source {
    id
    citation
    citationId
    sourceType
    sourceUrl
    displayType
  }
  user {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  initialComment
  status
}
    `;
export const SourcePopoverFragmentDoc = gql`
    fragment sourcePopover on SourcePopover {
  id
  name
  evidenceItemCount
  citation
  citationId
  displayType
  sourceUrl
  clinicalTrials {
    id
    nctId
  }
}
    `;
export const BrowseSourceRowFieldsFragmentDoc = gql`
    fragment BrowseSourceRowFields on BrowseSource {
  id
  authors
  citationId
  evidenceItemCount
  journal
  name
  publicationYear
  sourceType
  citation
  displayType
}
    `;
export const PopoverUserFragmentDoc = gql`
    fragment popoverUser on User {
  id
  profileImagePath(size: 64)
  displayName
  bio
  role
  organizations {
    id
    name
  }
}
    `;
export const UserBrowseTableRowFieldsFragmentDoc = gql`
    fragment UserBrowseTableRowFields on User {
  id
  name
  displayName
  organizations {
    id
    name
  }
  role
  statsHash {
    submittedEvidenceItems
    revisions
  }
  mostRecentActionTimestamp
}
    `;
export const BrowseVariantGroupRowFieldsFragmentDoc = gql`
    fragment BrowseVariantGroupRowFields on BrowseVariantGroup {
  id
  name
  geneNames
  variantNames
  variantCount
  evidenceItemCount
}
    `;
export const VariantTypePopoverFragmentDoc = gql`
    fragment variantTypePopover on VariantTypePopover {
  id
  name
  url
  soid
  variantCount
}
    `;
export const VariantTypeBrowseTableRowFieldsFragmentDoc = gql`
    fragment VariantTypeBrowseTableRowFields on BrowseVariantType {
  id
  name
  soid
  url
  variantCount
}
    `;
export const VariantPopoverFieldsFragmentDoc = gql`
    fragment variantPopoverFields on Variant {
  id
  name
  description
  variantAliases
  alleleRegistryId
  evidenceItems {
    totalCount
  }
  gene {
    id
    name
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  flags(state: OPEN) {
    totalCount
  }
}
    `;
export const MenuVariantFragmentDoc = gql`
    fragment menuVariant on Variant {
  id
  name
}
    `;
export const PreviewCommentFragmentDoc = gql`
    fragment previewComment on CommentBodySegment {
  __typename
  ... on CommentTagSegment {
    entityId
    displayName
    tagType
    status
    __typename
  }
  ... on CommentTextSegment {
    text
    __typename
  }
  ... on User {
    id
    displayName
    role
    __typename
  }
}
    `;
export const AddDiseaseFieldsFragmentDoc = gql`
    fragment AddDiseaseFields on AddDiseasePayload {
  new
  disease {
    id
    name
    displayName
  }
}
    `;
export const AddDrugFieldsFragmentDoc = gql`
    fragment AddDrugFields on AddDrugPayload {
  new
  drug {
    id
    ncitId
    name
  }
}
    `;
export const EvidenceTransferSearchFieldsFragmentDoc = gql`
    fragment EvidenceTransferSearchFields on EvidenceItem {
  id
  name
}
    `;
export const GeneTypeaheadFieldsFragmentDoc = gql`
    fragment GeneTypeaheadFields on Gene {
  id
  name
  geneAliases
  entrezId
}
    `;
export const SourceTypeaheadResultFragmentDoc = gql`
    fragment SourceTypeaheadResult on Source {
  id
  name
  citation
  citationId
  sourceType
}
    `;
export const SourceStubFieldsFragmentDoc = gql`
    fragment SourceStubFields on SourceStub {
  id
  citationId
  sourceType
}
    `;
export const SourceTypeaheadFieldsFragmentDoc = gql`
    fragment SourceTypeaheadFields on Source {
  id
  name
  citation
  citationId
  sourceType
}
    `;
export const VariantTypeaheadFieldsFragmentDoc = gql`
    fragment VariantTypeaheadFields on Variant {
  id
  name
}
    `;
export const AddVariantFieldsFragmentDoc = gql`
    fragment AddVariantFields on AddVariantPayload {
  new
  variant {
    id
    name
  }
}
    `;
export const VariantSelectFieldsFragmentDoc = gql`
    fragment VariantSelectFields on Variant {
  id
  name
}
    `;
export const RevisableEvidenceFieldsFragmentDoc = gql`
    fragment RevisableEvidenceFields on EvidenceItem {
  id
  variant {
    id
    name
  }
  variantOrigin
  description
  clinicalSignificance
  disease {
    id
    doid
    name
    displayName
  }
  drugs {
    id
    ncitId
    name
  }
  drugInteractionType
  evidenceDirection
  evidenceLevel
  evidenceType
  phenotypes {
    id
    hpoId
    name
  }
  evidenceRating
  source {
    id
    sourceType
    citationId
    citation
  }
}
    `;
export const SubmittableEvidenceFieldsFragmentDoc = gql`
    fragment SubmittableEvidenceFields on EvidenceItem {
  id
  description
  variantOrigin
  evidenceType
  clinicalSignificance
  evidenceLevel
  evidenceDirection
  evidenceRating
  drugInteractionType
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  source {
    id
    citation
    sourceType
  }
  phenotypes {
    id
    name
  }
  drugs {
    id
    name
  }
  disease {
    id
    name
  }
}
    `;
export const RevisableGeneFieldsFragmentDoc = gql`
    fragment RevisableGeneFields on Gene {
  id
  description
  sources {
    id
    sourceType
    citation
    citationId
  }
}
    `;
export const CoordinateFieldsFragmentDoc = gql`
    fragment CoordinateFields on Coordinate {
  chromosome
  referenceBases
  representativeTranscript
  start
  stop
  variantBases
}
    `;
export const RevisableVariantFieldsFragmentDoc = gql`
    fragment RevisableVariantFields on Variant {
  id
  name
  description
  sources {
    id
    sourceType
    citation
    citationId
  }
  gene {
    id
    name
  }
  variantAliases
  alleleRegistryId
  clinvarIds
  ensemblVersion
  hgvsDescriptions
  referenceBuild
  variantTypes {
    id
    name
    soid
  }
  fivePrimeCoordinates {
    ...CoordinateFields
  }
  threePrimeCoordinates {
    ...CoordinateFields
  }
}
    ${CoordinateFieldsFragmentDoc}`;
export const AssertionDetailFieldsFragmentDoc = gql`
    fragment AssertionDetailFields on Assertion {
  id
  name
  status
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const AssertionSummaryFieldsFragmentDoc = gql`
    fragment AssertionSummaryFields on Assertion {
  id
  name
  summary
  description
  status
  variantOrigin
  disease {
    id
    name
  }
  gene {
    id
    name
  }
  variant {
    id
    name
    alleleRegistryId
  }
  assertionType
  assertionDirection
  clinicalSignificance
  drugs {
    ncitId
    name
    id
  }
  phenotypes {
    id
    name
  }
  drugInteractionType
  ampLevel
  acmgCodes {
    code
    description
  }
  nccnGuideline
  nccnGuidelineVersion
  regulatoryApproval
  fdaCompanionTest
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  acceptanceEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  submissionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  rejectionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
}
    `;
export const EvidenceDetailFieldsFragmentDoc = gql`
    fragment EvidenceDetailFields on EvidenceItem {
  id
  name
  status
  variant {
    id
    name
  }
  gene {
    id
    name
  }
  assertions {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const EvidenceSummaryFieldsFragmentDoc = gql`
    fragment EvidenceSummaryFields on EvidenceItem {
  id
  name
  description
  status
  evidenceLevel
  evidenceType
  evidenceDirection
  clinicalSignificance
  variantOrigin
  drugs {
    id
    name
  }
  drugInteractionType
  disease {
    id
    name
  }
  phenotypes {
    id
    name
  }
  source {
    id
    citation
    citationId
    sourceType
    displayType
    sourceUrl
    ascoAbstractId
    clinicalTrials {
      nctId
      id
    }
  }
  evidenceRating
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  acceptanceEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  submissionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  rejectionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
}
    `;
export const GeneDetailFieldsFragmentDoc = gql`
    fragment GeneDetailFields on Gene {
  id
  name
  officialName
  entrezId
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const GeneSummaryFieldsFragmentDoc = gql`
    fragment GeneSummaryFields on Gene {
  description
  entrezId
  geneAliases
  id
  name
  officialName
  sources {
    id
    citation
    sourceUrl
    displayType
    sourceType
  }
  variants {
    edges {
      node {
        id
        name
        description
      }
    }
  }
  myGeneInfoDetails
  lastSubmittedRevisionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  lastAcceptedRevisionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
}
    `;
export const OrganizationDetailFieldsFragmentDoc = gql`
    fragment OrganizationDetailFields on Organization {
  id
  name
  url
  description
  profileImagePath(size: 256)
  subGroups {
    id
    name
    profileImagePath(size: 12)
  }
  orgStatsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
  orgAndSuborgsStatsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
}
    `;
export const OrganizationGroupsFieldsFragmentDoc = gql`
    fragment OrganizationGroupsFields on Organization {
  id
  name
  description
  profileImagePath(size: 12)
  orgStatsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
}
    `;
export const OrganizationMembersFieldsFragmentDoc = gql`
    fragment OrganizationMembersFields on User {
  id
  name
  displayName
  username
  profileImagePath(size: 36)
  role
  url
  areaOfExpertise
  orcid
  twitterHandle
  facebookProfile
  linkedinProfile
}
    `;
export const ReleaseFragmentDoc = gql`
    fragment Release on DataRelease {
  name
  geneTsv {
    filename
    path
  }
  variantTsv {
    filename
    path
  }
  variantGroupTsv {
    filename
    path
  }
  evidenceTsv {
    filename
    path
  }
  assertionTsv {
    filename
    path
  }
  acceptedVariantsVcf {
    filename
    path
  }
  acceptedAndSubmittedVariantsVcf {
    filename
    path
  }
}
    `;
export const SourceDetailFieldsFragmentDoc = gql`
    fragment SourceDetailFields on Source {
  id
  citation
  sourceUrl
  displayType
  citationId
}
    `;
export const SourceSummaryFieldsFragmentDoc = gql`
    fragment SourceSummaryFields on Source {
  displayType
  title
  abstract
  publicationDate
  citationId
  fullJournalTitle
  pmcId
  authorString
  clinicalTrials {
    nctId
    id
  }
}
    `;
export const UserDetailFieldsFragmentDoc = gql`
    fragment UserDetailFields on User {
  id
  name
  displayName
  username
  email
  profileImagePath(size: 128)
  role
  url
  bio
  areaOfExpertise
  orcid
  twitterHandle
  facebookProfile
  linkedinProfile
  organizations {
    id
    name
  }
  country {
    id
    name
  }
  statsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
  mostRecentConflictOfInterestStatement {
    id
    coiPresent
    coiStatement
    coiStatus
    createdAt
    expiresAt
  }
}
    `;
export const NotificationOrganizationFragmentDoc = gql`
    fragment notificationOrganization on Organization {
  id
  name
}
    `;
export const NotificationOriginatingUsersFragmentDoc = gql`
    fragment notificationOriginatingUsers on User {
  id
  displayName
}
    `;
export const NotificationFeedSubjectsFragmentDoc = gql`
    fragment notificationFeedSubjects on EventSubjectWithCount {
  subject {
    id
    __typename
    name
  }
  occuranceCount
}
    `;
export const NotificationNodeFragmentDoc = gql`
    fragment notificationNode on Notification {
  id
  type
  event {
    ...eventFeedNode
  }
  seen
  subscription {
    id
    subscribable {
      id
      name
      __typename
    }
  }
}
    ${EventFeedNodeFragmentDoc}`;
export const SubscribableFragmentDoc = gql`
    fragment subscribable on Subscribable {
  id
  entityType
  __typename
}
    `;
export const VariantGroupDetailFieldsFragmentDoc = gql`
    fragment VariantGroupDetailFields on VariantGroup {
  id
  name
  variants {
    totalCount
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const VariantGroupSummaryFieldsFragmentDoc = gql`
    fragment VariantGroupSummaryFields on VariantGroup {
  id
  name
  description
}
    `;
export const VariantDetailFieldsFragmentDoc = gql`
    fragment VariantDetailFields on Variant {
  id
  name
  gene {
    id
    name
  }
  variantAliases
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const MyVariantInfoFieldsFragmentDoc = gql`
    fragment MyVariantInfoFields on MyVariantInfo {
  myVariantInfoId
  caddConsequence
  caddDetail
  caddScore
  clinvarClinicalSignificance
  clinvarHgvsCoding
  clinvarHgvsGenomic
  clinvarHgvsNonCoding
  clinvarHgvsProtein
  clinvarId
  clinvarOmim
  cosmicId
  dbnsfpInterproDomain
  dbsnpRsid
  eglClass
  eglHgvs
  eglProtein
  eglTranscript
  exacAlleleCount
  exacAlleleFrequency
  exacAlleleNumber
  fathmmMklPrediction
  fathmmMklScore
  fathmmPrediction
  fathmmScore
  fitconsScore
  gerp
  gnomadExomeAlleleCount
  gnomadExomeAlleleFrequency
  gnomadExomeAlleleNumber
  gnomadExomeFilter
  gnomadGenomeAlleleCount
  gnomadGenomeAlleleFrequency
  gnomadGenomeAlleleNumber
  gnomadGenomeFilter
  lrtPrediction
  lrtScore
  metalrPrediction
  metalrScore
  metasvmPrediction
  metasvmScore
  mutationassessorPrediction
  mutationassessorScore
  mutationtasterPrediction
  mutationtasterScore
  phastcons100way
  phastcons30way
  phyloP100way
  phyloP30way
  polyphen2HdivPrediction
  polyphen2HdivScore
  polyphen2HvarPrediction
  polyphen2HvarScore
  proveanPrediction
  proveanScore
  revelScore
  siftPrediction
  siftScore
  siphy
  snpeffSnpEffect
  snpeffSnpImpact
}
    `;
export const VariantSummaryFieldsFragmentDoc = gql`
    fragment VariantSummaryFields on Variant {
  id
  name
  description
  gene {
    id
    name
  }
  sources {
    id
    citation
    sourceUrl
    displayType
    sourceType
  }
  variantAliases
  alleleRegistryId
  variantTypes {
    soid
    name
  }
  hgvsDescriptions
  clinvarIds
  evidenceScore
  referenceBuild
  ensemblVersion
  fivePrimeCoordinates {
    representativeTranscript
    chromosome
    start
    stop
    referenceBases
    variantBases
  }
  threePrimeCoordinates {
    representativeTranscript
    chromosome
    start
    stop
    referenceBases
    variantBases
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  myVariantInfo {
    ...MyVariantInfoFields
  }
  lastSubmittedRevisionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  lastAcceptedRevisionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
}
    ${MyVariantInfoFieldsFragmentDoc}`;
export const AssertionPopoverDocument = gql`
    query AssertionPopover($assertionId: Int!) {
  assertion(id: $assertionId) {
    ...assertionPopover
  }
}
    ${AssertionPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionPopoverGQL extends Apollo.Query<AssertionPopoverQuery, AssertionPopoverQueryVariables> {
    document = AssertionPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssertionsBrowseDocument = gql`
    query AssertionsBrowse($first: Int, $last: Int, $before: String, $after: String, $diseaseName: String, $drugName: String, $id: Int, $summary: String, $assertionDirection: EvidenceDirection, $clinicalSignificance: EvidenceClinicalSignificance, $assertionType: EvidenceType, $variantId: Int, $evidenceId: Int, $geneName: String, $variantName: String, $sortBy: AssertionSort, $ampLevel: AmpLevel, $organizationId: Int, $userId: Int, $phenotypeId: Int, $diseaseId: Int, $drugId: Int, $cardView: Boolean!) {
  assertions(
    first: $first
    last: $last
    before: $before
    after: $after
    diseaseName: $diseaseName
    drugName: $drugName
    id: $id
    summary: $summary
    assertionDirection: $assertionDirection
    clinicalSignificance: $clinicalSignificance
    assertionType: $assertionType
    variantId: $variantId
    sortBy: $sortBy
    ampLevel: $ampLevel
    geneName: $geneName
    variantName: $variantName
    evidenceId: $evidenceId
    organizationId: $organizationId
    userId: $userId
    phenotypeId: $phenotypeId
    drugId: $drugId
    diseaseId: $diseaseId
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...AssertionBrowseTableRowFields
      }
    }
  }
}
    ${AssertionBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionsBrowseGQL extends Apollo.Query<AssertionsBrowseQuery, AssertionsBrowseQueryVariables> {
    document = AssertionsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ClinicalTrialPopoverDocument = gql`
    query ClinicalTrialPopover($clinicalTrialId: Int!) {
  clinicalTrials(id: $clinicalTrialId) {
    edges {
      node {
        ...clinicalTrialPopover
      }
    }
  }
}
    ${ClinicalTrialPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class ClinicalTrialPopoverGQL extends Apollo.Query<ClinicalTrialPopoverQuery, ClinicalTrialPopoverQueryVariables> {
    document = ClinicalTrialPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ClinicalTrialsBrowseDocument = gql`
    query ClinicalTrialsBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $nctId: String, $sortBy: ClinicalTrialSort) {
  clinicalTrials(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    nctId: $nctId
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        name
        nctId
        evidenceCount
        sourceCount
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ClinicalTrialsBrowseGQL extends Apollo.Query<ClinicalTrialsBrowseQuery, ClinicalTrialsBrowseQueryVariables> {
    document = ClinicalTrialsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CommentListDocument = gql`
    query CommentList($first: Int, $last: Int, $before: String, $after: String, $originatingUserId: Int, $mentionedUserId: Int, $mentionedRole: UserRole, $mentionedEntity: TaggableEntityInput, $subject: CommentableInput, $sortBy: DateSort) {
  comments(
    first: $first
    last: $last
    before: $before
    after: $after
    originatingUserId: $originatingUserId
    mentionedUserId: $mentionedUserId
    mentionedRole: $mentionedRole
    mentionedEntity: $mentionedEntity
    subject: $subject
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    uniqueCommenters {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
    mentionedUsers {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
    mentionedRoles {
      displayName
      entityId
      tagType
    }
    mentionedEntities {
      displayName
      entityId
      tagType
    }
    unfilteredCountForSubject
    edges {
      cursor
      node {
        ...commentListNode
      }
    }
  }
}
    ${CommentListNodeFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CommentListGQL extends Apollo.Query<CommentListQuery, CommentListQueryVariables> {
    document = CommentListDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CommentPopoverDocument = gql`
    query CommentPopover($commentId: Int!) {
  comment(id: $commentId) {
    ...commentPopover
  }
}
    ${CommentPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CommentPopoverGQL extends Apollo.Query<CommentPopoverQuery, CommentPopoverQueryVariables> {
    document = CommentPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DiseasePopoverDocument = gql`
    query DiseasePopover($diseaseId: Int!) {
  diseasePopover(id: $diseaseId) {
    id
    name
    displayName
    doid
    diseaseUrl
    diseaseAliases
    assertionCount
    evidenceItemCount
    variantCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DiseasePopoverGQL extends Apollo.Query<DiseasePopoverQuery, DiseasePopoverQueryVariables> {
    document = DiseasePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseDiseasesDocument = gql`
    query BrowseDiseases($first: Int, $last: Int, $before: String, $after: String, $sortBy: DiseasesSort, $name: String, $doid: String, $geneNames: String) {
  browseDiseases(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    name: $name
    doid: $doid
    geneNames: $geneNames
  ) {
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseDiseaseRowFields
      }
    }
  }
}
    ${BrowseDiseaseRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseDiseasesGQL extends Apollo.Query<BrowseDiseasesQuery, BrowseDiseasesQueryVariables> {
    document = BrowseDiseasesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugPopoverDocument = gql`
    query DrugPopover($drugId: Int!) {
  drugPopover(id: $drugId) {
    id
    name
    drugUrl
    ncitId
    drugAliases
    assertionCount
    evidenceItemCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugPopoverGQL extends Apollo.Query<DrugPopoverQuery, DrugPopoverQueryVariables> {
    document = DrugPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugsBrowseDocument = gql`
    query DrugsBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $ncitId: String, $sortBy: DrugSort) {
  drugs(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    ncitId: $ncitId
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...DrugBrowseTableRowFields
      }
    }
  }
}
    ${DrugBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugsBrowseGQL extends Apollo.Query<DrugsBrowseQuery, DrugsBrowseQueryVariables> {
    document = DrugsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EventFeedDocument = gql`
    query EventFeed($subject: SubscribableQueryInput, $first: Int, $last: Int, $before: String, $after: String, $originatingUserId: Int, $organizationId: Int, $eventType: EventAction) {
  events(
    subject: $subject
    first: $first
    last: $last
    before: $before
    after: $after
    originatingUserId: $originatingUserId
    organizationId: $organizationId
    eventType: $eventType
  ) {
    ...eventFeed
  }
}
    ${EventFeedFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EventFeedGQL extends Apollo.Query<EventFeedQuery, EventFeedQueryVariables> {
    document = EventFeedDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidencePopoverDocument = gql`
    query EvidencePopover($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...evidencePopover
  }
}
    ${EvidencePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidencePopoverGQL extends Apollo.Query<EvidencePopoverQuery, EvidencePopoverQueryVariables> {
    document = EvidencePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceBrowseDocument = gql`
    query EvidenceBrowse($first: Int, $last: Int, $before: String, $after: String, $diseaseName: String, $drugName: String, $id: Int, $description: String, $evidenceLevel: EvidenceLevel, $evidenceDirection: EvidenceDirection, $clinicalSignificance: EvidenceClinicalSignificance, $evidenceType: EvidenceType, $rating: Int, $variantOrigin: VariantOrigin, $variantId: Int, $assertionId: Int, $organizationId: Int, $userId: Int, $sortBy: EvidenceSort, $phenotypeId: Int, $diseaseId: Int, $drugId: Int, $sourceId: Int, $clinicalTrialId: Int, $geneSymbol: String, $variantName: String, $cardView: Boolean!) {
  evidenceItems(
    first: $first
    last: $last
    before: $before
    after: $after
    diseaseName: $diseaseName
    drugName: $drugName
    id: $id
    description: $description
    evidenceLevel: $evidenceLevel
    evidenceDirection: $evidenceDirection
    clinicalSignificance: $clinicalSignificance
    evidenceType: $evidenceType
    evidenceRating: $rating
    variantOrigin: $variantOrigin
    variantId: $variantId
    assertionId: $assertionId
    organizationId: $organizationId
    userId: $userId
    phenotypeId: $phenotypeId
    diseaseId: $diseaseId
    drugId: $drugId
    sourceId: $sourceId
    clinicalTrialId: $clinicalTrialId
    geneSymbol: $geneSymbol
    variantName: $variantName
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...EvidenceGridFields
      }
    }
  }
}
    ${EvidenceGridFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceBrowseGQL extends Apollo.Query<EvidenceBrowseQuery, EvidenceBrowseQueryVariables> {
    document = EvidenceBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const FlagListDocument = gql`
    query FlagList($flaggable: FlaggableInput, $flaggingUserId: Int, $resolvingUserId: Int, $state: FlagState, $sortBy: DateSort, $first: Int, $last: Int, $before: String, $after: String) {
  flags(
    flaggable: $flaggable
    flaggingUserId: $flaggingUserId
    resolvingUserId: $resolvingUserId
    state: $state
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    ...flagList
  }
}
    ${FlagListFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class FlagListGQL extends Apollo.Query<FlagListQuery, FlagListQueryVariables> {
    document = FlagListDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GenePopoverDocument = gql`
    query GenePopover($geneId: Int!) {
  gene(id: $geneId) {
    ...genePopover
  }
}
    ${GenePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GenePopoverGQL extends Apollo.Query<GenePopoverQuery, GenePopoverQueryVariables> {
    document = GenePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseGenesDocument = gql`
    query BrowseGenes($entrezSymbol: String, $drugName: String, $geneAlias: String, $diseaseName: String, $sortBy: GenesSort, $first: Int, $last: Int, $before: String, $after: String) {
  browseGenes(
    entrezSymbol: $entrezSymbol
    drugName: $drugName
    geneAlias: $geneAlias
    diseaseName: $diseaseName
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    edges {
      cursor
      node {
        id
        entrezId
        name
        geneAliases
        diseases {
          name
          id
        }
        drugs {
          name
          id
        }
        variantCount
        evidenceItemCount
        assertionCount
      }
    }
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    totalCount
    filteredCount
    pageCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseGenesGQL extends Apollo.Query<BrowseGenesQuery, BrowseGenesQueryVariables> {
    document = BrowseGenesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const QuicksearchDocument = gql`
    query Quicksearch($query: String!) {
  search(query: $query) {
    ...QuicksearchResult
  }
}
    ${QuicksearchResultFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class QuicksearchGQL extends Apollo.Query<QuicksearchQuery, QuicksearchQueryVariables> {
    document = QuicksearchDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrgPopoverDocument = gql`
    query OrgPopover($orgId: Int!) {
  organization(id: $orgId) {
    ...orgPopover
  }
}
    ${OrgPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrgPopoverGQL extends Apollo.Query<OrgPopoverQuery, OrgPopoverQueryVariables> {
    document = OrgPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationsBrowseDocument = gql`
    query OrganizationsBrowse($first: Int, $last: Int, $before: String, $after: String, $id: Int, $orgName: String, $sortBy: OrganizationSort, $cardView: Boolean!) {
  organizations(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $orgName
    id: $id
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...OrganizationBrowseTableRowFields
      }
    }
  }
}
    ${OrganizationBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationsBrowseGQL extends Apollo.Query<OrganizationsBrowseQuery, OrganizationsBrowseQueryVariables> {
    document = OrganizationsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypePopoverDocument = gql`
    query PhenotypePopover($phenotypeId: Int!) {
  phenotypePopover(id: $phenotypeId) {
    id
    name
    url
    hpoId
    assertionCount
    evidenceItemCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypePopoverGQL extends Apollo.Query<PhenotypePopoverQuery, PhenotypePopoverQueryVariables> {
    document = PhenotypePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypesBrowseDocument = gql`
    query PhenotypesBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $hpoId: String, $sortBy: PhenotypeSort) {
  phenotypes(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    hpoId: $hpoId
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...PhenotypeBrowseTableRowFields
      }
    }
  }
}
    ${PhenotypeBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypesBrowseGQL extends Apollo.Query<PhenotypesBrowseQuery, PhenotypesBrowseQueryVariables> {
    document = PhenotypesBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AcceptRevisionDocument = gql`
    mutation AcceptRevision($input: AcceptRevisionsInput!) {
  acceptRevisions(input: $input) {
    revisions {
      id
      __typename
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AcceptRevisionGQL extends Apollo.Mutation<AcceptRevisionMutation, AcceptRevisionMutationVariables> {
    document = AcceptRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const RejectRevisionDocument = gql`
    mutation RejectRevision($input: RejectRevisionsInput!) {
  rejectRevisions(input: $input) {
    revisions {
      id
      __typename
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class RejectRevisionGQL extends Apollo.Mutation<RejectRevisionMutation, RejectRevisionMutationVariables> {
    document = RejectRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ValidateRevisionsForAcceptanceDocument = gql`
    query ValidateRevisionsForAcceptance($ids: [Int!]!) {
  validateRevisionsForAcceptance(revisionIds: $ids) {
    genericErrors
    validationErrors {
      ...validationError
    }
  }
}
    ${ValidationErrorFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class ValidateRevisionsForAcceptanceGQL extends Apollo.Query<ValidateRevisionsForAcceptanceQuery, ValidateRevisionsForAcceptanceQueryVariables> {
    document = ValidateRevisionsForAcceptanceDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const RevisionsDocument = gql`
    query Revisions($subject: ModeratedInput, $first: Int, $last: Int, $before: String, $after: String, $fieldName: String, $originatingUserId: Int, $resolvingUserId: Int, $revisionsetId: String, $status: RevisionStatus) {
  revisions(
    first: $first
    last: $last
    before: $before
    after: $after
    fieldName: $fieldName
    originatingUserId: $originatingUserId
    resolvingUserId: $resolvingUserId
    subject: $subject
    status: $status
    revisionsetId: $revisionsetId
  ) {
    totalCount
    unfilteredCountForSubject
    uniqueRevisors {
      username
      id
      profileImagePath(size: 32)
    }
    uniqueResolvers {
      username
      id
      profileImagePath(size: 32)
    }
    revisedFieldNames {
      name
      displayName
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      endCursor
      startCursor
    }
    edges {
      node {
        ...revision
      }
    }
  }
}
    ${RevisionFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class RevisionsGQL extends Apollo.Query<RevisionsQuery, RevisionsQueryVariables> {
    document = RevisionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ContributorAvatarsDocument = gql`
    query ContributorAvatars($subscribable: SubscribableInput!) {
  contributors(subscribable: $subscribable) {
    editors {
      ...ContributorFields
    }
    curators {
      ...ContributorFields
    }
  }
}
    ${ContributorFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class ContributorAvatarsGQL extends Apollo.Query<ContributorAvatarsQuery, ContributorAvatarsQueryVariables> {
    document = ContributorAvatarsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SubscriptionForEntityDocument = gql`
    query SubscriptionForEntity($subscribable: SubscribableInput!) {
  subscriptionForEntity(subscribable: $subscribable) {
    ...subscriptionId
  }
}
    ${SubscriptionIdFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SubscriptionForEntityGQL extends Apollo.Query<SubscriptionForEntityQuery, SubscriptionForEntityQueryVariables> {
    document = SubscriptionForEntityDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ModerateEvidenceItemDocument = gql`
    mutation ModerateEvidenceItem($input: ModerateEvidenceItemInput!) {
  moderateEvidenceItem(input: $input) {
    evidenceItem {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ModerateEvidenceItemGQL extends Apollo.Mutation<ModerateEvidenceItemMutation, ModerateEvidenceItemMutationVariables> {
    document = ModerateEvidenceItemDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ModerateAssertionDocument = gql`
    mutation ModerateAssertion($input: ModerateAssertionInput!) {
  moderateAssertion(input: $input) {
    assertion {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ModerateAssertionGQL extends Apollo.Mutation<ModerateAssertionMutation, ModerateAssertionMutationVariables> {
    document = ModerateAssertionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CivicStatsDocument = gql`
    query CivicStats {
  timepointStats {
    assertions {
      ...TimepointCount
    }
    diseases {
      ...TimepointCount
    }
    comments {
      ...TimepointCount
    }
    drugs {
      ...TimepointCount
    }
    evidenceItems {
      ...TimepointCount
    }
    genes {
      ...TimepointCount
    }
    revisions {
      ...TimepointCount
    }
    sources {
      ...TimepointCount
    }
    users {
      ...TimepointCount
    }
    variants {
      ...TimepointCount
    }
  }
}
    ${TimepointCountFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CivicStatsGQL extends Apollo.Query<CivicStatsQuery, CivicStatsQueryVariables> {
    document = CivicStatsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseSourceSuggestionsDocument = gql`
    query BrowseSourceSuggestions($first: Int, $last: Int, $before: String, $after: String, $sortBy: SourceSuggestionsSort, $sourceType: SourceSource, $citationId: Int, $sourceId: Int, $geneName: String, $variantName: String, $diseaseName: String, $comment: String, $submitter: String, $citation: String, $submitterId: Int, $status: SourceSuggestionStatus) {
  sourceSuggestions(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    sourceType: $sourceType
    citationId: $citationId
    sourceId: $sourceId
    geneName: $geneName
    variantName: $variantName
    diseaseName: $diseaseName
    comment: $comment
    submitter: $submitter
    citation: $citation
    submitterId: $submitterId
    status: $status
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseSourceSuggestionRowFields
      }
    }
  }
}
    ${BrowseSourceSuggestionRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseSourceSuggestionsGQL extends Apollo.Query<BrowseSourceSuggestionsQuery, BrowseSourceSuggestionsQueryVariables> {
    document = BrowseSourceSuggestionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateSourceSuggestionStatusDocument = gql`
    mutation UpdateSourceSuggestionStatus($input: UpdateSourceSuggestionStatusInput!) {
  updateSourceSuggestionStatus(input: $input) {
    sourceSuggestion {
      id
      status
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateSourceSuggestionStatusGQL extends Apollo.Mutation<UpdateSourceSuggestionStatusMutation, UpdateSourceSuggestionStatusMutationVariables> {
    document = UpdateSourceSuggestionStatusDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourcePopoverDocument = gql`
    query SourcePopover($sourceId: Int!) {
  sourcePopover(id: $sourceId) {
    ...sourcePopover
  }
}
    ${SourcePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourcePopoverGQL extends Apollo.Query<SourcePopoverQuery, SourcePopoverQueryVariables> {
    document = SourcePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseSourcesDocument = gql`
    query BrowseSources($first: Int, $last: Int, $before: String, $after: String, $sortBy: SourcesSort, $name: String, $year: Int, $sourceType: SourceSource, $citationId: Int, $author: String, $journal: String, $clinicalTrialId: Int) {
  browseSources(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    name: $name
    year: $year
    sourceType: $sourceType
    citationId: $citationId
    author: $author
    journal: $journal
    clinicalTrialId: $clinicalTrialId
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseSourceRowFields
      }
    }
  }
}
    ${BrowseSourceRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseSourcesGQL extends Apollo.Query<BrowseSourcesQuery, BrowseSourcesQueryVariables> {
    document = BrowseSourcesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserPopoverDocument = gql`
    query UserPopover($userId: Int!) {
  user(id: $userId) {
    ...popoverUser
  }
}
    ${PopoverUserFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UserPopoverGQL extends Apollo.Query<UserPopoverQuery, UserPopoverQueryVariables> {
    document = UserPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UsersBrowseDocument = gql`
    query UsersBrowse($first: Int, $last: Int, $before: String, $after: String, $userName: String, $orgName: OrganizationFilter, $userRole: UserRole, $sortBy: UsersSort) {
  users(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $userName
    organization: $orgName
    role: $userRole
    sortBy: $sortBy
  ) {
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    totalCount
    edges {
      cursor
      node {
        ...UserBrowseTableRowFields
      }
    }
  }
}
    ${UserBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UsersBrowseGQL extends Apollo.Query<UsersBrowseQuery, UsersBrowseQueryVariables> {
    document = UsersBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseVariantGroupsDocument = gql`
    query BrowseVariantGroups($first: Int, $last: Int, $before: String, $after: String, $sortBy: VariantGroupsSort, $name: String, $geneNames: String, $variantNames: String) {
  browseVariantGroups(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    name: $name
    geneNames: $geneNames
    variantNames: $variantNames
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseVariantGroupRowFields
      }
    }
  }
}
    ${BrowseVariantGroupRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseVariantGroupsGQL extends Apollo.Query<BrowseVariantGroupsQuery, BrowseVariantGroupsQueryVariables> {
    document = BrowseVariantGroupsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypePopoverDocument = gql`
    query VariantTypePopover($variantTypeId: Int!) {
  variantTypePopover(id: $variantTypeId) {
    ...variantTypePopover
  }
}
    ${VariantTypePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypePopoverGQL extends Apollo.Query<VariantTypePopoverQuery, VariantTypePopoverQueryVariables> {
    document = VariantTypePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypesBrowseDocument = gql`
    query VariantTypesBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $soid: String, $sortBy: VariantTypeSort) {
  variantTypes(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    soid: $soid
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...VariantTypeBrowseTableRowFields
      }
    }
  }
}
    ${VariantTypeBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypesBrowseGQL extends Apollo.Query<VariantTypesBrowseQuery, VariantTypesBrowseQueryVariables> {
    document = VariantTypesBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantPopoverDocument = gql`
    query VariantPopover($variantId: Int!) {
  variant(id: $variantId) {
    ...variantPopoverFields
  }
}
    ${VariantPopoverFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantPopoverGQL extends Apollo.Query<VariantPopoverQuery, VariantPopoverQueryVariables> {
    document = VariantPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantsMenuDocument = gql`
    query VariantsMenu($geneId: Int, $variantName: String, $evidenceStatusFilter: VariantDisplayFilter, $first: Int, $last: Int, $before: String, $after: String) {
  variants(
    geneId: $geneId
    name: $variantName
    evidenceStatusFilter: $evidenceStatusFilter
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    edges {
      cursor
      node {
        ...menuVariant
      }
    }
  }
}
    ${MenuVariantFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantsMenuGQL extends Apollo.Query<VariantsMenuQuery, VariantsMenuQueryVariables> {
    document = VariantsMenuDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseVariantsDocument = gql`
    query BrowseVariants($variantName: String, $entrezSymbol: String, $diseaseName: String, $drugName: String, $variantAlias: String, $variantTypeId: Int, $variantGroupId: Int, $sortBy: VariantsSort, $first: Int, $last: Int, $before: String, $after: String) {
  browseVariants(
    variantName: $variantName
    entrezSymbol: $entrezSymbol
    diseaseName: $diseaseName
    drugName: $drugName
    variantAlias: $variantAlias
    variantTypeId: $variantTypeId
    variantGroupId: $variantGroupId
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    edges {
      cursor
      node {
        id
        name
        evidenceScore
        evidenceItemCount
        geneId
        geneName
        diseases {
          id
          name
        }
        drugs {
          id
          name
        }
        aliases {
          name
        }
        assertionCount
      }
    }
    totalCount
    filteredCount
    pageCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseVariantsGQL extends Apollo.Query<BrowseVariantsQuery, BrowseVariantsQueryVariables> {
    document = BrowseVariantsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerBaseDocument = gql`
    query ViewerBase {
  viewer {
    id
    username
    role
    displayName
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
    mostRecentConflictOfInterestStatement {
      coiStatus
    }
    mostRecentOrganizationId
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ViewerBaseGQL extends Apollo.Query<ViewerBaseQuery, ViewerBaseQueryVariables> {
    document = ViewerBaseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerNotificationCountDocument = gql`
    query ViewerNotificationCount {
  notifications {
    unreadCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ViewerNotificationCountGQL extends Apollo.Query<ViewerNotificationCountQuery, ViewerNotificationCountQueryVariables> {
    document = ViewerNotificationCountDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SubmitAssertionDocument = gql`
    mutation SubmitAssertion($input: SubmitAssertionInput!) {
  submitAssertion(input: $input) {
    clientMutationId
    assertion {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SubmitAssertionGQL extends Apollo.Mutation<SubmitAssertionMutation, SubmitAssertionMutationVariables> {
    document = SubmitAssertionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddCommentDocument = gql`
    mutation AddComment($input: AddCommentInput!) {
  addComment(input: $input) {
    clientMutationId
    comment {
      ...commentListNode
    }
  }
}
    ${CommentListNodeFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AddCommentGQL extends Apollo.Mutation<AddCommentMutation, AddCommentMutationVariables> {
    document = AddCommentDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PreviewCommentDocument = gql`
    query previewComment($commentText: String!) {
  previewCommentText(commentText: $commentText) {
    ...previewComment
  }
}
    ${PreviewCommentFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class PreviewCommentGQL extends Apollo.Query<PreviewCommentQuery, PreviewCommentQueryVariables> {
    document = PreviewCommentDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserTypeaheadDocument = gql`
    query userTypeahead($queryTerm: String!) {
  userTypeahead(queryTerm: $queryTerm) {
    username
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UserTypeaheadGQL extends Apollo.Query<UserTypeaheadQuery, UserTypeaheadQueryVariables> {
    document = UserTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EntityTypeaheadDocument = gql`
    query entityTypeahead($queryTerm: String!) {
  entityTypeahead(queryTerm: $queryTerm) {
    entityId
    tagType
    displayName
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class EntityTypeaheadGQL extends Apollo.Query<EntityTypeaheadQuery, EntityTypeaheadQueryVariables> {
    document = EntityTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AcmgCodeTypeaheadDocument = gql`
    query AcmgCodeTypeahead($code: String!) {
  acmgCodesTypeahead(queryTerm: $code) {
    id
    code
    description
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AcmgCodeTypeaheadGQL extends Apollo.Query<AcmgCodeTypeaheadQuery, AcmgCodeTypeaheadQueryVariables> {
    document = AcmgCodeTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DiseaseTypeaheadDocument = gql`
    query DiseaseTypeahead($name: String!) {
  diseaseTypeahead(queryTerm: $name) {
    id
    name
    displayName
    doid
    diseaseAliases
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DiseaseTypeaheadGQL extends Apollo.Query<DiseaseTypeaheadQuery, DiseaseTypeaheadQueryVariables> {
    document = DiseaseTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddDiseaseDocument = gql`
    mutation AddDisease($name: String!, $doid: Int) {
  addDisease(input: {name: $name, doid: $doid}) {
    ...AddDiseaseFields
  }
}
    ${AddDiseaseFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AddDiseaseGQL extends Apollo.Mutation<AddDiseaseMutation, AddDiseaseMutationVariables> {
    document = AddDiseaseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugTypeaheadDocument = gql`
    query DrugTypeahead($name: String!) {
  drugTypeahead(queryTerm: $name) {
    id
    name
    ncitId
    drugAliases
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugTypeaheadGQL extends Apollo.Query<DrugTypeaheadQuery, DrugTypeaheadQueryVariables> {
    document = DrugTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddDrugDocument = gql`
    mutation AddDrug($name: String!, $ncitId: String) {
  addDrug(input: {name: $name, ncitId: $ncitId}) {
    ...AddDrugFields
  }
}
    ${AddDrugFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AddDrugGQL extends Apollo.Mutation<AddDrugMutation, AddDrugMutationVariables> {
    document = AddDrugDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceTypeaheadDocument = gql`
    query EvidenceTypeahead($id: Int!) {
  evidenceItem(id: $id) {
    id
    status
    name
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceTypeaheadGQL extends Apollo.Query<EvidenceTypeaheadQuery, EvidenceTypeaheadQueryVariables> {
    document = EvidenceTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceTransferSearchDocument = gql`
    query EvidenceTransferSearch($id: Int, $first: Int) {
  evidenceItems(id: $id, first: $first) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...EvidenceTransferSearchFields
      }
    }
  }
}
    ${EvidenceTransferSearchFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceTransferSearchGQL extends Apollo.Query<EvidenceTransferSearchQuery, EvidenceTransferSearchQueryVariables> {
    document = EvidenceTransferSearchDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneTypeaheadDocument = gql`
    query GeneTypeahead($entrezSymbol: String!) {
  geneTypeahead(queryTerm: $entrezSymbol) {
    ...GeneTypeaheadFields
  }
}
    ${GeneTypeaheadFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GeneTypeaheadGQL extends Apollo.Query<GeneTypeaheadQuery, GeneTypeaheadQueryVariables> {
    document = GeneTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const NccnGuidelineTypeaheadDocument = gql`
    query NccnGuidelineTypeahead($name: String!) {
  nccnGuidelinesTypeahead(queryTerm: $name) {
    id
    name
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class NccnGuidelineTypeaheadGQL extends Apollo.Query<NccnGuidelineTypeaheadQuery, NccnGuidelineTypeaheadQueryVariables> {
    document = NccnGuidelineTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypeTypeaheadDocument = gql`
    query PhenotypeTypeahead($name: String!) {
  phenotypeTypeahead(queryTerm: $name) {
    hpoId
    id
    name
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypeTypeaheadGQL extends Apollo.Query<PhenotypeTypeaheadQuery, PhenotypeTypeaheadQueryVariables> {
    document = PhenotypeTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CitationTypeaheadDocument = gql`
    query CitationTypeahead($partialCitationId: Int!, $sourceType: SourceSource!) {
  sourceTypeahead(citationId: $partialCitationId, sourceType: $sourceType) {
    ...SourceTypeaheadResult
  }
}
    ${SourceTypeaheadResultFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CitationTypeaheadGQL extends Apollo.Query<CitationTypeaheadQuery, CitationTypeaheadQueryVariables> {
    document = CitationTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CitationExistenceCheckDocument = gql`
    query CitationExistenceCheck($sourceType: SourceSource!, $citationId: Int!) {
  remoteCitation(sourceType: $sourceType, citationId: $citationId)
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CitationExistenceCheckGQL extends Apollo.Query<CitationExistenceCheckQuery, CitationExistenceCheckQueryVariables> {
    document = CitationExistenceCheckDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateSourceStubDocument = gql`
    mutation CreateSourceStub($input: AddRemoteCitationInput!) {
  addRemoteCitation(input: $input) {
    newSource {
      id
      citationId
      sourceType
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateSourceStubGQL extends Apollo.Mutation<CreateSourceStubMutation, CreateSourceStubMutationVariables> {
    document = CreateSourceStubDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CheckRemoteCitationDocument = gql`
    query CheckRemoteCitation($sourceType: SourceSource!, $citationId: Int!) {
  remoteCitation(sourceType: $sourceType, citationId: $citationId)
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CheckRemoteCitationGQL extends Apollo.Query<CheckRemoteCitationQuery, CheckRemoteCitationQueryVariables> {
    document = CheckRemoteCitationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddRemoteCitationDocument = gql`
    mutation AddRemoteCitation($input: AddRemoteCitationInput!) {
  addRemoteCitation(input: $input) {
    newSource {
      ...SourceStubFields
    }
  }
}
    ${SourceStubFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AddRemoteCitationGQL extends Apollo.Mutation<AddRemoteCitationMutation, AddRemoteCitationMutationVariables> {
    document = AddRemoteCitationDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourceTypeaheadDocument = gql`
    query SourceTypeahead($partialCitationId: Int!, $sourceType: SourceSource!) {
  sourceTypeahead(citationId: $partialCitationId, sourceType: $sourceType) {
    ...SourceTypeaheadResult
  }
}
    ${SourceTypeaheadResultFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourceTypeaheadGQL extends Apollo.Query<SourceTypeaheadQuery, SourceTypeaheadQueryVariables> {
    document = SourceTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypeaheadDocument = gql`
    query VariantTypeahead($name: String!, $geneId: Int) {
  variants(name: $name, geneId: $geneId, first: 20) {
    nodes {
      ...VariantTypeaheadFields
    }
  }
}
    ${VariantTypeaheadFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypeaheadGQL extends Apollo.Query<VariantTypeaheadQuery, VariantTypeaheadQueryVariables> {
    document = VariantTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddVariantDocument = gql`
    mutation AddVariant($name: String!, $geneId: Int!) {
  addVariant(input: {name: $name, geneId: $geneId}) {
    ...AddVariantFields
  }
}
    ${AddVariantFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AddVariantGQL extends Apollo.Mutation<AddVariantMutation, AddVariantMutationVariables> {
    document = AddVariantDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantSelectDocument = gql`
    query VariantSelect($name: String!, $geneId: Int) {
  variants(name: $name, first: 20, geneId: $geneId) {
    nodes {
      ...VariantTypeaheadFields
    }
  }
}
    ${VariantTypeaheadFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantSelectGQL extends Apollo.Query<VariantSelectQuery, VariantSelectQueryVariables> {
    document = VariantSelectDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypeTypeaheadDocument = gql`
    query VariantTypeTypeahead($name: String!) {
  variantTypeTypeahead(queryTerm: $name) {
    name
    soid
    id
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypeTypeaheadGQL extends Apollo.Query<VariantTypeTypeaheadQuery, VariantTypeTypeaheadQueryVariables> {
    document = VariantTypeTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceItemRevisableFieldsDocument = gql`
    query EvidenceItemRevisableFields($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...RevisableEvidenceFields
  }
}
    ${RevisableEvidenceFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceItemRevisableFieldsGQL extends Apollo.Query<EvidenceItemRevisableFieldsQuery, EvidenceItemRevisableFieldsQueryVariables> {
    document = EvidenceItemRevisableFieldsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SuggestEvidenceItemRevisionDocument = gql`
    mutation SuggestEvidenceItemRevision($input: SuggestEvidenceItemRevisionInput!) {
  suggestEvidenceItemRevision(input: $input) {
    clientMutationId
    evidenceItem {
      id
      revisions {
        totalCount
        edges {
          node {
            id
            revisionsetId
            createdAt
            fieldName
            currentValue
            suggestedValue
            linkoutData {
              name
              diffValue {
                ... on ObjectFieldDiff {
                  addedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  removedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  keptObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                }
                ... on ScalarFieldDiff {
                  left
                  right
                }
              }
            }
            revisor {
              id
              name
            }
            status
          }
        }
      }
    }
    results {
      id
      fieldName
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SuggestEvidenceItemRevisionGQL extends Apollo.Mutation<SuggestEvidenceItemRevisionMutation, SuggestEvidenceItemRevisionMutationVariables> {
    document = SuggestEvidenceItemRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceSubmittableFieldsDocument = gql`
    query EvidenceSubmittableFields($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...SubmittableEvidenceFields
  }
}
    ${SubmittableEvidenceFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceSubmittableFieldsGQL extends Apollo.Query<EvidenceSubmittableFieldsQuery, EvidenceSubmittableFieldsQueryVariables> {
    document = EvidenceSubmittableFieldsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SubmitEvidenceItemDocument = gql`
    mutation SubmitEvidenceItem($input: SubmitEvidenceItemInput!) {
  submitEvidence(input: $input) {
    clientMutationId
    evidenceItem {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SubmitEvidenceItemGQL extends Apollo.Mutation<SubmitEvidenceItemMutation, SubmitEvidenceItemMutationVariables> {
    document = SubmitEvidenceItemDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const FlagEntityDocument = gql`
    mutation FlagEntity($input: FlagEntityInput!) {
  flagEntity(input: $input) {
    flag {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class FlagEntityGQL extends Apollo.Mutation<FlagEntityMutation, FlagEntityMutationVariables> {
    document = FlagEntityDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ResolveFlagDocument = gql`
    mutation ResolveFlag($input: ResolveFlagInput!) {
  resolveFlag(input: $input) {
    flag {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ResolveFlagGQL extends Apollo.Mutation<ResolveFlagMutation, ResolveFlagMutationVariables> {
    document = ResolveFlagDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneRevisableFieldsDocument = gql`
    query GeneRevisableFields($geneId: Int!) {
  gene(id: $geneId) {
    ...RevisableGeneFields
  }
}
    ${RevisableGeneFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GeneRevisableFieldsGQL extends Apollo.Query<GeneRevisableFieldsQuery, GeneRevisableFieldsQueryVariables> {
    document = GeneRevisableFieldsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SuggestGeneRevisionDocument = gql`
    mutation SuggestGeneRevision($input: SuggestGeneRevisionInput!) {
  suggestGeneRevision(input: $input) {
    clientMutationId
    gene {
      id
      revisions {
        totalCount
        edges {
          node {
            id
            revisionsetId
            createdAt
            fieldName
            currentValue
            suggestedValue
            linkoutData {
              name
              diffValue {
                ... on ObjectFieldDiff {
                  addedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  removedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  keptObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                }
                ... on ScalarFieldDiff {
                  left
                  right
                }
              }
            }
            revisor {
              id
              name
            }
            status
          }
        }
      }
    }
    results {
      id
      fieldName
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SuggestGeneRevisionGQL extends Apollo.Mutation<SuggestGeneRevisionMutation, SuggestGeneRevisionMutationVariables> {
    document = SuggestGeneRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SuggestSourceDocument = gql`
    mutation SuggestSource($input: SuggestSourceInput!) {
  suggestSource(input: $input) {
    clientMutationId
    sourceSuggestion {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SuggestSourceGQL extends Apollo.Mutation<SuggestSourceMutation, SuggestSourceMutationVariables> {
    document = SuggestSourceDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateCoiDocument = gql`
    mutation UpdateCoi($input: UpdateCoiInput!) {
  updateCoi(input: $input) {
    coiStatement {
      coiPresent
      coiStatus
      createdAt
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateCoiGQL extends Apollo.Mutation<UpdateCoiMutation, UpdateCoiMutationVariables> {
    document = UpdateCoiDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateUserProfileDocument = gql`
    mutation UpdateUserProfile($input: EditUserInput!) {
  editUser(input: $input) {
    user {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateUserProfileGQL extends Apollo.Mutation<UpdateUserProfileMutation, UpdateUserProfileMutationVariables> {
    document = UpdateUserProfileDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CountriesDocument = gql`
    query Countries {
  countries {
    id
    name
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CountriesGQL extends Apollo.Query<CountriesQuery, CountriesQueryVariables> {
    document = CountriesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantRevisableFieldsDocument = gql`
    query VariantRevisableFields($variantId: Int!) {
  variant(id: $variantId) {
    ...RevisableVariantFields
  }
}
    ${RevisableVariantFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantRevisableFieldsGQL extends Apollo.Query<VariantRevisableFieldsQuery, VariantRevisableFieldsQueryVariables> {
    document = VariantRevisableFieldsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SuggestVariantRevisionDocument = gql`
    mutation SuggestVariantRevision($input: SuggestVariantRevisionInput!) {
  suggestVariantRevision(input: $input) {
    clientMutationId
    variant {
      id
      revisions {
        totalCount
        edges {
          node {
            id
            revisionsetId
            createdAt
            fieldName
            currentValue
            suggestedValue
            linkoutData {
              name
              diffValue {
                ... on ObjectFieldDiff {
                  addedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  removedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  keptObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                }
                ... on ScalarFieldDiff {
                  left
                  right
                }
              }
            }
            revisor {
              id
              name
            }
            status
          }
        }
      }
    }
    results {
      id
      fieldName
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SuggestVariantRevisionGQL extends Apollo.Mutation<SuggestVariantRevisionMutation, SuggestVariantRevisionMutationVariables> {
    document = SuggestVariantRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssertionDetailDocument = gql`
    query AssertionDetail($assertionId: Int!) {
  assertion(id: $assertionId) {
    ...AssertionDetailFields
  }
}
    ${AssertionDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionDetailGQL extends Apollo.Query<AssertionDetailQuery, AssertionDetailQueryVariables> {
    document = AssertionDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssertionSummaryDocument = gql`
    query AssertionSummary($assertionId: Int!) {
  assertion(id: $assertionId) {
    ...AssertionSummaryFields
  }
}
    ${AssertionSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionSummaryGQL extends Apollo.Query<AssertionSummaryQuery, AssertionSummaryQueryVariables> {
    document = AssertionSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ClinicalTrialDetailDocument = gql`
    query ClinicalTrialDetail($clinicalTrialId: Int!) {
  clinicalTrial(id: $clinicalTrialId) {
    id
    name
    nctId
    description
    url
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ClinicalTrialDetailGQL extends Apollo.Query<ClinicalTrialDetailQuery, ClinicalTrialDetailQueryVariables> {
    document = ClinicalTrialDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DiseaseDetailDocument = gql`
    query DiseaseDetail($diseaseId: Int!) {
  disease(id: $diseaseId) {
    id
    name
    doid
    diseaseUrl
    displayName
    diseaseAliases
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DiseaseDetailGQL extends Apollo.Query<DiseaseDetailQuery, DiseaseDetailQueryVariables> {
    document = DiseaseDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugDetailDocument = gql`
    query DrugDetail($drugId: Int!) {
  drug(id: $drugId) {
    id
    name
    ncitId
    drugUrl
    drugAliases
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugDetailGQL extends Apollo.Query<DrugDetailQuery, DrugDetailQueryVariables> {
    document = DrugDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceDetailDocument = gql`
    query EvidenceDetail($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...EvidenceDetailFields
  }
}
    ${EvidenceDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceDetailGQL extends Apollo.Query<EvidenceDetailQuery, EvidenceDetailQueryVariables> {
    document = EvidenceDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceSummaryDocument = gql`
    query EvidenceSummary($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...EvidenceSummaryFields
  }
}
    ${EvidenceSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceSummaryGQL extends Apollo.Query<EvidenceSummaryQuery, EvidenceSummaryQueryVariables> {
    document = EvidenceSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneDetailDocument = gql`
    query GeneDetail($geneId: Int!) {
  gene(id: $geneId) {
    ...GeneDetailFields
  }
}
    ${GeneDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GeneDetailGQL extends Apollo.Query<GeneDetailQuery, GeneDetailQueryVariables> {
    document = GeneDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GenesSummaryDocument = gql`
    query GenesSummary($geneId: Int!) {
  gene(id: $geneId) {
    ...GeneSummaryFields
  }
}
    ${GeneSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GenesSummaryGQL extends Apollo.Query<GenesSummaryQuery, GenesSummaryQueryVariables> {
    document = GenesSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationDetailDocument = gql`
    query OrganizationDetail($organizationId: Int!) {
  organization(id: $organizationId) {
    ...OrganizationDetailFields
  }
}
    ${OrganizationDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationDetailGQL extends Apollo.Query<OrganizationDetailQuery, OrganizationDetailQueryVariables> {
    document = OrganizationDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationGroupsDocument = gql`
    query OrganizationGroups($organizationId: Int!) {
  organization(id: $organizationId) {
    subGroups {
      ...OrganizationGroupsFields
    }
  }
}
    ${OrganizationGroupsFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationGroupsGQL extends Apollo.Query<OrganizationGroupsQuery, OrganizationGroupsQueryVariables> {
    document = OrganizationGroupsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationMembersDocument = gql`
    query OrganizationMembers($organizationId: Int!) {
  organization(id: $organizationId) {
    members {
      edges {
        cursor
        node {
          ...OrganizationMembersFields
        }
      }
    }
  }
}
    ${OrganizationMembersFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationMembersGQL extends Apollo.Query<OrganizationMembersQuery, OrganizationMembersQueryVariables> {
    document = OrganizationMembersDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypeDetailDocument = gql`
    query PhenotypeDetail($phenotypeId: Int!) {
  phenotype(id: $phenotypeId) {
    id
    name
    hpoId
    url
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypeDetailGQL extends Apollo.Query<PhenotypeDetailQuery, PhenotypeDetailQueryVariables> {
    document = PhenotypeDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DataReleasesDocument = gql`
    query DataReleases {
  dataReleases {
    ...Release
  }
}
    ${ReleaseFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class DataReleasesGQL extends Apollo.Query<DataReleasesQuery, DataReleasesQueryVariables> {
    document = DataReleasesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourceDetailDocument = gql`
    query SourceDetail($sourceId: Int!) {
  source(id: $sourceId) {
    ...SourceDetailFields
  }
}
    ${SourceDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourceDetailGQL extends Apollo.Query<SourceDetailQuery, SourceDetailQueryVariables> {
    document = SourceDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourceSummaryDocument = gql`
    query SourceSummary($sourceId: Int!) {
  source(id: $sourceId) {
    ...SourceSummaryFields
  }
}
    ${SourceSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourceSummaryGQL extends Apollo.Query<SourceSummaryQuery, SourceSummaryQueryVariables> {
    document = SourceSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserDetailDocument = gql`
    query UserDetail($userId: Int!) {
  user(id: $userId) {
    ...UserDetailFields
  }
}
    ${UserDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UserDetailGQL extends Apollo.Query<UserDetailQuery, UserDetailQueryVariables> {
    document = UserDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserNotificationsDocument = gql`
    query UserNotifications($first: Int, $last: Int, $before: String, $after: String, $notificationReason: NotificationReason, $subscriptionId: Int, $originatingObject: SubscribableInput, $eventType: EventAction, $originatingUserId: Int, $organizationId: Int, $includeRead: Boolean) {
  notifications(
    first: $first
    last: $last
    before: $before
    after: $after
    notificationReason: $notificationReason
    subscriptionId: $subscriptionId
    originatingObject: $originatingObject
    eventType: $eventType
    originatingUserId: $originatingUserId
    organizationId: $organizationId
    includeRead: $includeRead
  ) {
    pageInfo {
      startCursor
      endCursor
      hasNextPage
      hasPreviousPage
    }
    notificationSubjects {
      ...notificationFeedSubjects
    }
    originatingUsers {
      ...notificationOriginatingUsers
    }
    organizations {
      ...notificationOrganization
    }
    eventTypes
    edges {
      node {
        ...notificationNode
      }
    }
  }
}
    ${NotificationFeedSubjectsFragmentDoc}
${NotificationOriginatingUsersFragmentDoc}
${NotificationOrganizationFragmentDoc}
${NotificationNodeFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UserNotificationsGQL extends Apollo.Query<UserNotificationsQuery, UserNotificationsQueryVariables> {
    document = UserNotificationsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UpdateNotificationStatusDocument = gql`
    mutation UpdateNotificationStatus($input: UpdateNotificationStatusInput!) {
  updateNotificationStatus(input: $input) {
    notifications {
      ...notificationNode
    }
  }
}
    ${NotificationNodeFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateNotificationStatusGQL extends Apollo.Mutation<UpdateNotificationStatusMutation, UpdateNotificationStatusMutationVariables> {
    document = UpdateNotificationStatusDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UnsubscribeDocument = gql`
    mutation Unsubscribe($input: UnsubscribeInput!) {
  unsubscribe(input: $input) {
    unsubscribedEntities {
      ...subscribable
    }
  }
}
    ${SubscribableFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UnsubscribeGQL extends Apollo.Mutation<UnsubscribeMutation, UnsubscribeMutationVariables> {
    document = UnsubscribeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SubscribeDocument = gql`
    mutation Subscribe($input: SubscribeInput!) {
  subscribe(input: $input) {
    subscriptions {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SubscribeGQL extends Apollo.Mutation<SubscribeMutation, SubscribeMutationVariables> {
    document = SubscribeDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantGroupDetailDocument = gql`
    query VariantGroupDetail($variantGroupId: Int!) {
  variantGroup(id: $variantGroupId) {
    ...VariantGroupDetailFields
  }
}
    ${VariantGroupDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantGroupDetailGQL extends Apollo.Query<VariantGroupDetailQuery, VariantGroupDetailQueryVariables> {
    document = VariantGroupDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantGroupRevisionsDocument = gql`
    query VariantGroupRevisions($variantGroupId: Int!, $first: Int, $last: Int, $before: String, $after: String, $fieldName: String, $originatingUserId: Int) {
  variantGroup(id: $variantGroupId) {
    id
    revisions(
      first: $first
      last: $last
      before: $before
      after: $after
      fieldName: $fieldName
      originatingUserId: $originatingUserId
    ) {
      totalCount
      uniqueRevisors {
        username
        id
        profileImagePath(size: 32)
      }
      revisedFieldNames {
        name
        displayName
      }
      edges {
        node {
          id
          revisionsetId
          createdAt
          fieldName
          currentValue
          suggestedValue
          linkoutData {
            name
            diffValue {
              ... on ObjectFieldDiff {
                addedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                removedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                keptObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
              }
              ... on ScalarFieldDiff {
                left
                right
              }
            }
          }
          revisor {
            id
            name
          }
          status
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantGroupRevisionsGQL extends Apollo.Query<VariantGroupRevisionsQuery, VariantGroupRevisionsQueryVariables> {
    document = VariantGroupRevisionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantGroupsSummaryDocument = gql`
    query VariantGroupsSummary($variantGroupId: Int!) {
  variantGroup(id: $variantGroupId) {
    ...VariantGroupSummaryFields
  }
}
    ${VariantGroupSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantGroupsSummaryGQL extends Apollo.Query<VariantGroupsSummaryQuery, VariantGroupsSummaryQueryVariables> {
    document = VariantGroupsSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypeDetailDocument = gql`
    query VariantTypeDetail($variantTypeId: Int!) {
  variantType(id: $variantTypeId) {
    id
    name
    soid
    description
    url
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypeDetailGQL extends Apollo.Query<VariantTypeDetailQuery, VariantTypeDetailQueryVariables> {
    document = VariantTypeDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantDetailDocument = gql`
    query VariantDetail($variantId: Int!) {
  variant(id: $variantId) {
    ...VariantDetailFields
  }
}
    ${VariantDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantDetailGQL extends Apollo.Query<VariantDetailQuery, VariantDetailQueryVariables> {
    document = VariantDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantSummaryDocument = gql`
    query VariantSummary($variantId: Int!) {
  variant(id: $variantId) {
    ...VariantSummaryFields
  }
}
    ${VariantSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantSummaryGQL extends Apollo.Query<VariantSummaryQuery, VariantSummaryQueryVariables> {
    document = VariantSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }