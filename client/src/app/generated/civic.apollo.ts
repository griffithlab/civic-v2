/* eslint-disable */
import { gql } from 'apollo-angular';
import { Injectable } from '@angular/core';
import * as Apollo from 'apollo-angular';
export type Maybe<T> = T | undefined;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** Represents untyped JSON */
  JSON: any;
};



/** Autogenerated input type of AcceptRevision */
export type AcceptRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Body of an optional comment to attach to the revision on acceptance. */
  comment?: Maybe<Scalars['String']>;
  /** The ID of the Revision to accept. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of AcceptRevision */
export type AcceptRevisionPayload = {
  __typename: 'AcceptRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly accepted Revision. */
  revision: Revision;
  /** A list of any revisions that were superseded by the acceptance of this one. */
  supersededRevisions: Array<Revision>;
};

export type AcmgCode = {
  __typename: 'AcmgCode';
  code: Scalars['String'];
  description: Scalars['String'];
  id: Scalars['Int'];
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  /** Text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The commentable to attach the comment to. Specified by ID and Type. */
  subject: CommentableInput;
  /** Optional title for the comment. */
  title?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddComment */
export type AddCommentPayload = {
  __typename: 'AddCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<Comment>;
};

/** Autogenerated input type of AddRemoteCitation */
export type AddRemoteCitationInput = {
  /** The external id for the source to add. */
  citationId: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The origin of the external source. */
  sourceType: SourceSource;
};

/** Autogenerated return type of AddRemoteCitation */
export type AddRemoteCitationPayload = {
  __typename: 'AddRemoteCitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The stubbed in record for the newly created source. */
  newSource: SourceStub;
};

export type AdvancedSearchResult = {
  __typename: 'AdvancedSearchResult';
  permalinkId?: Maybe<Scalars['String']>;
  resultIds: Array<Scalars['Int']>;
  searchEndpoint: Scalars['String'];
};

export enum AmpLevel {
  Na = 'NA',
  TierIii = 'TIER_III',
  TierIiLevelC = 'TIER_II_LEVEL_C',
  TierIiLevelD = 'TIER_II_LEVEL_D',
  TierIv = 'TIER_IV',
  TierILevelA = 'TIER_I_LEVEL_A',
  TierILevelB = 'TIER_I_LEVEL_B'
}

export type Assertion = Commentable & EventOriginObject & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Assertion';
  acceptanceEvent?: Maybe<Event>;
  acmgCodes: Array<AcmgCode>;
  ampLevel?: Maybe<AmpLevel>;
  assertionDirection: EvidenceDirection;
  assertionType: EvidenceType;
  clinicalSignificance: EvidenceClinicalSignificance;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  disease?: Maybe<Disease>;
  drugInteractionType?: Maybe<DrugInteraction>;
  drugs: Array<Drug>;
  /** List and filter events for an object */
  events: EventConnection;
  fdaCompanionTest?: Maybe<Scalars['Boolean']>;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  name: Scalars['String'];
  nccnGuideline?: Maybe<Scalars['String']>;
  phenotypes: Array<Phenotype>;
  regulatoryApproval?: Maybe<Scalars['Boolean']>;
  rejectionEvent?: Maybe<Event>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  source: Source;
  status: EvidenceStatus;
  submissionEvent: Event;
  summary: Scalars['String'];
  variant: Variant;
  variantOrigin: VariantOrigin;
};


export type AssertionCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type AssertionEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type AssertionFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type AssertionRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

/** The connection type for Assertion. */
export type AssertionConnection = {
  __typename: 'AssertionConnection';
  /** A list of edges. */
  edges: Array<AssertionEdge>;
  /** A list of nodes. */
  nodes: Array<Assertion>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AssertionEdge = {
  __typename: 'AssertionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Assertion>;
};

export type AssertionSort = {
  /** Available columns for sorting */
  column: AssertionSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum AssertionSortColumns {
  AmpLevel = 'AMP_LEVEL',
  AssertionDirection = 'ASSERTION_DIRECTION',
  AssertionType = 'ASSERTION_TYPE',
  ClinicalSignificance = 'CLINICAL_SIGNIFICANCE',
  DiseaseName = 'DISEASE_NAME',
  DrugName = 'DRUG_NAME',
  GeneName = 'GENE_NAME',
  Id = 'ID',
  Status = 'STATUS',
  Summary = 'SUMMARY',
  VariantName = 'VARIANT_NAME'
}

export enum BooleanOperator {
  And = 'AND',
  Or = 'OR'
}

export type BooleanSearchInput = {
  value: Scalars['Boolean'];
};

export type BrowseClinicalTrial = {
  __typename: 'BrowseClinicalTrial';
  evidenceCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nctId?: Maybe<Scalars['String']>;
  sourceCount: Scalars['Int'];
  url?: Maybe<Scalars['String']>;
};

/** The connection type for BrowseClinicalTrial. */
export type BrowseClinicalTrialConnection = {
  __typename: 'BrowseClinicalTrialConnection';
  /** A list of edges. */
  edges: Array<BrowseClinicalTrialEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseClinicalTrial>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseClinicalTrialEdge = {
  __typename: 'BrowseClinicalTrialEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseClinicalTrial>;
};

export type BrowseDisease = {
  __typename: 'BrowseDisease';
  assertionCount: Scalars['Int'];
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['String']>;
  evidenceItemCount: Scalars['Int'];
  geneNames: Array<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseDisease. */
export type BrowseDiseaseConnection = {
  __typename: 'BrowseDiseaseConnection';
  /** A list of edges. */
  edges: Array<BrowseDiseaseEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseDisease>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseDiseaseEdge = {
  __typename: 'BrowseDiseaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseDisease>;
};

export type BrowseDrug = {
  __typename: 'BrowseDrug';
  assertionCount: Scalars['Int'];
  drugUrl?: Maybe<Scalars['String']>;
  evidenceCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

/** The connection type for BrowseDrug. */
export type BrowseDrugConnection = {
  __typename: 'BrowseDrugConnection';
  /** A list of edges. */
  edges: Array<BrowseDrugEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseDrug>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseDrugEdge = {
  __typename: 'BrowseDrugEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseDrug>;
};

export type BrowseGene = {
  __typename: 'BrowseGene';
  aliases?: Maybe<Array<GeneAlias>>;
  assertionCount: Scalars['Int'];
  description: Scalars['String'];
  diseases?: Maybe<Array<Disease>>;
  drugs?: Maybe<Array<Drug>>;
  entrezId: Scalars['Int'];
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseGene. */
export type BrowseGeneConnection = {
  __typename: 'BrowseGeneConnection';
  /** A list of edges. */
  edges: Array<BrowseGeneEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseGene>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseGeneEdge = {
  __typename: 'BrowseGeneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseGene>;
};

export type BrowsePhenotype = {
  __typename: 'BrowsePhenotype';
  assertionCount: Scalars['Int'];
  evidenceCount: Scalars['Int'];
  hpoId: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  url: Scalars['String'];
};

/** The connection type for BrowsePhenotype. */
export type BrowsePhenotypeConnection = {
  __typename: 'BrowsePhenotypeConnection';
  /** A list of edges. */
  edges: Array<BrowsePhenotypeEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowsePhenotype>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowsePhenotypeEdge = {
  __typename: 'BrowsePhenotypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowsePhenotype>;
};

export type BrowseSource = {
  __typename: 'BrowseSource';
  authors: Array<Scalars['String']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials: Array<ClinicalTrial>;
  displayType: Scalars['String'];
  evidenceItemCount: Scalars['Int'];
  id: Scalars['Int'];
  journal?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  publicationYear?: Maybe<Scalars['Int']>;
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
};

/** The connection type for BrowseSource. */
export type BrowseSourceConnection = {
  __typename: 'BrowseSourceConnection';
  /** A list of edges. */
  edges: Array<BrowseSourceEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseSource>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseSourceEdge = {
  __typename: 'BrowseSourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseSource>;
};

export type BrowseVariant = {
  __typename: 'BrowseVariant';
  assertionCount: Scalars['Int'];
  diseases: Array<Disease>;
  drugs: Array<Drug>;
  evidenceItemCount: Scalars['Int'];
  evidenceScore: Scalars['Float'];
  geneId: Scalars['Int'];
  geneName: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** The connection type for BrowseVariant. */
export type BrowseVariantConnection = {
  __typename: 'BrowseVariantConnection';
  /** A list of edges. */
  edges: Array<BrowseVariantEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseVariant>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseVariantEdge = {
  __typename: 'BrowseVariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseVariant>;
};

export type BrowseVariantGroup = {
  __typename: 'BrowseVariantGroup';
  evidenceItemCount: Scalars['Int'];
  geneNames: Array<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  variantCount: Scalars['Int'];
  variantNames: Array<Scalars['String']>;
};

/** The connection type for BrowseVariantGroup. */
export type BrowseVariantGroupConnection = {
  __typename: 'BrowseVariantGroupConnection';
  /** A list of edges. */
  edges: Array<BrowseVariantGroupEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseVariantGroup>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseVariantGroupEdge = {
  __typename: 'BrowseVariantGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseVariantGroup>;
};

export type BrowseVariantType = {
  __typename: 'BrowseVariantType';
  id: Scalars['Int'];
  name: Scalars['String'];
  soid: Scalars['String'];
  url?: Maybe<Scalars['String']>;
  variantCount: Scalars['Int'];
};

/** The connection type for BrowseVariantType. */
export type BrowseVariantTypeConnection = {
  __typename: 'BrowseVariantTypeConnection';
  /** A list of edges. */
  edges: Array<BrowseVariantTypeEdge>;
  /** The total number of records in this set. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes: Array<BrowseVariantType>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records of this type, regardless of any filtering. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BrowseVariantTypeEdge = {
  __typename: 'BrowseVariantTypeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BrowseVariantType>;
};

export type ClinicalTrial = {
  __typename: 'ClinicalTrial';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  nctId: Scalars['String'];
  url?: Maybe<Scalars['String']>;
};

export type ClinicalTrialSort = {
  /** Available columns for sorting */
  column: ClinicalTrialSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum ClinicalTrialSortColumns {
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  Name = 'NAME',
  NctId = 'NCT_ID',
  SourceCount = 'SOURCE_COUNT'
}

/**
 * An input object representing possible ClinVar ID states.
 * You may specify either one or more Integer IDs OR either none found or not applicable.
 */
export type ClinvarInput = {
  /** The ClinVar ID(s) */
  ids?: Maybe<Array<Scalars['Int']>>;
  noneFound?: Maybe<Scalars['Boolean']>;
  notApplicable?: Maybe<Scalars['Boolean']>;
};

export type Coi = {
  __typename: 'Coi';
  coiPresent: Scalars['Boolean'];
  coiStatement?: Maybe<Scalars['String']>;
  coiStatus: Scalars['String'];
  createdAt?: Maybe<Scalars['ISO8601DateTime']>;
  expiresAt: Scalars['ISO8601DateTime'];
};

export type Comment = EventOriginObject & {
  __typename: 'Comment';
  comment: Scalars['String'];
  commentable: Commentable;
  commenter: User;
  createdAt: Scalars['ISO8601DateTime'];
  creationEvent?: Maybe<Event>;
  id: Scalars['Int'];
  name: Scalars['String'];
  title?: Maybe<Scalars['String']>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename: 'CommentConnection';
  /** A list of edges. */
  edges: Array<CommentEdge>;
  /** A list of nodes. */
  nodes: Array<Comment>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have commented on this entity. */
  uniqueCommenters: Array<User>;
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

/** A CIViC entity that can have comments on it. */
export type Commentable = {
  /** List and filter comments. */
  comments: CommentConnection;
  id: Scalars['Int'];
  lastCommentEvent?: Maybe<Event>;
  name: Scalars['String'];
};


/** A CIViC entity that can have comments on it. */
export type CommentableCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum CommentableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Entity to comment on */
export type CommentableInput = {
  /** The type of the entity to comment on. */
  entityType: CommentableEntities;
  /** ID of the entity to comment on. */
  id: Scalars['Int'];
};

/** A user with all the unique kinds of actions they've performed on a given entity */
export type ContributingUser = {
  __typename: 'ContributingUser';
  lastActionDate: Scalars['ISO8601DateTime'];
  totalActionCount: Scalars['Int'];
  uniqueActions: Array<Contribution>;
  user: User;
};

export type ContributingUsersSummary = {
  __typename: 'ContributingUsersSummary';
  curators: Array<ContributingUser>;
  editors: Array<ContributingUser>;
};

export type Contribution = {
  __typename: 'Contribution';
  action: EventAction;
  count: Scalars['Int'];
};

export type Coordinate = {
  __typename: 'Coordinate';
  chromosome?: Maybe<Scalars['String']>;
  referenceBases?: Maybe<Scalars['String']>;
  representativeTranscript?: Maybe<Scalars['String']>;
  start?: Maybe<Scalars['Int']>;
  stop?: Maybe<Scalars['Int']>;
  variantBases?: Maybe<Scalars['String']>;
};

export type CoordinateInput = {
  chromosome?: Maybe<Scalars['String']>;
  representativeTranscript?: Maybe<Scalars['String']>;
  start?: Maybe<Scalars['Int']>;
  stop?: Maybe<Scalars['Int']>;
};

export type DateSort = {
  /** Value to sort by. */
  column: DateSortColumns;
  /** Sort direction. */
  direction: SortDirection;
};

export enum DateSortColumns {
  Created = 'CREATED',
  LastModified = 'LAST_MODIFIED'
}

export type Disease = {
  __typename: 'Disease';
  diseaseUrl?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  doid?: Maybe<Scalars['Int']>;
  id: Scalars['Int'];
  name: Scalars['String'];
};

export type DiseasesSort = {
  /** Available columns for sorting */
  column: DiseasesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum DiseasesSortColumns {
  AssertionCount = 'ASSERTION_COUNT',
  Doid = 'DOID',
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  GeneNames = 'GENE_NAMES',
  Name = 'NAME',
  VariantCount = 'VARIANT_COUNT'
}

export type Drug = {
  __typename: 'Drug';
  drugUrl?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  name: Scalars['String'];
  ncitId?: Maybe<Scalars['String']>;
};

export enum DrugInteraction {
  Combination = 'COMBINATION',
  Sequential = 'SEQUENTIAL',
  Substitutes = 'SUBSTITUTES'
}

export type DrugSort = {
  /** Available columns for sorting */
  column: DrugSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum DrugSortColumns {
  AssertionCount = 'ASSERTION_COUNT',
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  Name = 'NAME',
  NcitId = 'NCIT_ID'
}

export type Event = {
  __typename: 'Event';
  action: EventAction;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['Int'];
  organization?: Maybe<Organization>;
  originatingObject?: Maybe<EventOriginObject>;
  originatingUser: User;
  subject: EventSubject;
};

export enum EventAction {
  Accepted = 'ACCEPTED',
  AssertionAccepted = 'ASSERTION_ACCEPTED',
  AssertionRejected = 'ASSERTION_REJECTED',
  AssertionSubmitted = 'ASSERTION_SUBMITTED',
  Commented = 'COMMENTED',
  Flagged = 'FLAGGED',
  FlagResolved = 'FLAG_RESOLVED',
  PublicationSuggested = 'PUBLICATION_SUGGESTED',
  Rejected = 'REJECTED',
  Reverted = 'REVERTED',
  RevisionAccepted = 'REVISION_ACCEPTED',
  RevisionRejected = 'REVISION_REJECTED',
  RevisionSuggested = 'REVISION_SUGGESTED',
  RevisionSuperseded = 'REVISION_SUPERSEDED',
  Submitted = 'SUBMITTED'
}

/** The connection type for Event. */
export type EventConnection = {
  __typename: 'EventConnection';
  /** A list of edges. */
  edges: Array<EventEdge>;
  /** List of event types that have occured on this entity. */
  eventTypes: Array<EventAction>;
  /** A list of nodes. */
  nodes: Array<Event>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** List of all organizations who are involved in this event stream. */
  participatingOrganizations: Array<Organization>;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have generated an event on the subject entity. */
  uniqueParticipants: Array<User>;
};

/** An edge in a connection. */
export type EventEdge = {
  __typename: 'EventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Event>;
};

/**
 * The originating object for an event.
 * This is useful when the subject of an event is not the actual origin of the event.
 * For instance when you suggest a revision, the subject of the Event will be the entity being revised,
 * while the originating object will be the Revision itself.
 */
export type EventOriginObject = {
  id: Scalars['Int'];
  name: Scalars['String'];
};

/** The subject of an event log event. */
export type EventSubject = {
  /** List and filter events for an object */
  events: EventConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
};


/** The subject of an event log event. */
export type EventSubjectEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum EvidenceClinicalSignificance {
  AdverseResponse = 'ADVERSE_RESPONSE',
  Benign = 'BENIGN',
  BetterOutcome = 'BETTER_OUTCOME',
  DominantNegative = 'DOMINANT_NEGATIVE',
  GainOfFunction = 'GAIN_OF_FUNCTION',
  LikelyBenign = 'LIKELY_BENIGN',
  LikelyPathogenic = 'LIKELY_PATHOGENIC',
  LossOfFunction = 'LOSS_OF_FUNCTION',
  Na = 'NA',
  Negative = 'NEGATIVE',
  Neomorphic = 'NEOMORPHIC',
  Pathogenic = 'PATHOGENIC',
  PoorOutcome = 'POOR_OUTCOME',
  Positive = 'POSITIVE',
  ReducedSensitivity = 'REDUCED_SENSITIVITY',
  Resistance = 'RESISTANCE',
  Sensitivityresponse = 'SENSITIVITYRESPONSE',
  UnalteredFunction = 'UNALTERED_FUNCTION',
  UncertainSignificance = 'UNCERTAIN_SIGNIFICANCE',
  Unknown = 'UNKNOWN'
}

export enum EvidenceDirection {
  DoesNotSupport = 'DOES_NOT_SUPPORT',
  Na = 'NA',
  Supports = 'SUPPORTS'
}

export type EvidenceItem = Commentable & EventOriginObject & EventSubject & Flaggable & WithRevisions & {
  __typename: 'EvidenceItem';
  acceptanceEvent?: Maybe<Event>;
  assertions: Array<Assertion>;
  clinicalSignificance: EvidenceClinicalSignificance;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  disease?: Maybe<Disease>;
  drugInteractionType?: Maybe<DrugInteraction>;
  drugs: Array<Drug>;
  /** List and filter events for an object */
  events: EventConnection;
  evidenceDirection?: Maybe<EvidenceDirection>;
  evidenceLevel: EvidenceLevel;
  evidenceRating?: Maybe<Scalars['Int']>;
  evidenceType: EvidenceType;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  name: Scalars['String'];
  phenotypes: Array<Phenotype>;
  rejectionEvent?: Maybe<Event>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  source: Source;
  status: EvidenceStatus;
  submissionEvent: Event;
  variant: Variant;
  variantHgvs: Scalars['String'];
  variantOrigin: VariantOrigin;
};


export type EvidenceItemCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type EvidenceItemEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type EvidenceItemFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type EvidenceItemRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

/** The connection type for EvidenceItem. */
export type EvidenceItemConnection = {
  __typename: 'EvidenceItemConnection';
  /** A list of edges. */
  edges: Array<EvidenceItemEdge>;
  /** A list of nodes. */
  nodes: Array<EvidenceItem>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type EvidenceItemEdge = {
  __typename: 'EvidenceItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<EvidenceItem>;
};

/** Fields on an EvidenceItem that curators may propose revisions to. */
export type EvidenceItemFields = {
  /** The Clinical Significance of the EvidenceItem */
  clinicalSignificance: EvidenceClinicalSignificance;
  /** The Evidence Items's description/summary text. */
  description: NullableStringInput;
  /** The ID of the disease (if applicable) for this EvidenceItem */
  diseaseId: NullableIntInput;
  /** List of IDs of CIViC Drug entries for this EvidenceItem. An empty list indicates none. */
  drugIds: Array<Scalars['Int']>;
  /** Drug interaction type for cases where more than one drug ID is provided. */
  drugInteractionType: NullableDrugInteractionTypeInput;
  /** The evidence direction for this EvidenceItem. */
  evidenceDirection: EvidenceDirection;
  /** The evidence level of the EvidenceItem */
  evidenceLevel: EvidenceLevel;
  /** The Type of the EvidenceItem */
  evidenceType: EvidenceType;
  /** List of IDs of CIViC Phenotype entries for this EvidenceItem. An empty list indicates none. */
  phenotypeIds: Array<Scalars['Int']>;
  /** The rating for this EvidenceItem */
  rating: Scalars['Int'];
  /** The ID of the Source from which this EvidenceItem was curated. */
  sourceId: Scalars['Int'];
  /** The ID of the Variant to which this EvidenceItem belongs */
  variantId: Scalars['Int'];
  /** The Variant Origin for this EvidenceItem. */
  variantOrigin: VariantOrigin;
};

export enum EvidenceLevel {
  A = 'A',
  B = 'B',
  C = 'C',
  D = 'D',
  E = 'E'
}

export type EvidenceSort = {
  /** Available columns for sorting */
  column: EvidenceSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum EvidenceSortColumns {
  ClinicalSignificance = 'CLINICAL_SIGNIFICANCE',
  Description = 'DESCRIPTION',
  DiseaseName = 'DISEASE_NAME',
  DrugName = 'DRUG_NAME',
  EvidenceDirection = 'EVIDENCE_DIRECTION',
  EvidenceLevel = 'EVIDENCE_LEVEL',
  EvidenceRating = 'EVIDENCE_RATING',
  EvidenceType = 'EVIDENCE_TYPE',
  GeneSymbol = 'GENE_SYMBOL',
  Id = 'ID',
  Status = 'STATUS',
  VariantName = 'VARIANT_NAME',
  VariantOrigin = 'VARIANT_ORIGIN'
}

export enum EvidenceStatus {
  Accepted = 'ACCEPTED',
  Rejected = 'REJECTED',
  Submitted = 'SUBMITTED'
}

export enum EvidenceType {
  Diagnostic = 'DIAGNOSTIC',
  Functional = 'FUNCTIONAL',
  Oncogenic = 'ONCOGENIC',
  Predictive = 'PREDICTIVE',
  Predisposing = 'PREDISPOSING',
  Prognostic = 'PROGNOSTIC'
}

export type FieldName = {
  __typename: 'FieldName';
  /** The user facing representation of the field name. */
  displayName: Scalars['String'];
  /** The internal server representation of the field name. */
  name: Scalars['String'];
};

export type Flag = Commentable & EventOriginObject & {
  __typename: 'Flag';
  /** List and filter comments. */
  comments: CommentConnection;
  createdAt: Scalars['ISO8601DateTime'];
  flaggable: Flaggable;
  flaggingUser: User;
  id: Scalars['Int'];
  lastCommentEvent?: Maybe<Event>;
  name: Scalars['String'];
  openComment: Comment;
  resolutionComment?: Maybe<Comment>;
  resolvedAt?: Maybe<Scalars['ISO8601DateTime']>;
  resolvingUser?: Maybe<User>;
  state: FlagState;
};


export type FlagCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** The connection type for Flag. */
export type FlagConnection = {
  __typename: 'FlagConnection';
  /** A list of edges. */
  edges: Array<FlagEdge>;
  /** A list of nodes. */
  nodes: Array<Flag>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type FlagEdge = {
  __typename: 'FlagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Flag>;
};

/** Autogenerated input type of FlagEntity */
export type FlagEntityInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the problem you observed with this entity. */
  comment: Scalars['String'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
  /** The entity to flag, specified by its ID and type. */
  subject: FlaggableInput;
};

/** Autogenerated return type of FlagEntity */
export type FlagEntityPayload = {
  __typename: 'FlagEntityPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created Flag. */
  flag?: Maybe<Flag>;
};

export enum FlagState {
  Open = 'OPEN',
  Resolved = 'RESOLVED'
}

/** A CIViC entity that can be flagged for editor attention. */
export type Flaggable = {
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  name: Scalars['String'];
};


/** A CIViC entity that can be flagged for editor attention. */
export type FlaggableFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};

/** Enumeration of all entities in CIViC that can be flagged. */
export enum FlaggableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Entity to flag */
export type FlaggableInput = {
  /** The type of the entity to flag. */
  entityType: FlaggableEntities;
  /** The ID of the entity. */
  id: Scalars['Int'];
};

export type Gene = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Gene';
  aliases: Array<GeneAlias>;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  entrezId: Scalars['Int'];
  /** List and filter events for an object */
  events: EventConnection;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  myGeneInfoDetails?: Maybe<Scalars['JSON']>;
  name: Scalars['String'];
  officialName: Scalars['String'];
  /** List and filter revisions. */
  revisions: RevisionConnection;
  sources: Array<Source>;
  /** List and filter variants. */
  variants: VariantConnection;
};


export type GeneCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type GeneEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type GeneFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type GeneRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};


export type GeneVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

export type GeneAlias = {
  __typename: 'GeneAlias';
  name: Scalars['String'];
};

/** Fields on a Gene that curators may propose revisions to. */
export type GeneFields = {
  /** The Gene's description/summary text. */
  description: NullableStringInput;
  /** Source IDs cited by the Gene's summary. */
  sourceIds: Array<Scalars['Int']>;
};

export type GeneSearchFilter = {
  alias?: Maybe<StringSearchInput>;
  booleanOperator?: Maybe<BooleanOperator>;
  description?: Maybe<StringSearchInput>;
  entrezId?: Maybe<IntSearchInput>;
  entrezSymbol?: Maybe<StringSearchInput>;
  hasAssertion?: Maybe<BooleanSearchInput>;
  id?: Maybe<IntSearchInput>;
  openRevisionCount?: Maybe<IntSearchInput>;
  subFilters?: Maybe<Array<GeneSearchFilter>>;
};

export type GenesSort = {
  /** Available columns for sorting */
  column: GenesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum GenesSortColumns {
  AssertionCount = 'assertionCount',
  DiseaseName = 'diseaseName',
  DrugName = 'drugName',
  EntrezSymbol = 'entrezSymbol',
  EvidenceItemCount = 'evidenceItemCount',
  GeneAlias = 'geneAlias',
  VariantCount = 'variantCount'
}


export type IntSearchInput = {
  comparisonOperator: IntSearchOperator;
  value: Scalars['Int'];
};

export enum IntSearchOperator {
  /** Equal To */
  Eq = 'EQ',
  Ge = 'GE',
  Gt = 'GT',
  Le = 'LE',
  Lt = 'LT',
  Ne = 'NE'
}


export type LinkoutData = {
  __typename: 'LinkoutData';
  currentValue: ModeratedField;
  diffValue: ModeratedFieldDiff;
  name: Scalars['String'];
  suggestedValue: ModeratedField;
};

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more Notification IDs. */
  ids: Array<Scalars['Int']>;
};

/** Autogenerated return type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadPayload = {
  __typename: 'MarkNotificationsAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of the notifications in their new state. */
  notifications: Array<Notification>;
};

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedField = ObjectField | ScalarField;

/** Fields that can have revisions can be either scalar values or complex objects */
export type ModeratedFieldDiff = ObjectFieldDiff | ScalarField;

export type ModeratedObjectField = {
  __typename: 'ModeratedObjectField';
  displayName: Scalars['String'];
  displayType: Scalars['String'];
  entityType: Scalars['String'];
  id: Scalars['Int'];
};

export type Mutation = {
  __typename: 'Mutation';
  /**
   * Accept a revision by ID. The accepting user must be an editor with a valid
   * conflict of interest statement on file and the revision must not be their own.
   */
  acceptRevision?: Maybe<AcceptRevisionPayload>;
  /** Add a comment to any commentable entity. */
  addComment?: Maybe<AddCommentPayload>;
  /**
   * Add a stub record for an external source that is not yet in CiVIC.
   * This is for adding a new Source inline while performing other curation activities
   * such as adding new evidence items and is distinct from suggesting a source for curation.
   */
  addRemoteCitation?: Maybe<AddRemoteCitationPayload>;
  /** Flag an entity to signal to the editorial team that you believe there is an issue with it. */
  flagEntity?: Maybe<FlagEntityPayload>;
  /** Mark one or more of your notifications as read. The notification IDs provided must belong to the requesting user. */
  markNotificationsAsRead?: Maybe<MarkNotificationsAsReadPayload>;
  /**
   * Reject a revision by ID. Any user may reject a Revision that they submitted
   * themselves. Otherwise, the rejecting user must be an editor with valid
   * conflict of interest statement on file.
   */
  rejectRevision?: Maybe<RejectRevisionPayload>;
  /**
   * Resolve a flag on a CIViC entity indicating that it was either erronously flagged or the issue has been resolved.
   * Any user may resolve their own flag however only editors with valid conflict
   * of interest statements can resolve other flags.
   */
  resolveFlag?: Maybe<ResolveFlagPayload>;
  /** Subscribe to a CIViC entity in order to receive notifications about it. */
  subscribe?: Maybe<SubscribePayload>;
  /** Suggest a Revision to an EvidenceItem entity. */
  suggestEvidenceItemRevision?: Maybe<SuggestEvidenceItemRevisionPayload>;
  /** Suggest a Revision to a Gene entity. */
  suggestGeneRevision?: Maybe<SuggestGeneRevisionPayload>;
  /** Suggest a Revision to a Variant entity. */
  suggestVariantRevision?: Maybe<SuggestVariantRevisionPayload>;
  /** Unsubscribe from a CIViC entity to stop receiving notifications about it. */
  unsubscribe?: Maybe<UnsubscribePayload>;
};


export type MutationAcceptRevisionArgs = {
  input: AcceptRevisionInput;
};


export type MutationAddCommentArgs = {
  input: AddCommentInput;
};


export type MutationAddRemoteCitationArgs = {
  input: AddRemoteCitationInput;
};


export type MutationFlagEntityArgs = {
  input: FlagEntityInput;
};


export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput;
};


export type MutationRejectRevisionArgs = {
  input: RejectRevisionInput;
};


export type MutationResolveFlagArgs = {
  input: ResolveFlagInput;
};


export type MutationSubscribeArgs = {
  input: SubscribeInput;
};


export type MutationSuggestEvidenceItemRevisionArgs = {
  input: SuggestEvidenceItemRevisionInput;
};


export type MutationSuggestGeneRevisionArgs = {
  input: SuggestGeneRevisionInput;
};


export type MutationSuggestVariantRevisionArgs = {
  input: SuggestVariantRevisionInput;
};


export type MutationUnsubscribeArgs = {
  input: UnsubscribeInput;
};

export type MyVariantInfo = {
  __typename: 'MyVariantInfo';
  caddConsequence: Array<Scalars['String']>;
  caddDetail: Array<Scalars['String']>;
  caddScore?: Maybe<Scalars['Float']>;
  clinvarClinicalSignificance: Array<Scalars['String']>;
  clinvarHgvsCoding: Array<Scalars['String']>;
  clinvarHgvsGenomic: Array<Scalars['String']>;
  clinvarHgvsNonCoding: Array<Scalars['String']>;
  clinvarHgvsProtein: Array<Scalars['String']>;
  clinvarId?: Maybe<Scalars['Int']>;
  clinvarOmim?: Maybe<Scalars['String']>;
  cosmicId?: Maybe<Scalars['String']>;
  dbnsfpInterproDomain: Array<Scalars['String']>;
  dbsnpRsid?: Maybe<Scalars['String']>;
  eglClass?: Maybe<Scalars['String']>;
  eglHgvs: Array<Scalars['String']>;
  eglProtein?: Maybe<Scalars['String']>;
  eglTranscript?: Maybe<Scalars['String']>;
  exacAlleleCount?: Maybe<Scalars['Int']>;
  exacAlleleFrequency?: Maybe<Scalars['Float']>;
  exacAlleleNumber?: Maybe<Scalars['Int']>;
  fathmmMklPrediction?: Maybe<Scalars['String']>;
  fathmmMklScore?: Maybe<Scalars['Float']>;
  fathmmPrediction: Array<Scalars['String']>;
  fathmmScore: Array<Scalars['Float']>;
  fitconsScore?: Maybe<Scalars['Float']>;
  gerp?: Maybe<Scalars['Float']>;
  gnomadExomeAlleleCount?: Maybe<Scalars['Int']>;
  gnomadExomeAlleleFrequency?: Maybe<Scalars['Float']>;
  gnomadExomeAlleleNumber?: Maybe<Scalars['Int']>;
  gnomadExomeFilter?: Maybe<Scalars['String']>;
  gnomadGenomeAlleleCount?: Maybe<Scalars['Int']>;
  gnomadGenomeAlleleFrequency?: Maybe<Scalars['Float']>;
  gnomadGenomeAlleleNumber?: Maybe<Scalars['Int']>;
  gnomadGenomeFilter?: Maybe<Scalars['String']>;
  lrtPrediction?: Maybe<Scalars['String']>;
  lrtScore?: Maybe<Scalars['Float']>;
  metalrPrediction?: Maybe<Scalars['String']>;
  metalrScore?: Maybe<Scalars['Float']>;
  metasvmPrediction?: Maybe<Scalars['String']>;
  metasvmScore?: Maybe<Scalars['Float']>;
  mutationassessorPrediction: Array<Scalars['String']>;
  mutationassessorScore: Array<Scalars['Float']>;
  mutationtasterPrediction: Array<Scalars['String']>;
  mutationtasterScore: Array<Scalars['Float']>;
  myVariantInfoId: Scalars['String'];
  phastcons100way?: Maybe<Scalars['Float']>;
  phastcons30way?: Maybe<Scalars['Float']>;
  phyloP100way?: Maybe<Scalars['Float']>;
  phyloP30way?: Maybe<Scalars['Float']>;
  polyphen2HdivPrediction: Array<Scalars['String']>;
  polyphen2HdivScore: Array<Scalars['Float']>;
  polyphen2HvarPrediction: Array<Scalars['String']>;
  polyphen2HvarScore: Array<Scalars['Float']>;
  proveanPrediction: Array<Scalars['String']>;
  proveanScore: Array<Scalars['Float']>;
  revelScore?: Maybe<Scalars['Float']>;
  siftPrediction: Array<Scalars['String']>;
  siftScore: Array<Scalars['Float']>;
  siphy?: Maybe<Scalars['Float']>;
  snpeffSnpEffect: Array<Scalars['String']>;
  snpeffSnpImpact: Array<Scalars['String']>;
};

export type Notification = {
  __typename: 'Notification';
  createdAt: Scalars['ISO8601DateTime'];
  event: Event;
  id: Scalars['Int'];
  notifiedUser: User;
  originatingUser: User;
  seen: Scalars['Boolean'];
  subscription?: Maybe<Subscription>;
  type: NotificationReason;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename: 'NotificationConnection';
  /** A list of edges. */
  edges: Array<NotificationEdge>;
  /** A list of nodes. */
  nodes: Array<Notification>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

export enum NotificationReason {
  Mention = 'MENTION',
  Subscription = 'SUBSCRIPTION'
}

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableDrugInteractionTypeInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<DrugInteraction>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableIntInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<Scalars['Int']>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableReferenceBuildTypeInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<ReferenceBuild>;
};

/**
 * An input object that represents a field value that can be "unset" or changed to null.
 * To change the field's value to null, pass unset as true, otherwise pass in the desired value as value.
 * This is to work around two issues with the GraphQL spec: lack of support for unions in input types
 * and the inability to have an input object argument be both required _and_ nullable at the same time.
 */
export type NullableStringInput = {
  /** Set to true if you wish to set the field's value to null. */
  unset?: Maybe<Scalars['Boolean']>;
  /** The desired value for the field. Mutually exclusive with unset. */
  value?: Maybe<Scalars['String']>;
};

export type ObjectField = {
  __typename: 'ObjectField';
  objects: Array<ModeratedObjectField>;
};

export type ObjectFieldDiff = {
  __typename: 'ObjectFieldDiff';
  addedObjects: Array<ModeratedObjectField>;
  keptObjects: Array<ModeratedObjectField>;
  removedObjects: Array<ModeratedObjectField>;
};

export type Organization = {
  __typename: 'Organization';
  description: Scalars['String'];
  eventCount: Scalars['Int'];
  events: EventConnection;
  id: Scalars['Int'];
  memberCount: Scalars['Int'];
  members: UserConnection;
  mostRecentEvent?: Maybe<Event>;
  name: Scalars['String'];
  orgAndSuborgsStatsHash: Stats;
  orgStatsHash: Stats;
  profileImagePath?: Maybe<Scalars['String']>;
  subGroups: Array<Organization>;
  url: Scalars['String'];
};


export type OrganizationEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type OrganizationMembersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type OrganizationProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** The connection type for Organization. */
export type OrganizationConnection = {
  __typename: 'OrganizationConnection';
  /** A list of edges. */
  edges: Array<OrganizationEdge>;
  /** A list of nodes. */
  nodes: Array<Organization>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename: 'OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Organization>;
};

/** Filter on organization id and whether or not to include the organization's subgroups */
export type OrganizationFilter = {
  /** The organization ID. */
  id: Scalars['Int'];
  /** Whether or not to include the organization's subgroup. */
  includeSubgroups?: Maybe<Scalars['Boolean']>;
};

export type OrganizationSort = {
  /** Available columns for sorting */
  column: OrganizationSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum OrganizationSortColumns {
  Id = 'ID',
  Name = 'NAME'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Phenotype = {
  __typename: 'Phenotype';
  hpoId: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  url: Scalars['String'];
};

export type PhenotypeSort = {
  /** Available columns for sorting */
  column: PhenotypeSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum PhenotypeSortColumns {
  AssertionCount = 'ASSERTION_COUNT',
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  HpoId = 'HPO_ID',
  Name = 'NAME'
}

export type Query = {
  __typename: 'Query';
  /** Find an assertion by CIViC ID */
  assertion?: Maybe<Assertion>;
  /** List and filter assertions. */
  assertions: AssertionConnection;
  browseDiseases: BrowseDiseaseConnection;
  browseGenes: BrowseGeneConnection;
  browseSources: BrowseSourceConnection;
  browseVariantGroups: BrowseVariantGroupConnection;
  browseVariants: BrowseVariantConnection;
  /** Find a clinical trial by CIViC ID */
  clinicalTrial?: Maybe<ClinicalTrial>;
  /** List and filter Clinical Trials from ClinicalTrials.gov. */
  clinicalTrials: BrowseClinicalTrialConnection;
  /** Find a comment by CIViC ID */
  comment?: Maybe<Comment>;
  /** List and filter comments. */
  comments: CommentConnection;
  contributors: ContributingUsersSummary;
  /** Find a disease by CIViC ID */
  disease?: Maybe<Disease>;
  /** Find a drug by CIViC ID */
  drug?: Maybe<Drug>;
  /** List and filter Drugs from the NCI Thesaurus. */
  drugs: BrowseDrugConnection;
  /** List and filter events for an object */
  events: EventConnection;
  /** Find an evidence item by CIViC ID */
  evidenceItem?: Maybe<EvidenceItem>;
  /** List and filter evidence items. */
  evidenceItems: EvidenceItemConnection;
  /** Find a flag by CIViC ID */
  flag?: Maybe<Flag>;
  /** List and filter flags. */
  flags: FlagConnection;
  /** Find a gene by CIViC ID */
  gene?: Maybe<Gene>;
  /** Find an organization by CIViC ID */
  organization?: Maybe<Organization>;
  /** List and filter organizations. */
  organizations: OrganizationConnection;
  /** Find a phenotype by CIViC ID */
  phenotype?: Maybe<Phenotype>;
  /** List and filter Phenotypes from the Human Phenotype Ontology. */
  phenotypes: BrowsePhenotypeConnection;
  /** Check to see if a citation ID for a source not already in CIViC exists in an external database. */
  remoteCitation?: Maybe<Scalars['String']>;
  /** Find a revision by CIViC ID */
  revision?: Maybe<Revision>;
  search: Array<SearchResult>;
  searchByPermalink: AdvancedSearchResult;
  searchGenes: AdvancedSearchResult;
  /** Find a source by CIViC ID */
  source?: Maybe<Source>;
  /** Provide suggestions for sources based on a partial citation ID */
  sourceTypeahead: Array<Source>;
  user?: Maybe<User>;
  /** List and filter users. */
  users: UserConnection;
  /** Find a variant by CIViC ID */
  variant?: Maybe<Variant>;
  /** Find a variant group by CIViC ID */
  variantGroup?: Maybe<VariantGroup>;
  /** Find a variant type by CIViC ID */
  variantType?: Maybe<VariantType>;
  /** List and filter Variant Types from the Sequence Ontology. */
  variantTypes: BrowseVariantTypeConnection;
  /** List and filter variants. */
  variants: VariantConnection;
  viewer?: Maybe<User>;
};


export type QueryAssertionArgs = {
  id: Scalars['Int'];
};


export type QueryAssertionsArgs = {
  after?: Maybe<Scalars['String']>;
  ampLevel?: Maybe<AmpLevel>;
  assertionDirection?: Maybe<EvidenceDirection>;
  assertionType?: Maybe<EvidenceType>;
  before?: Maybe<Scalars['String']>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  diseaseId?: Maybe<Scalars['Int']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugId?: Maybe<Scalars['Int']>;
  drugName?: Maybe<Scalars['String']>;
  evidenceId?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  geneName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  phenotypeId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<AssertionSort>;
  summary?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
  variantId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
};


export type QueryBrowseDiseasesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  doid?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneNames?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DiseasesSort>;
};


export type QueryBrowseGenesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneAlias?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<GenesSort>;
};


export type QueryBrowseSourcesArgs = {
  after?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  citationId?: Maybe<Scalars['Int']>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  journal?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<SourcesSort>;
  sourceType?: Maybe<SourceSource>;
  year?: Maybe<Scalars['Int']>;
};


export type QueryBrowseVariantGroupsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  geneNames?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantGroupsSort>;
  variantNames?: Maybe<Scalars['String']>;
};


export type QueryBrowseVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<VariantsSort>;
  variantName?: Maybe<Scalars['String']>;
  variantTypeId?: Maybe<Scalars['Int']>;
};


export type QueryClinicalTrialArgs = {
  id: Scalars['Int'];
};


export type QueryClinicalTrialsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  nctId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<ClinicalTrialSort>;
};


export type QueryCommentArgs = {
  id: Scalars['Int'];
};


export type QueryCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  subject?: Maybe<CommentableInput>;
};


export type QueryContributorsArgs = {
  subscribable: SubscribableInput;
};


export type QueryDiseaseArgs = {
  id: Scalars['Int'];
};


export type QueryDrugArgs = {
  id: Scalars['Int'];
};


export type QueryDrugsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  ncitId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DrugSort>;
};


export type QueryEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  subject?: Maybe<SubscribableQueryInput>;
};


export type QueryEvidenceItemArgs = {
  id: Scalars['Int'];
};


export type QueryEvidenceItemsArgs = {
  after?: Maybe<Scalars['String']>;
  assertionId?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  diseaseId?: Maybe<Scalars['Int']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugId?: Maybe<Scalars['Int']>;
  drugName?: Maybe<Scalars['String']>;
  evidenceDirection?: Maybe<EvidenceDirection>;
  evidenceLevel?: Maybe<EvidenceLevel>;
  evidenceRating?: Maybe<Scalars['Int']>;
  evidenceType?: Maybe<EvidenceType>;
  first?: Maybe<Scalars['Int']>;
  geneSymbol?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  phenotypeId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<EvidenceSort>;
  sourceId?: Maybe<Scalars['Int']>;
  status?: Maybe<EvidenceStatus>;
  userId?: Maybe<Scalars['Int']>;
  variantId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
  variantOrigin?: Maybe<VariantOrigin>;
};


export type QueryFlagArgs = {
  id: Scalars['Int'];
};


export type QueryFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggable?: Maybe<FlaggableInput>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type QueryGeneArgs = {
  id: Scalars['Int'];
};


export type QueryOrganizationArgs = {
  id: Scalars['Int'];
};


export type QueryOrganizationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<OrganizationSort>;
};


export type QueryPhenotypeArgs = {
  id: Scalars['Int'];
};


export type QueryPhenotypesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  hpoId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sortBy?: Maybe<PhenotypeSort>;
};


export type QueryRemoteCitationArgs = {
  citationId: Scalars['Int'];
  sourceType: SourceSource;
};


export type QueryRevisionArgs = {
  id: Scalars['Int'];
};


export type QuerySearchArgs = {
  query: Scalars['String'];
};


export type QuerySearchByPermalinkArgs = {
  permalinkId: Scalars['String'];
};


export type QuerySearchGenesArgs = {
  createPermalink?: Maybe<Scalars['Boolean']>;
  query: GeneSearchFilter;
};


export type QuerySourceArgs = {
  id: Scalars['Int'];
};


export type QuerySourceTypeaheadArgs = {
  citationId: Scalars['Int'];
  sourceType: SourceSource;
};


export type QueryUserArgs = {
  id: Scalars['Int'];
};


export type QueryUsersArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organization?: Maybe<OrganizationFilter>;
};


export type QueryVariantArgs = {
  id: Scalars['Int'];
};


export type QueryVariantGroupArgs = {
  id: Scalars['Int'];
};


export type QueryVariantTypeArgs = {
  id: Scalars['Int'];
};


export type QueryVariantTypesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  soid?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantTypeSort>;
};


export type QueryVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  geneId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

export enum ReferenceBuild {
  Grch37 = 'GRCH37',
  Grch38 = 'GRCH38',
  Ncbi36 = 'NCBI36'
}

/** Autogenerated input type of RejectRevision */
export type RejectRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text explaining the reasoning for rejecting this Revision. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the Revision to reject. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of RejectRevision */
export type RejectRevisionPayload = {
  __typename: 'RejectRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The rejected Revision. */
  revision: Revision;
};

/** Autogenerated input type of ResolveFlag */
export type ResolveFlagInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for resolving the flag. Will be attached as a comment. */
  comment: Scalars['String'];
  /** The ID of the flag to resolve. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of ResolveFlag */
export type ResolveFlagPayload = {
  __typename: 'ResolveFlagPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  flag?: Maybe<Flag>;
};

export type Revision = EventOriginObject & EventSubject & {
  __typename: 'Revision';
  comments: Array<Comment>;
  createdAt: Scalars['ISO8601DateTime'];
  creationEvent?: Maybe<Event>;
  currentValue?: Maybe<Scalars['JSON']>;
  /** List and filter events for an object */
  events: EventConnection;
  fieldName: Scalars['String'];
  id: Scalars['Int'];
  linkoutData: LinkoutData;
  name: Scalars['String'];
  revisionsetId: Scalars['String'];
  revisor: User;
  status: RevisionStatus;
  suggestedValue?: Maybe<Scalars['JSON']>;
  updatedAt: Scalars['ISO8601DateTime'];
};


export type RevisionEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

/** The connection type for Revision. */
export type RevisionConnection = {
  __typename: 'RevisionConnection';
  /** A list of edges. */
  edges: Array<RevisionEdge>;
  /** A list of nodes. */
  nodes: Array<Revision>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** List of all fields that have at least one revision. */
  revisedFieldNames: Array<FieldName>;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
  /** List of all users that have submitted a revision to this entity. */
  uniqueRevisors: Array<User>;
};

/** An edge in a connection. */
export type RevisionEdge = {
  __typename: 'RevisionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Revision>;
};

export type RevisionResult = {
  __typename: 'RevisionResult';
  /** Name of the field on the moderated entity that the Revision pertains to. */
  fieldName: Scalars['String'];
  /** ID of the Revision. */
  id: Scalars['Int'];
  /** Was this Revision newly created as a result of this request? */
  newlyCreated: Scalars['Boolean'];
  /** An identifier that can be used to group Revisions proposed at the same time. */
  revisionsetId: Scalars['String'];
};

export enum RevisionStatus {
  Accepted = 'ACCEPTED',
  New = 'NEW',
  Rejected = 'REJECTED',
  Superseded = 'SUPERSEDED'
}

export type ScalarField = {
  __typename: 'ScalarField';
  value?: Maybe<Scalars['String']>;
};

export type SearchResult = {
  __typename: 'SearchResult';
  id: Scalars['Int'];
  matchingText: Scalars['String'];
  name: Scalars['String'];
  resultType: SearchableEntities;
};

export enum SearchableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

export enum SortDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

export type Source = EventSubject & {
  __typename: 'Source';
  abstract?: Maybe<Scalars['String']>;
  ascoAbstractId?: Maybe<Scalars['Int']>;
  authorString?: Maybe<Scalars['String']>;
  citation: Scalars['String'];
  citationId: Scalars['Int'];
  clinicalTrials?: Maybe<Array<ClinicalTrial>>;
  displayType: Scalars['String'];
  /** List and filter events for an object */
  events: EventConnection;
  fullJournalTitle?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  journal: Scalars['String'];
  name: Scalars['String'];
  pmcId?: Maybe<Scalars['String']>;
  publicationDate?: Maybe<Scalars['String']>;
  publicationDay?: Maybe<Scalars['Int']>;
  publicationMonth: Scalars['Int'];
  publicationYear: Scalars['Int'];
  sourceType: SourceSource;
  sourceUrl: Scalars['String'];
  status: SourceStatus;
  title?: Maybe<Scalars['String']>;
};


export type SourceEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};

export enum SourceSource {
  Asco = 'ASCO',
  Pubmed = 'PUBMED'
}

export enum SourceStatus {
  FullyCurated = 'FullyCurated',
  PartiallyCurated = 'PartiallyCurated',
  Submitted = 'Submitted'
}

export type SourceStub = {
  __typename: 'SourceStub';
  citationId: Scalars['Int'];
  id: Scalars['Int'];
  sourceType: SourceSource;
};

export type SourcesSort = {
  /** Available columns for sorting */
  column: SourcesSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum SourcesSortColumns {
  Authors = 'AUTHORS',
  CitationId = 'CITATION_ID',
  EvidenceCount = 'EVIDENCE_COUNT',
  Journal = 'JOURNAL',
  Name = 'NAME',
  SourceType = 'SOURCE_TYPE',
  Year = 'YEAR'
}

export type Stats = {
  __typename: 'Stats';
  acceptedAssertions: Scalars['Int'];
  acceptedEvidenceItems: Scalars['Int'];
  appliedRevisions: Scalars['Int'];
  comments: Scalars['Int'];
  revisions: Scalars['Int'];
  submittedAssertions: Scalars['Int'];
  submittedEvidenceItems: Scalars['Int'];
  suggestedSources: Scalars['Int'];
};

export type StringSearchInput = {
  comparisonOperator: StringSearchOperator;
  value: Scalars['String'];
};

export enum StringSearchOperator {
  Contains = 'CONTAINS',
  DoesNotContain = 'DOES_NOT_CONTAIN',
  Eq = 'EQ',
  Ne = 'NE',
  StartsWith = 'STARTS_WITH'
}

export type Subscribable = {
  __typename: 'Subscribable';
  entityType: SubscribableEntities;
  id: Scalars['Int'];
};

/** Enumeration of all subscribable CIViC entities. */
export enum SubscribableEntities {
  Assertion = 'ASSERTION',
  EvidenceItem = 'EVIDENCE_ITEM',
  Gene = 'GENE',
  Revision = 'REVISION',
  Variant = 'VARIANT',
  VariantGroup = 'VARIANT_GROUP'
}

/** Entity to subscribe to. */
export type SubscribableInput = {
  /** Type of subscribable entity. */
  entityType: SubscribableEntities;
  /** ID of subscribable entity. */
  id: Scalars['Int'];
};

/** Entity to subscribe to. */
export type SubscribableQueryInput = {
  /** Type of subscribable entity. */
  entityType: SubscribableEntities;
  /** ID of subscribable entity. */
  id: Scalars['Int'];
  /** Include child entities of the requested subscribable */
  includeChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of Subscribe */
export type SubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to subscribe to, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you want to subscribe to related child entities of the subscribed entities?
   * IE: If you subscribe to a Gene, do you want to receive notifications for its Variants as well?
   */
  subscribeToChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Subscribe */
export type SubscribePayload = {
  __typename: 'SubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created subscription objects. */
  subscriptions: Array<Subscription>;
};

export type Subscription = {
  __typename: 'Subscription';
  id: Scalars['Int'];
};

/** Autogenerated input type of SuggestEvidenceItemRevision */
export type SuggestEvidenceItemRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the EvidenceItems's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: EvidenceItemFields;
  /** The ID of the EvidenceItem to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestEvidenceItemRevision */
export type SuggestEvidenceItemRevisionPayload = {
  __typename: 'SuggestEvidenceItemRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The EvidenceItem the user has proposed a Revision to. */
  evidenceItem: EvidenceItem;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of SuggestGeneRevision */
export type SuggestGeneRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Gene's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: GeneFields;
  /** The ID of the Gene to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestGeneRevision */
export type SuggestGeneRevisionPayload = {
  __typename: 'SuggestGeneRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Gene the user has proposed a Revision to. */
  gene: Gene;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
};

/** Autogenerated input type of SuggestVariantRevision */
export type SuggestVariantRevisionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Text describing the reason for the change. Will be attached to the Revision as a comment. */
  comment: Scalars['String'];
  /**
   * The desired state of the Variant's editable fields if the change were applied.
   * If no change is desired for a particular field, pass in the current value of that field.
   */
  fields: VariantFields;
  /** The ID of the Variant to suggest a Revision to. */
  id: Scalars['Int'];
  /**
   * The ID of the organization to credit the user's contributions to.
   * If the user belongs to a single organization or no organizations, this field is not required.
   * This field is required if the user belongs to more than one organization.
   * The user must belong to the organization provided.
   */
  organizationId?: Maybe<Scalars['Int']>;
};

/** Autogenerated return type of SuggestVariantRevision */
export type SuggestVariantRevisionPayload = {
  __typename: 'SuggestVariantRevisionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /**
   * A list of Revisions generated as a result of this suggestion.
   * If an existing Revision exactly matches the proposed one, it will be returned instead.
   * This is indicated via the 'newlyCreated' Boolean.
   * Revisions are stored on a per-field basis.
   * The changesetId can be used to group Revisions proposed at the same time.
   */
  results: Array<RevisionResult>;
  /** The Variant the user has proposed a Revision to. */
  variant: Variant;
};

/** Autogenerated input type of Unsubscribe */
export type UnsubscribeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A list of one or more entities to unsubscribe from, each identified by its ID and type. */
  subscribables: Array<SubscribableInput>;
  /**
   * Do you also wish to stop receiving notifications from child entities?
   * IE: If you unsubscribe from a Gene do you want to stop receiving notifications for its Variants as well?
   */
  unsubscribeFromChildren?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated return type of Unsubscribe */
export type UnsubscribePayload = {
  __typename: 'UnsubscribePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The entities that were unsubscribed from. */
  unsubscribedEntities: Array<Subscribable>;
};

export type User = {
  __typename: 'User';
  areaOfExpertise?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  displayName: Scalars['String'];
  email?: Maybe<Scalars['String']>;
  events: EventConnection;
  facebookProfile?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  linkedinProfile?: Maybe<Scalars['String']>;
  mostRecentConflictOfInterestStatement?: Maybe<Coi>;
  name: Scalars['String'];
  /** Filterable list of notifications for the logged in user. */
  notifications?: Maybe<NotificationConnection>;
  orcid?: Maybe<Scalars['String']>;
  organizations: Array<Organization>;
  profileImagePath?: Maybe<Scalars['String']>;
  role: Scalars['String'];
  statsHash: Stats;
  twitterHandle?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};


export type UserEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type UserNotificationsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  includeSeen?: Maybe<Scalars['Boolean']>;
  last?: Maybe<Scalars['Int']>;
  notificationType?: Maybe<NotificationReason>;
  subscriptionId?: Maybe<Scalars['Int']>;
};


export type UserProfileImagePathArgs = {
  size?: Maybe<Scalars['Int']>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename: 'UserConnection';
  /** A list of edges. */
  edges: Array<UserEdge>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

export type Variant = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'Variant';
  alleleRegistryId?: Maybe<Scalars['String']>;
  clinvarIds?: Maybe<Array<Scalars['String']>>;
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  ensemblVersion?: Maybe<Scalars['Int']>;
  /** List and filter events for an object */
  events: EventConnection;
  evidenceItems: EvidenceItemConnection;
  evidenceScore: Scalars['Float'];
  fivePrimeCoordinates?: Maybe<Coordinate>;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  gene: Gene;
  hgvsDescriptions?: Maybe<Array<Scalars['String']>>;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  myVariantInfo?: Maybe<MyVariantInfo>;
  name: Scalars['String'];
  referenceBuild?: Maybe<ReferenceBuild>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
  sources: Array<Source>;
  threePrimeCoordinates?: Maybe<Coordinate>;
  variantAliases?: Maybe<Array<Scalars['String']>>;
  variantTypes?: Maybe<Array<VariantType>>;
};


export type VariantCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantEvidenceItemsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type VariantFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type VariantRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

/** The connection type for Variant. */
export type VariantConnection = {
  __typename: 'VariantConnection';
  /** A list of edges. */
  edges: Array<VariantEdge>;
  /** A list of nodes. */
  nodes: Array<Variant>;
  /** Total number of pages, based on filtered count and pagesize. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of records in this filtered collection. */
  totalCount: Scalars['Int'];
};

export enum VariantDisplayFilter {
  /** Display all variants regardless of attached evience. */
  All = 'ALL',
  /** Display only variants which have at least one accepted evidence item. */
  WithAccepted = 'WITH_ACCEPTED',
  /** Display only variants which have evidence in either an accepted or submitted state. */
  WithAcceptedOrSubmitted = 'WITH_ACCEPTED_OR_SUBMITTED',
  /** Display variants which have at least one submited evidence item. */
  WithSubmitted = 'WITH_SUBMITTED'
}

/** An edge in a connection. */
export type VariantEdge = {
  __typename: 'VariantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Variant>;
};

/** Fields on a Variant that curators may propose revisions to. */
export type VariantFields = {
  /** List of aliases or alternate names for the Variant. */
  aliases: Array<Scalars['String']>;
  /** List of ClinVar IDs for the Variant. */
  clinvarIds: ClinvarInput;
  /** The Variant's description/summary text. */
  description: NullableStringInput;
  /** The Ensembl database version. */
  ensemblVersion: Scalars['Int'];
  /** The ID of the Gene this Variant corresponds to. */
  geneId: Scalars['Int'];
  /** List of HGVS descriptions for the Variant. */
  hgvsDescriptions: Array<Scalars['String']>;
  /** The Variant's name. */
  name: Scalars['String'];
  /** The primary coordinates for this Variant. In the case of Fusions this will be the coordinates of the 5' partner. */
  primaryCoordinates: CoordinateInput;
  /** Reference bases for this variant */
  referenceBases: NullableStringInput;
  /** The reference build for the genomic coordinates of this Variant. */
  referenceBuild: NullableReferenceBuildTypeInput;
  /** In the case of Fusions these will be the coordinates of the 3' partner, otherwise set the values to null. */
  secondaryCoordinates: CoordinateInput;
  /** Source IDs cited by the Variant's summary. */
  sourceIds: Array<Scalars['Int']>;
  /** Variant bases for this variant */
  variantBases: NullableStringInput;
  /** List of IDs for the variant types for this Variant */
  variantTypeIds: Array<Scalars['Int']>;
};

export type VariantGroup = Commentable & EventSubject & Flaggable & WithRevisions & {
  __typename: 'VariantGroup';
  /** List and filter comments. */
  comments: CommentConnection;
  description: Scalars['String'];
  /** List and filter events for an object */
  events: EventConnection;
  flagged: Scalars['Boolean'];
  /** List and filter flags. */
  flags: FlagConnection;
  id: Scalars['Int'];
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastCommentEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  name: Scalars['String'];
  /** List and filter revisions. */
  revisions: RevisionConnection;
  /** List and filter variants. */
  variants: VariantConnection;
};


export type VariantGroupCommentsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantGroupEventsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  eventType?: Maybe<EventAction>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
};


export type VariantGroupFlagsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<DateSort>;
  state?: Maybe<FlagState>;
};


export type VariantGroupRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};


export type VariantGroupVariantsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
};

export type VariantGroupsSort = {
  /** Available columns for sorting */
  column: VariantGroupsSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum VariantGroupsSortColumns {
  EvidenceItemCount = 'EVIDENCE_ITEM_COUNT',
  GeneNames = 'GENE_NAMES',
  Name = 'NAME',
  VariantCount = 'VARIANT_COUNT',
  VariantNames = 'VARIANT_NAMES'
}

export enum VariantOrigin {
  CommonGermline = 'COMMON_GERMLINE',
  GermlineOrSomatic = 'GERMLINE_OR_SOMATIC',
  Na = 'NA',
  RareGermline = 'RARE_GERMLINE',
  Somatic = 'SOMATIC',
  Unknown = 'UNKNOWN'
}

export type VariantType = {
  __typename: 'VariantType';
  description: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  soid: Scalars['String'];
  url: Scalars['String'];
};

export type VariantTypeSort = {
  /** Available columns for sorting */
  column: VariantTypeSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum VariantTypeSortColumns {
  Name = 'NAME',
  Soid = 'SOID',
  VariantCount = 'VARIANT_COUNT'
}

export type VariantsSort = {
  /** Available columns for sorting */
  column: VariantsSortColumns;
  /** Sort direction */
  direction: SortDirection;
};

export enum VariantsSortColumns {
  AssertionCount = 'assertionCount',
  DiseaseName = 'diseaseName',
  DrugName = 'drugName',
  EntrezSymbol = 'entrezSymbol',
  EvidenceItemCount = 'evidenceItemCount',
  EvidenceScore = 'evidenceScore',
  VariantName = 'variantName'
}

/** A CIViC entity that can have revisions proposed to it. */
export type WithRevisions = {
  lastAcceptedRevisionEvent?: Maybe<Event>;
  lastSubmittedRevisionEvent?: Maybe<Event>;
  /** List and filter revisions. */
  revisions: RevisionConnection;
};


/** A CIViC entity that can have revisions proposed to it. */
export type WithRevisionsRevisionsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  revisionsetId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DateSort>;
  status?: Maybe<RevisionStatus>;
};

export type AssertionPopoverQueryVariables = Exact<{
  assertionId: Scalars['Int'];
}>;


export type AssertionPopoverQuery = (
  { __typename: 'Query' }
  & { assertion?: Maybe<(
    { __typename: 'Assertion' }
    & AssertionPopoverFragment
  )> }
);

export type AssertionPopoverFragment = (
  { __typename: 'Assertion' }
  & Pick<Assertion, 'id' | 'name' | 'summary' | 'assertionType' | 'assertionDirection' | 'clinicalSignificance' | 'variantOrigin' | 'ampLevel' | 'nccnGuideline' | 'fdaCompanionTest' | 'regulatoryApproval' | 'drugInteractionType'>
  & { acmgCodes: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'code'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type AssertionsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  summary?: Maybe<Scalars['String']>;
  assertionDirection?: Maybe<EvidenceDirection>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  assertionType?: Maybe<EvidenceType>;
  variantId?: Maybe<Scalars['Int']>;
  evidenceId?: Maybe<Scalars['Int']>;
  geneName?: Maybe<Scalars['String']>;
  variantName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<AssertionSort>;
  ampLevel?: Maybe<AmpLevel>;
  organizationId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  phenotypeId?: Maybe<Scalars['Int']>;
  diseaseId?: Maybe<Scalars['Int']>;
  drugId?: Maybe<Scalars['Int']>;
  cardView: Scalars['Boolean'];
}>;


export type AssertionsBrowseQuery = (
  { __typename: 'Query' }
  & { assertions: (
    { __typename: 'AssertionConnection' }
    & Pick<AssertionConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'AssertionEdge' }
      & Pick<AssertionEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Assertion' }
        & AssertionBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type AssertionBrowseTableRowFieldsFragment = (
  { __typename: 'Assertion' }
  & MakeOptional<Pick<Assertion, 'id' | 'name' | 'drugInteractionType' | 'summary' | 'assertionType' | 'assertionDirection' | 'clinicalSignificance' | 'ampLevel' | 'fdaCompanionTest' | 'regulatoryApproval' | 'nccnGuideline' | 'variantOrigin'>, 'fdaCompanionTest' | 'regulatoryApproval' | 'nccnGuideline' | 'variantOrigin'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, acmgCodes: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'code'>
  )> }
);

export type ClinicalTrialPopoverQueryVariables = Exact<{
  clinicalTrialId: Scalars['Int'];
}>;


export type ClinicalTrialPopoverQuery = (
  { __typename: 'Query' }
  & { clinicalTrials: (
    { __typename: 'BrowseClinicalTrialConnection' }
    & { edges: Array<(
      { __typename: 'BrowseClinicalTrialEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowseClinicalTrial' }
        & ClinicalTrialPopoverFragment
      )> }
    )> }
  ) }
);

export type ClinicalTrialPopoverFragment = (
  { __typename: 'BrowseClinicalTrial' }
  & Pick<BrowseClinicalTrial, 'id' | 'name' | 'nctId' | 'url' | 'sourceCount' | 'evidenceCount'>
);

export type ClinicalTrialsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nctId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<ClinicalTrialSort>;
}>;


export type ClinicalTrialsBrowseQuery = (
  { __typename: 'Query' }
  & { clinicalTrials: (
    { __typename: 'BrowseClinicalTrialConnection' }
    & Pick<BrowseClinicalTrialConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowseClinicalTrialEdge' }
      & Pick<BrowseClinicalTrialEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseClinicalTrial' }
        & Pick<BrowseClinicalTrial, 'id' | 'name' | 'nctId' | 'evidenceCount' | 'sourceCount'>
      )> }
    )> }
  ) }
);

export type CommentListQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  subject?: Maybe<CommentableInput>;
  sortBy?: Maybe<DateSort>;
}>;


export type CommentListQuery = (
  { __typename: 'Query' }
  & { comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ), uniqueCommenters: Array<(
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    )>, edges: Array<(
      { __typename: 'CommentEdge' }
      & Pick<CommentEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Comment' }
        & CommentListNodeFragment
      )> }
    )> }
  ) }
);

export type CommentListNodeFragment = (
  { __typename: 'Comment' }
  & Pick<Comment, 'id' | 'title' | 'comment' | 'createdAt'>
  & { commenter: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'displayName' | 'name' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )> }
  ) }
);

export type CommentPopoverQueryVariables = Exact<{
  commentId: Scalars['Int'];
}>;


export type CommentPopoverQuery = (
  { __typename: 'Query' }
  & { comment?: Maybe<(
    { __typename: 'Comment' }
    & CommentPopoverFragment
  )> }
);

export type CommentPopoverFragment = (
  { __typename: 'Comment' }
  & Pick<Comment, 'id' | 'name' | 'createdAt' | 'title' | 'comment'>
  & { commenter: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  ), commentable: (
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'name'>
  ) | (
    { __typename: 'Flag' }
    & Pick<Flag, 'id' | 'name'>
  ) | (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ) | (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ) | (
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'id' | 'name'>
  ) }
);

export type DiseasePopoverQueryVariables = Exact<{
  diseaseId: Scalars['Int'];
}>;


export type DiseasePopoverQuery = (
  { __typename: 'Query' }
  & { browseDiseases: (
    { __typename: 'BrowseDiseaseConnection' }
    & { edges: Array<(
      { __typename: 'BrowseDiseaseEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowseDisease' }
        & DiseasePopoverFragment
      )> }
    )> }
  ) }
);

export type DiseasePopoverFragment = (
  { __typename: 'BrowseDisease' }
  & Pick<BrowseDisease, 'id' | 'name' | 'doid' | 'diseaseUrl' | 'assertionCount' | 'evidenceItemCount' | 'variantCount'>
);

export type BrowseDiseasesQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DiseasesSort>;
  name?: Maybe<Scalars['String']>;
  doid?: Maybe<Scalars['String']>;
  geneNames?: Maybe<Scalars['String']>;
}>;


export type BrowseDiseasesQuery = (
  { __typename: 'Query' }
  & { browseDiseases: (
    { __typename: 'BrowseDiseaseConnection' }
    & Pick<BrowseDiseaseConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'hasPreviousPage' | 'startCursor'>
    ), edges: Array<(
      { __typename: 'BrowseDiseaseEdge' }
      & Pick<BrowseDiseaseEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseDisease' }
        & BrowseDiseaseRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseDiseaseRowFieldsFragment = (
  { __typename: 'BrowseDisease' }
  & Pick<BrowseDisease, 'id' | 'name' | 'doid' | 'diseaseUrl' | 'geneNames' | 'assertionCount' | 'evidenceItemCount' | 'variantCount'>
);

export type DrugPopoverQueryVariables = Exact<{
  drugId: Scalars['Int'];
}>;


export type DrugPopoverQuery = (
  { __typename: 'Query' }
  & { drugs: (
    { __typename: 'BrowseDrugConnection' }
    & { edges: Array<(
      { __typename: 'BrowseDrugEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowseDrug' }
        & DrugPopoverFragment
      )> }
    )> }
  ) }
);

export type DrugPopoverFragment = (
  { __typename: 'BrowseDrug' }
  & Pick<BrowseDrug, 'id' | 'name' | 'drugUrl' | 'ncitId' | 'assertionCount' | 'evidenceCount'>
);

export type DrugsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  ncitId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<DrugSort>;
}>;


export type DrugsBrowseQuery = (
  { __typename: 'Query' }
  & { drugs: (
    { __typename: 'BrowseDrugConnection' }
    & Pick<BrowseDrugConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowseDrugEdge' }
      & Pick<BrowseDrugEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseDrug' }
        & DrugBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type DrugBrowseTableRowFieldsFragment = (
  { __typename: 'BrowseDrug' }
  & Pick<BrowseDrug, 'id' | 'name' | 'ncitId' | 'drugUrl' | 'assertionCount' | 'evidenceCount'>
);

export type EventFeedQueryVariables = Exact<{
  subject?: Maybe<SubscribableQueryInput>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  eventType?: Maybe<EventAction>;
}>;


export type EventFeedQuery = (
  { __typename: 'Query' }
  & { events: (
    { __typename: 'EventConnection' }
    & EventFeedFragment
  ) }
);

export type EventFeedFragment = (
  { __typename: 'EventConnection' }
  & Pick<EventConnection, 'eventTypes'>
  & { pageInfo: (
    { __typename: 'PageInfo' }
    & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
  ), uniqueParticipants: Array<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
  )>, participatingOrganizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, edges: Array<(
    { __typename: 'EventEdge' }
    & Pick<EventEdge, 'cursor'>
    & { node?: Maybe<(
      { __typename: 'Event' }
      & EventFeedNodeFragment
    )> }
  )> }
);

export type EventFeedNodeFragment = (
  { __typename: 'Event' }
  & Pick<Event, 'id' | 'action' | 'createdAt'>
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, originatingUser: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'displayName' | 'role' | 'profileImagePath'>
  ), subject: (
    { __typename: 'Assertion' }
    & Pick<Assertion, 'name' | 'id'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'name' | 'id'>
  ) | (
    { __typename: 'Gene' }
    & Pick<Gene, 'name' | 'id'>
  ) | (
    { __typename: 'Revision' }
    & Pick<Revision, 'name' | 'id'>
  ) | (
    { __typename: 'Source' }
    & Pick<Source, 'name' | 'id'>
  ) | (
    { __typename: 'Variant' }
    & Pick<Variant, 'name' | 'id'>
  ) | (
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'name' | 'id'>
  ), originatingObject?: Maybe<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  ) | (
    { __typename: 'Comment' }
    & Pick<Comment, 'id' | 'name'>
  ) | (
    { __typename: 'EvidenceItem' }
    & Pick<EvidenceItem, 'id' | 'name'>
  ) | (
    { __typename: 'Flag' }
    & Pick<Flag, 'id' | 'name'>
  ) | (
    { __typename: 'Revision' }
    & Pick<Revision, 'id' | 'name'>
  )> }
);

export type EvidencePopoverQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidencePopoverQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & EvidencePopoverFragment
  )> }
);

export type EvidencePopoverFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'description' | 'evidenceLevel' | 'evidenceType' | 'evidenceDirection' | 'clinicalSignificance' | 'variantOrigin' | 'drugInteractionType' | 'evidenceRating'>
  & { drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceType' | 'displayType'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type EvidenceBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  description?: Maybe<Scalars['String']>;
  evidenceLevel?: Maybe<EvidenceLevel>;
  evidenceDirection?: Maybe<EvidenceDirection>;
  clinicalSignificance?: Maybe<EvidenceClinicalSignificance>;
  evidenceType?: Maybe<EvidenceType>;
  rating?: Maybe<Scalars['Int']>;
  variantOrigin?: Maybe<VariantOrigin>;
  variantId?: Maybe<Scalars['Int']>;
  assertionId?: Maybe<Scalars['Int']>;
  organizationId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<EvidenceSort>;
  phenotypeId?: Maybe<Scalars['Int']>;
  diseaseId?: Maybe<Scalars['Int']>;
  drugId?: Maybe<Scalars['Int']>;
  sourceId?: Maybe<Scalars['Int']>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
  geneSymbol?: Maybe<Scalars['String']>;
  variantName?: Maybe<Scalars['String']>;
  cardView: Scalars['Boolean'];
}>;


export type EvidenceBrowseQuery = (
  { __typename: 'Query' }
  & { evidenceItems: (
    { __typename: 'EvidenceItemConnection' }
    & Pick<EvidenceItemConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'EvidenceItemEdge' }
      & Pick<EvidenceItemEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'EvidenceItem' }
        & EvidenceGridFieldsFragment
      )> }
    )> }
  ) }
);

export type EvidenceGridFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'status' | 'drugInteractionType' | 'description' | 'evidenceType' | 'evidenceDirection' | 'evidenceLevel' | 'evidenceRating' | 'clinicalSignificance' | 'variantOrigin'>
  & { disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'citationId' | 'sourceType' | 'sourceUrl'>
    & { clinicalTrials?: Maybe<Array<(
      { __typename: 'ClinicalTrial' }
      & Pick<ClinicalTrial, 'nctId' | 'id'>
    )>> }
  ), assertions: Array<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  )> }
);

export type FlagListQueryVariables = Exact<{
  flaggable?: Maybe<FlaggableInput>;
  flaggingUserId?: Maybe<Scalars['Int']>;
  resolvingUserId?: Maybe<Scalars['Int']>;
  state?: Maybe<FlagState>;
  sortBy?: Maybe<DateSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type FlagListQuery = (
  { __typename: 'Query' }
  & { flags: (
    { __typename: 'FlagConnection' }
    & FlagListFragment
  ) }
);

export type FlagListFragment = (
  { __typename: 'FlagConnection' }
  & { pageInfo: (
    { __typename: 'PageInfo' }
    & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasNextPage' | 'hasPreviousPage'>
  ), edges: Array<(
    { __typename: 'FlagEdge' }
    & { node?: Maybe<(
      { __typename: 'Flag' }
      & Pick<Flag, 'id' | 'state' | 'createdAt' | 'resolvedAt'>
      & { flaggable: (
        { __typename: 'Assertion' }
        & Pick<Assertion, 'id' | 'name'>
      ) | (
        { __typename: 'EvidenceItem' }
        & Pick<EvidenceItem, 'id' | 'name'>
      ) | (
        { __typename: 'Gene' }
        & Pick<Gene, 'id' | 'name'>
      ) | (
        { __typename: 'Variant' }
        & Pick<Variant, 'id' | 'name'>
      ) | (
        { __typename: 'VariantGroup' }
        & Pick<VariantGroup, 'id' | 'name'>
      ), flaggingUser: (
        { __typename: 'User' }
        & Pick<User, 'id' | 'displayName' | 'profileImagePath'>
      ), resolvingUser?: Maybe<(
        { __typename: 'User' }
        & Pick<User, 'id' | 'displayName' | 'profileImagePath'>
      )>, openComment: (
        { __typename: 'Comment' }
        & Pick<Comment, 'comment'>
      ), resolutionComment?: Maybe<(
        { __typename: 'Comment' }
        & Pick<Comment, 'comment'>
      )> }
    )> }
  )> }
);

export type BrowseGenesQueryVariables = Exact<{
  entrezSymbol?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  geneAlias?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<GenesSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type BrowseGenesQuery = (
  { __typename: 'Query' }
  & { browseGenes: (
    { __typename: 'BrowseGeneConnection' }
    & Pick<BrowseGeneConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { edges: Array<(
      { __typename: 'BrowseGeneEdge' }
      & Pick<BrowseGeneEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseGene' }
        & Pick<BrowseGene, 'id' | 'entrezId' | 'name' | 'variantCount' | 'evidenceItemCount' | 'assertionCount'>
        & { aliases?: Maybe<Array<(
          { __typename: 'GeneAlias' }
          & Pick<GeneAlias, 'name'>
        )>>, diseases?: Maybe<Array<(
          { __typename: 'Disease' }
          & Pick<Disease, 'name' | 'id'>
        )>>, drugs?: Maybe<Array<(
          { __typename: 'Drug' }
          & Pick<Drug, 'name' | 'id'>
        )>> }
      )> }
    )>, pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ) }
  ) }
);

export type GenePopoverQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GenePopoverQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & GenePopoverFragment
  )> }
);

export type GenePopoverFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'name' | 'officialName'>
  & { aliases: Array<(
    { __typename: 'GeneAlias' }
    & Pick<GeneAlias, 'name'>
  )>, variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ) }
);

export type QuicksearchQueryVariables = Exact<{
  query: Scalars['String'];
}>;


export type QuicksearchQuery = (
  { __typename: 'Query' }
  & { search: Array<(
    { __typename: 'SearchResult' }
    & QuicksearchResultFragment
  )> }
);

export type QuicksearchResultFragment = (
  { __typename: 'SearchResult' }
  & Pick<SearchResult, 'id' | 'resultType' | 'name' | 'matchingText'>
);

export type OrgPopoverQueryVariables = Exact<{
  orgId: Scalars['Int'];
}>;


export type OrgPopoverQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & OrgPopoverFragment
  )> }
);

export type OrgPopoverFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'profileImagePath' | 'name' | 'description' | 'url'>
);

export type OrganizationsBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  orgName?: Maybe<Scalars['String']>;
  sortBy?: Maybe<OrganizationSort>;
  cardView: Scalars['Boolean'];
}>;


export type OrganizationsBrowseQuery = (
  { __typename: 'Query' }
  & { organizations: (
    { __typename: 'OrganizationConnection' }
    & Pick<OrganizationConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'OrganizationEdge' }
      & Pick<OrganizationEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Organization' }
        & OrganizationBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type OrganizationBrowseTableRowFieldsFragment = (
  { __typename: 'Organization' }
  & MakeOptional<Pick<Organization, 'id' | 'name' | 'description' | 'profileImagePath' | 'url' | 'memberCount' | 'eventCount'>, 'description' | 'profileImagePath'>
  & { mostRecentEvent?: Maybe<(
    { __typename: 'Event' }
    & Pick<Event, 'createdAt'>
  )>, orgStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ) }
);

export type PhenotypePopoverQueryVariables = Exact<{
  phenotypeId: Scalars['Int'];
}>;


export type PhenotypePopoverQuery = (
  { __typename: 'Query' }
  & { phenotypes: (
    { __typename: 'BrowsePhenotypeConnection' }
    & { edges: Array<(
      { __typename: 'BrowsePhenotypeEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowsePhenotype' }
        & PhenotypePopoverFragment
      )> }
    )> }
  ) }
);

export type PhenotypePopoverFragment = (
  { __typename: 'BrowsePhenotype' }
  & Pick<BrowsePhenotype, 'id' | 'name' | 'url' | 'hpoId' | 'assertionCount' | 'evidenceCount'>
);

export type PhenotypesBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  hpoId?: Maybe<Scalars['String']>;
  sortBy?: Maybe<PhenotypeSort>;
}>;


export type PhenotypesBrowseQuery = (
  { __typename: 'Query' }
  & { phenotypes: (
    { __typename: 'BrowsePhenotypeConnection' }
    & Pick<BrowsePhenotypeConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowsePhenotypeEdge' }
      & Pick<BrowsePhenotypeEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowsePhenotype' }
        & PhenotypeBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type PhenotypeBrowseTableRowFieldsFragment = (
  { __typename: 'BrowsePhenotype' }
  & Pick<BrowsePhenotype, 'id' | 'name' | 'hpoId' | 'url' | 'assertionCount' | 'evidenceCount'>
);

export type ContributorAvatarsQueryVariables = Exact<{
  subscribable: SubscribableInput;
}>;


export type ContributorAvatarsQuery = (
  { __typename: 'Query' }
  & { contributors: (
    { __typename: 'ContributingUsersSummary' }
    & { editors: Array<(
      { __typename: 'ContributingUser' }
      & ContributorFieldsFragment
    )>, curators: Array<(
      { __typename: 'ContributingUser' }
      & ContributorFieldsFragment
    )> }
  ) }
);

export type ContributorFieldsFragment = (
  { __typename: 'ContributingUser' }
  & Pick<ContributingUser, 'lastActionDate' | 'totalActionCount'>
  & { user: (
    { __typename: 'User' }
    & Pick<User, 'id' | 'profileImagePath'>
  ), uniqueActions: Array<(
    { __typename: 'Contribution' }
    & Pick<Contribution, 'action' | 'count'>
  )> }
);

export type SourcePopoverQueryVariables = Exact<{
  sourceId: Scalars['Int'];
}>;


export type SourcePopoverQuery = (
  { __typename: 'Query' }
  & { browseSources: (
    { __typename: 'BrowseSourceConnection' }
    & { edges: Array<(
      { __typename: 'BrowseSourceEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowseSource' }
        & SourcePopoverFragment
      )> }
    )> }
  ) }
);

export type SourcePopoverFragment = (
  { __typename: 'BrowseSource' }
  & Pick<BrowseSource, 'id' | 'name' | 'evidenceItemCount' | 'citation' | 'citationId' | 'displayType' | 'sourceUrl'>
  & { clinicalTrials: Array<(
    { __typename: 'ClinicalTrial' }
    & Pick<ClinicalTrial, 'id' | 'nctId'>
  )> }
);

export type BrowseSourcesQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<SourcesSort>;
  name?: Maybe<Scalars['String']>;
  year?: Maybe<Scalars['Int']>;
  sourceType?: Maybe<SourceSource>;
  citationId?: Maybe<Scalars['Int']>;
  author?: Maybe<Scalars['String']>;
  journal?: Maybe<Scalars['String']>;
  clinicalTrialId?: Maybe<Scalars['Int']>;
}>;


export type BrowseSourcesQuery = (
  { __typename: 'Query' }
  & { browseSources: (
    { __typename: 'BrowseSourceConnection' }
    & Pick<BrowseSourceConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'BrowseSourceEdge' }
      & Pick<BrowseSourceEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseSource' }
        & BrowseSourceRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseSourceRowFieldsFragment = (
  { __typename: 'BrowseSource' }
  & Pick<BrowseSource, 'id' | 'authors' | 'citationId' | 'evidenceItemCount' | 'journal' | 'name' | 'publicationYear' | 'sourceType' | 'citation' | 'displayType'>
);

export type UserPopoverQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type UserPopoverQuery = (
  { __typename: 'Query' }
  & { user?: Maybe<(
    { __typename: 'User' }
    & PopoverUserFragment
  )> }
);

export type PopoverUserFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'profileImagePath' | 'displayName' | 'bio' | 'role'>
  & { organizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name'>
  )> }
);

export type BrowseVariantGroupsQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantGroupsSort>;
  name?: Maybe<Scalars['String']>;
  geneNames?: Maybe<Scalars['String']>;
  variantNames?: Maybe<Scalars['String']>;
}>;


export type BrowseVariantGroupsQuery = (
  { __typename: 'Query' }
  & { browseVariantGroups: (
    { __typename: 'BrowseVariantGroupConnection' }
    & Pick<BrowseVariantGroupConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'BrowseVariantGroupEdge' }
      & Pick<BrowseVariantGroupEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseVariantGroup' }
        & BrowseVariantGroupRowFieldsFragment
      )> }
    )> }
  ) }
);

export type BrowseVariantGroupRowFieldsFragment = (
  { __typename: 'BrowseVariantGroup' }
  & Pick<BrowseVariantGroup, 'id' | 'name' | 'geneNames' | 'variantNames' | 'variantCount' | 'evidenceItemCount'>
);

export type VariantTypePopoverQueryVariables = Exact<{
  variantTypeId: Scalars['Int'];
}>;


export type VariantTypePopoverQuery = (
  { __typename: 'Query' }
  & { variantTypes: (
    { __typename: 'BrowseVariantTypeConnection' }
    & { edges: Array<(
      { __typename: 'BrowseVariantTypeEdge' }
      & { node?: Maybe<(
        { __typename: 'BrowseVariantType' }
        & VariantTypePopoverFragment
      )> }
    )> }
  ) }
);

export type VariantTypePopoverFragment = (
  { __typename: 'BrowseVariantType' }
  & Pick<BrowseVariantType, 'id' | 'name' | 'url' | 'soid' | 'variantCount'>
);

export type VariantTypesBrowseQueryVariables = Exact<{
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  soid?: Maybe<Scalars['String']>;
  sortBy?: Maybe<VariantTypeSort>;
}>;


export type VariantTypesBrowseQuery = (
  { __typename: 'Query' }
  & { variantTypes: (
    { __typename: 'BrowseVariantTypeConnection' }
    & Pick<BrowseVariantTypeConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'hasNextPage' | 'hasPreviousPage' | 'startCursor' | 'endCursor'>
    ), edges: Array<(
      { __typename: 'BrowseVariantTypeEdge' }
      & Pick<BrowseVariantTypeEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseVariantType' }
        & VariantTypeBrowseTableRowFieldsFragment
      )> }
    )> }
  ) }
);

export type VariantTypeBrowseTableRowFieldsFragment = (
  { __typename: 'BrowseVariantType' }
  & Pick<BrowseVariantType, 'id' | 'name' | 'soid' | 'url' | 'variantCount'>
);

export type VariantPopoverQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantPopoverQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & VariantPopoverFieldsFragment
  )> }
);

export type VariantPopoverFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'description' | 'variantAliases' | 'alleleRegistryId'>
  & { evidenceItems: (
    { __typename: 'EvidenceItemConnection' }
    & Pick<EvidenceItemConnection, 'totalCount'>
  ), gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ) }
);

export type VariantsMenuQueryVariables = Exact<{
  geneId?: Maybe<Scalars['Int']>;
  variantName?: Maybe<Scalars['String']>;
  evidenceStatusFilter?: Maybe<VariantDisplayFilter>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type VariantsMenuQuery = (
  { __typename: 'Query' }
  & { variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'startCursor' | 'endCursor' | 'hasPreviousPage' | 'hasNextPage'>
    ), edges: Array<(
      { __typename: 'VariantEdge' }
      & Pick<VariantEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'Variant' }
        & MenuVariantFragment
      )> }
    )> }
  ) }
);

export type MenuVariantFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name'>
);

export type BrowseVariantsQueryVariables = Exact<{
  variantName?: Maybe<Scalars['String']>;
  entrezSymbol?: Maybe<Scalars['String']>;
  diseaseName?: Maybe<Scalars['String']>;
  drugName?: Maybe<Scalars['String']>;
  variantTypeId?: Maybe<Scalars['Int']>;
  sortBy?: Maybe<VariantsSort>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
}>;


export type BrowseVariantsQuery = (
  { __typename: 'Query' }
  & { browseVariants: (
    { __typename: 'BrowseVariantConnection' }
    & Pick<BrowseVariantConnection, 'totalCount' | 'filteredCount' | 'pageCount'>
    & { pageInfo: (
      { __typename: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'startCursor' | 'hasPreviousPage'>
    ), edges: Array<(
      { __typename: 'BrowseVariantEdge' }
      & Pick<BrowseVariantEdge, 'cursor'>
      & { node?: Maybe<(
        { __typename: 'BrowseVariant' }
        & Pick<BrowseVariant, 'id' | 'name' | 'evidenceScore' | 'evidenceItemCount' | 'geneId' | 'geneName' | 'assertionCount'>
        & { diseases: Array<(
          { __typename: 'Disease' }
          & Pick<Disease, 'id' | 'name'>
        )>, drugs: Array<(
          { __typename: 'Drug' }
          & Pick<Drug, 'id' | 'name'>
        )> }
      )> }
    )> }
  ) }
);

export type AddCommentMutationVariables = Exact<{
  input: AddCommentInput;
}>;


export type AddCommentMutation = (
  { __typename: 'Mutation' }
  & { addComment?: Maybe<(
    { __typename: 'AddCommentPayload' }
    & Pick<AddCommentPayload, 'clientMutationId'>
    & { comment?: Maybe<(
      { __typename: 'Comment' }
      & CommentListNodeFragment
    )> }
  )> }
);

export type GeneRevisableFieldsQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GeneRevisableFieldsQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'description'>
    & { sources: Array<(
      { __typename: 'Source' }
      & Pick<Source, 'id' | 'sourceType' | 'citation' | 'citationId'>
    )> }
  )> }
);

export type SuggestGeneRevisionMutationVariables = Exact<{
  input: SuggestGeneRevisionInput;
}>;


export type SuggestGeneRevisionMutation = (
  { __typename: 'Mutation' }
  & { suggestGeneRevision?: Maybe<(
    { __typename: 'SuggestGeneRevisionPayload' }
    & Pick<SuggestGeneRevisionPayload, 'clientMutationId'>
    & { gene: (
      { __typename: 'Gene' }
      & Pick<Gene, 'id'>
      & { revisions: (
        { __typename: 'RevisionConnection' }
        & Pick<RevisionConnection, 'totalCount'>
        & { edges: Array<(
          { __typename: 'RevisionEdge' }
          & { node?: Maybe<(
            { __typename: 'Revision' }
            & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
            & { linkoutData: (
              { __typename: 'LinkoutData' }
              & Pick<LinkoutData, 'name'>
              & { diffValue: (
                { __typename: 'ObjectFieldDiff' }
                & { addedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, removedObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )>, keptObjects: Array<(
                  { __typename: 'ModeratedObjectField' }
                  & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
                )> }
              ) | (
                { __typename: 'ScalarField' }
                & Pick<ScalarField, 'value'>
              ) }
            ), revisor: (
              { __typename: 'User' }
              & Pick<User, 'id' | 'name'>
            ) }
          )> }
        )> }
      ) }
    ), results: Array<(
      { __typename: 'RevisionResult' }
      & Pick<RevisionResult, 'id' | 'fieldName'>
    )> }
  )> }
);

export type CitationExistenceCheckQueryVariables = Exact<{
  sourceType: SourceSource;
  citationId: Scalars['Int'];
}>;


export type CitationExistenceCheckQuery = (
  { __typename: 'Query' }
  & Pick<Query, 'remoteCitation'>
);

export type CreateSourceStubMutationVariables = Exact<{
  input: AddRemoteCitationInput;
}>;


export type CreateSourceStubMutation = (
  { __typename: 'Mutation' }
  & { addRemoteCitation?: Maybe<(
    { __typename: 'AddRemoteCitationPayload' }
    & { newSource: (
      { __typename: 'SourceStub' }
      & Pick<SourceStub, 'id' | 'citationId' | 'sourceType'>
    ) }
  )> }
);

export type CitationTypeaheadQueryVariables = Exact<{
  partialCitationId: Scalars['Int'];
  sourceType: SourceSource;
}>;


export type CitationTypeaheadQuery = (
  { __typename: 'Query' }
  & { sourceTypeahead: Array<(
    { __typename: 'Source' }
    & SourceTypeaheadResultFragment
  )> }
);

export type SourceTypeaheadResultFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'id' | 'name' | 'citation' | 'citationId' | 'sourceType'>
);

export type FlagEntityMutationVariables = Exact<{
  input: FlagEntityInput;
}>;


export type FlagEntityMutation = (
  { __typename: 'Mutation' }
  & { flagEntity?: Maybe<(
    { __typename: 'FlagEntityPayload' }
    & { flag?: Maybe<(
      { __typename: 'Flag' }
      & Pick<Flag, 'id'>
    )> }
  )> }
);

export type ResolveFlagMutationVariables = Exact<{
  input: ResolveFlagInput;
}>;


export type ResolveFlagMutation = (
  { __typename: 'Mutation' }
  & { resolveFlag?: Maybe<(
    { __typename: 'ResolveFlagPayload' }
    & { flag?: Maybe<(
      { __typename: 'Flag' }
      & Pick<Flag, 'id'>
    )> }
  )> }
);

export type ViewerBaseQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerBaseQuery = (
  { __typename: 'Query' }
  & { viewer?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )>, events: (
      { __typename: 'EventConnection' }
      & { nodes: Array<(
        { __typename: 'Event' }
        & Pick<Event, 'id' | 'createdAt'>
        & { organization?: Maybe<(
          { __typename: 'Organization' }
          & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
        )> }
      )> }
    ) }
  )> }
);

export type ViewerFullQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerFullQuery = (
  { __typename: 'Query' }
  & { viewer?: Maybe<(
    { __typename: 'User' }
    & Pick<User, 'id' | 'username' | 'name' | 'email' | 'bio' | 'url' | 'role' | 'profileImagePath'>
    & { organizations: Array<(
      { __typename: 'Organization' }
      & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
    )> }
  )> }
);

export type AssertionDetailQueryVariables = Exact<{
  assertionId: Scalars['Int'];
}>;


export type AssertionDetailQuery = (
  { __typename: 'Query' }
  & { assertion?: Maybe<(
    { __typename: 'Assertion' }
    & AssertionDetailFieldsFragment
  )> }
);

export type AssertionDetailFieldsFragment = (
  { __typename: 'Assertion' }
  & Pick<Assertion, 'id' | 'name'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type AssertionSummaryQueryVariables = Exact<{
  assertionId: Scalars['Int'];
}>;


export type AssertionSummaryQuery = (
  { __typename: 'Query' }
  & { assertion?: Maybe<(
    { __typename: 'Assertion' }
    & AssertionSummaryFieldsFragment
  )> }
);

export type AssertionSummaryFieldsFragment = (
  { __typename: 'Assertion' }
  & Pick<Assertion, 'id' | 'name' | 'summary' | 'description' | 'status' | 'variantOrigin' | 'assertionType' | 'assertionDirection' | 'clinicalSignificance' | 'drugInteractionType' | 'ampLevel' | 'nccnGuideline' | 'regulatoryApproval' | 'fdaCompanionTest'>
  & { disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name' | 'alleleRegistryId'>
  ), drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'ncitId' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, acmgCodes: Array<(
    { __typename: 'AcmgCode' }
    & Pick<AcmgCode, 'code' | 'description'>
  )>, flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), acceptanceEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )>, submissionEvent: (
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  ), rejectionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )> }
);

export type ClinicalTrialDetailQueryVariables = Exact<{
  clinicalTrialId: Scalars['Int'];
}>;


export type ClinicalTrialDetailQuery = (
  { __typename: 'Query' }
  & { clinicalTrial?: Maybe<(
    { __typename: 'ClinicalTrial' }
    & Pick<ClinicalTrial, 'id' | 'name' | 'nctId' | 'description' | 'url'>
  )> }
);

export type DiseaseDetailQueryVariables = Exact<{
  diseaseId: Scalars['Int'];
}>;


export type DiseaseDetailQuery = (
  { __typename: 'Query' }
  & { disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name' | 'doid' | 'diseaseUrl' | 'displayName'>
  )> }
);

export type DrugDetailQueryVariables = Exact<{
  drugId: Scalars['Int'];
}>;


export type DrugDetailQuery = (
  { __typename: 'Query' }
  & { drug?: Maybe<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name' | 'ncitId' | 'drugUrl'>
  )> }
);

export type EvidenceDetailQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidenceDetailQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & EvidenceDetailFieldsFragment
  )> }
);

export type EvidenceDetailFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name'>
  & { variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), assertions: Array<(
    { __typename: 'Assertion' }
    & Pick<Assertion, 'id' | 'name'>
  )>, flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type EvidenceSummaryQueryVariables = Exact<{
  evidenceId: Scalars['Int'];
}>;


export type EvidenceSummaryQuery = (
  { __typename: 'Query' }
  & { evidenceItem?: Maybe<(
    { __typename: 'EvidenceItem' }
    & EvidenceSummaryFieldsFragment
  )> }
);

export type EvidenceSummaryFieldsFragment = (
  { __typename: 'EvidenceItem' }
  & Pick<EvidenceItem, 'id' | 'name' | 'description' | 'status' | 'evidenceLevel' | 'evidenceType' | 'evidenceDirection' | 'clinicalSignificance' | 'variantOrigin' | 'drugInteractionType' | 'evidenceRating'>
  & { drugs: Array<(
    { __typename: 'Drug' }
    & Pick<Drug, 'id' | 'name'>
  )>, disease?: Maybe<(
    { __typename: 'Disease' }
    & Pick<Disease, 'id' | 'name'>
  )>, phenotypes: Array<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name'>
  )>, source: (
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'citationId' | 'sourceType' | 'displayType' | 'sourceUrl' | 'ascoAbstractId'>
    & { clinicalTrials?: Maybe<Array<(
      { __typename: 'ClinicalTrial' }
      & Pick<ClinicalTrial, 'nctId' | 'id'>
    )>> }
  ), gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), variant: (
    { __typename: 'Variant' }
    & Pick<Variant, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), acceptanceEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )>, submissionEvent: (
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  ), rejectionEvent?: Maybe<(
    { __typename: 'Event' }
    & { originatingUser: (
      { __typename: 'User' }
      & Pick<User, 'id' | 'displayName' | 'role' | 'profileImagePath'>
    ) }
  )> }
);

export type GeneDetailQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GeneDetailQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & GeneDetailFieldsFragment
  )> }
);

export type GeneDetailFieldsFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'id' | 'name' | 'officialName' | 'entrezId'>
  & { flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type GeneRevisionsQueryVariables = Exact<{
  geneId: Scalars['Int'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
}>;


export type GeneRevisionsQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & Pick<Gene, 'id'>
    & { revisions: (
      { __typename: 'RevisionConnection' }
      & Pick<RevisionConnection, 'totalCount'>
      & { uniqueRevisors: Array<(
        { __typename: 'User' }
        & Pick<User, 'username' | 'id' | 'profileImagePath'>
      )>, revisedFieldNames: Array<(
        { __typename: 'FieldName' }
        & Pick<FieldName, 'name' | 'displayName'>
      )>, edges: Array<(
        { __typename: 'RevisionEdge' }
        & { node?: Maybe<(
          { __typename: 'Revision' }
          & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
          & { linkoutData: (
            { __typename: 'LinkoutData' }
            & Pick<LinkoutData, 'name'>
            & { diffValue: (
              { __typename: 'ObjectFieldDiff' }
              & { addedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, removedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, keptObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )> }
            ) | (
              { __typename: 'ScalarField' }
              & Pick<ScalarField, 'value'>
            ) }
          ), revisor: (
            { __typename: 'User' }
            & Pick<User, 'id' | 'name'>
          ) }
        )> }
      )> }
    ) }
  )> }
);

export type GenesSummaryQueryVariables = Exact<{
  geneId: Scalars['Int'];
}>;


export type GenesSummaryQuery = (
  { __typename: 'Query' }
  & { gene?: Maybe<(
    { __typename: 'Gene' }
    & GeneSummaryFieldsFragment
  )> }
);

export type GeneSummaryFieldsFragment = (
  { __typename: 'Gene' }
  & Pick<Gene, 'description' | 'entrezId' | 'id' | 'name' | 'officialName' | 'myGeneInfoDetails'>
  & { aliases: Array<(
    { __typename: 'GeneAlias' }
    & Pick<GeneAlias, 'name'>
  )>, sources: Array<(
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'displayType' | 'sourceType'>
  )>, variants: (
    { __typename: 'VariantConnection' }
    & { edges: Array<(
      { __typename: 'VariantEdge' }
      & { node?: Maybe<(
        { __typename: 'Variant' }
        & Pick<Variant, 'id' | 'name' | 'description'>
      )> }
    )> }
  ) }
);

export type OrganizationDetailQueryVariables = Exact<{
  organizationId: Scalars['Int'];
}>;


export type OrganizationDetailQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & OrganizationDetailFieldsFragment
  )> }
);

export type OrganizationDetailFieldsFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'name' | 'url' | 'description' | 'profileImagePath'>
  & { subGroups: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name' | 'profileImagePath'>
  )>, orgStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ), orgAndSuborgsStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ) }
);

export type OrganizationGroupsQueryVariables = Exact<{
  organizationId: Scalars['Int'];
}>;


export type OrganizationGroupsQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & { subGroups: Array<(
      { __typename: 'Organization' }
      & OrganizationGroupsFieldsFragment
    )> }
  )> }
);

export type OrganizationGroupsFieldsFragment = (
  { __typename: 'Organization' }
  & Pick<Organization, 'id' | 'name' | 'description' | 'profileImagePath'>
  & { orgStatsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ) }
);

export type OrganizationMembersQueryVariables = Exact<{
  organizationId: Scalars['Int'];
}>;


export type OrganizationMembersQuery = (
  { __typename: 'Query' }
  & { organization?: Maybe<(
    { __typename: 'Organization' }
    & { members: (
      { __typename: 'UserConnection' }
      & { edges: Array<(
        { __typename: 'UserEdge' }
        & Pick<UserEdge, 'cursor'>
        & { node?: Maybe<(
          { __typename: 'User' }
          & OrganizationMembersFieldsFragment
        )> }
      )> }
    ) }
  )> }
);

export type OrganizationMembersFieldsFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'name' | 'displayName' | 'username' | 'profileImagePath' | 'role' | 'url' | 'areaOfExpertise' | 'orcid' | 'twitterHandle' | 'facebookProfile' | 'linkedinProfile'>
);

export type PhenotypeDetailQueryVariables = Exact<{
  phenotypeId: Scalars['Int'];
}>;


export type PhenotypeDetailQuery = (
  { __typename: 'Query' }
  & { phenotype?: Maybe<(
    { __typename: 'Phenotype' }
    & Pick<Phenotype, 'id' | 'name' | 'hpoId' | 'url'>
  )> }
);

export type SourceDetailQueryVariables = Exact<{
  sourceId: Scalars['Int'];
}>;


export type SourceDetailQuery = (
  { __typename: 'Query' }
  & { source?: Maybe<(
    { __typename: 'Source' }
    & SourceDetailFieldsFragment
  )> }
);

export type SourceDetailFieldsFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'displayType' | 'citationId'>
);

export type SourceSummaryQueryVariables = Exact<{
  sourceId: Scalars['Int'];
}>;


export type SourceSummaryQuery = (
  { __typename: 'Query' }
  & { source?: Maybe<(
    { __typename: 'Source' }
    & SourceSummaryFieldsFragment
  )> }
);

export type SourceSummaryFieldsFragment = (
  { __typename: 'Source' }
  & Pick<Source, 'displayType' | 'title' | 'abstract' | 'publicationDate' | 'citationId' | 'fullJournalTitle' | 'pmcId' | 'authorString'>
  & { clinicalTrials?: Maybe<Array<(
    { __typename: 'ClinicalTrial' }
    & Pick<ClinicalTrial, 'nctId' | 'id'>
  )>> }
);

export type UserDetailQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type UserDetailQuery = (
  { __typename: 'Query' }
  & { user?: Maybe<(
    { __typename: 'User' }
    & UserDetailFieldsFragment
  )> }
);

export type UserDetailFieldsFragment = (
  { __typename: 'User' }
  & Pick<User, 'id' | 'name' | 'displayName' | 'username' | 'profileImagePath' | 'role' | 'url' | 'bio' | 'areaOfExpertise' | 'orcid' | 'twitterHandle' | 'facebookProfile' | 'linkedinProfile' | 'country'>
  & { organizations: Array<(
    { __typename: 'Organization' }
    & Pick<Organization, 'id' | 'name'>
  )>, statsHash: (
    { __typename: 'Stats' }
    & Pick<Stats, 'comments' | 'revisions' | 'appliedRevisions' | 'submittedEvidenceItems' | 'acceptedEvidenceItems' | 'suggestedSources' | 'submittedAssertions' | 'acceptedAssertions'>
  ), mostRecentConflictOfInterestStatement?: Maybe<(
    { __typename: 'Coi' }
    & Pick<Coi, 'coiPresent' | 'coiStatement' | 'coiStatus' | 'createdAt' | 'expiresAt'>
  )> }
);

export type VariantGroupDetailQueryVariables = Exact<{
  variantGroupId: Scalars['Int'];
}>;


export type VariantGroupDetailQuery = (
  { __typename: 'Query' }
  & { variantGroup?: Maybe<(
    { __typename: 'VariantGroup' }
    & VariantGroupDetailFieldsFragment
  )> }
);

export type VariantGroupDetailFieldsFragment = (
  { __typename: 'VariantGroup' }
  & Pick<VariantGroup, 'id' | 'name'>
  & { variants: (
    { __typename: 'VariantConnection' }
    & Pick<VariantConnection, 'totalCount'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type VariantGroupRevisionsQueryVariables = Exact<{
  variantGroupId: Scalars['Int'];
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['String']>;
  after?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  originatingUserId?: Maybe<Scalars['Int']>;
}>;


export type VariantGroupRevisionsQuery = (
  { __typename: 'Query' }
  & { variantGroup?: Maybe<(
    { __typename: 'VariantGroup' }
    & Pick<VariantGroup, 'id'>
    & { revisions: (
      { __typename: 'RevisionConnection' }
      & Pick<RevisionConnection, 'totalCount'>
      & { uniqueRevisors: Array<(
        { __typename: 'User' }
        & Pick<User, 'username' | 'id' | 'profileImagePath'>
      )>, revisedFieldNames: Array<(
        { __typename: 'FieldName' }
        & Pick<FieldName, 'name' | 'displayName'>
      )>, edges: Array<(
        { __typename: 'RevisionEdge' }
        & { node?: Maybe<(
          { __typename: 'Revision' }
          & Pick<Revision, 'id' | 'revisionsetId' | 'createdAt' | 'fieldName' | 'currentValue' | 'suggestedValue' | 'status'>
          & { linkoutData: (
            { __typename: 'LinkoutData' }
            & Pick<LinkoutData, 'name'>
            & { diffValue: (
              { __typename: 'ObjectFieldDiff' }
              & { addedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, removedObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )>, keptObjects: Array<(
                { __typename: 'ModeratedObjectField' }
                & Pick<ModeratedObjectField, 'id' | 'displayName' | 'displayType' | 'entityType'>
              )> }
            ) | (
              { __typename: 'ScalarField' }
              & Pick<ScalarField, 'value'>
            ) }
          ), revisor: (
            { __typename: 'User' }
            & Pick<User, 'id' | 'name'>
          ) }
        )> }
      )> }
    ) }
  )> }
);

export type VariantGroupsSummaryQueryVariables = Exact<{
  variantGroupId: Scalars['Int'];
}>;


export type VariantGroupsSummaryQuery = (
  { __typename: 'Query' }
  & { variantGroup?: Maybe<(
    { __typename: 'VariantGroup' }
    & VariantGroupSummaryFieldsFragment
  )> }
);

export type VariantGroupSummaryFieldsFragment = (
  { __typename: 'VariantGroup' }
  & Pick<VariantGroup, 'id' | 'name' | 'description'>
);

export type VariantTypeDetailQueryVariables = Exact<{
  variantTypeId: Scalars['Int'];
}>;


export type VariantTypeDetailQuery = (
  { __typename: 'Query' }
  & { variantType?: Maybe<(
    { __typename: 'VariantType' }
    & Pick<VariantType, 'id' | 'name' | 'soid' | 'description' | 'url'>
  )> }
);

export type VariantDetailQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantDetailQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & VariantDetailFieldsFragment
  )> }
);

export type VariantDetailFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'variantAliases'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ) }
);

export type VariantSummaryQueryVariables = Exact<{
  variantId: Scalars['Int'];
}>;


export type VariantSummaryQuery = (
  { __typename: 'Query' }
  & { variant?: Maybe<(
    { __typename: 'Variant' }
    & VariantSummaryFieldsFragment
  )> }
);

export type VariantSummaryFieldsFragment = (
  { __typename: 'Variant' }
  & Pick<Variant, 'id' | 'name' | 'description' | 'variantAliases' | 'alleleRegistryId' | 'hgvsDescriptions' | 'clinvarIds' | 'evidenceScore' | 'referenceBuild' | 'ensemblVersion'>
  & { gene: (
    { __typename: 'Gene' }
    & Pick<Gene, 'id' | 'name'>
  ), sources: Array<(
    { __typename: 'Source' }
    & Pick<Source, 'id' | 'citation' | 'sourceUrl' | 'displayType' | 'sourceType'>
  )>, variantTypes?: Maybe<Array<(
    { __typename: 'VariantType' }
    & Pick<VariantType, 'soid' | 'name'>
  )>>, fivePrimeCoordinates?: Maybe<(
    { __typename: 'Coordinate' }
    & Pick<Coordinate, 'representativeTranscript' | 'chromosome' | 'start' | 'stop' | 'referenceBases' | 'variantBases'>
  )>, threePrimeCoordinates?: Maybe<(
    { __typename: 'Coordinate' }
    & Pick<Coordinate, 'representativeTranscript' | 'chromosome' | 'start' | 'stop' | 'referenceBases' | 'variantBases'>
  )>, flags: (
    { __typename: 'FlagConnection' }
    & Pick<FlagConnection, 'totalCount'>
  ), revisions: (
    { __typename: 'RevisionConnection' }
    & Pick<RevisionConnection, 'totalCount'>
  ), comments: (
    { __typename: 'CommentConnection' }
    & Pick<CommentConnection, 'totalCount'>
  ), myVariantInfo?: Maybe<(
    { __typename: 'MyVariantInfo' }
    & MyVariantInfoFieldsFragment
  )> }
);

export type MyVariantInfoFieldsFragment = (
  { __typename: 'MyVariantInfo' }
  & Pick<MyVariantInfo, 'myVariantInfoId' | 'caddConsequence' | 'caddDetail' | 'caddScore' | 'clinvarClinicalSignificance' | 'clinvarHgvsCoding' | 'clinvarHgvsGenomic' | 'clinvarHgvsNonCoding' | 'clinvarHgvsProtein' | 'clinvarId' | 'clinvarOmim' | 'cosmicId' | 'dbnsfpInterproDomain' | 'dbsnpRsid' | 'eglClass' | 'eglHgvs' | 'eglProtein' | 'eglTranscript' | 'exacAlleleCount' | 'exacAlleleFrequency' | 'exacAlleleNumber' | 'fathmmMklPrediction' | 'fathmmMklScore' | 'fathmmPrediction' | 'fathmmScore' | 'fitconsScore' | 'gerp' | 'gnomadExomeAlleleCount' | 'gnomadExomeAlleleFrequency' | 'gnomadExomeAlleleNumber' | 'gnomadExomeFilter' | 'gnomadGenomeAlleleCount' | 'gnomadGenomeAlleleFrequency' | 'gnomadGenomeAlleleNumber' | 'gnomadGenomeFilter' | 'lrtPrediction' | 'lrtScore' | 'metalrPrediction' | 'metalrScore' | 'metasvmPrediction' | 'metasvmScore' | 'mutationassessorPrediction' | 'mutationassessorScore' | 'mutationtasterPrediction' | 'mutationtasterScore' | 'phastcons100way' | 'phastcons30way' | 'phyloP100way' | 'phyloP30way' | 'polyphen2HdivPrediction' | 'polyphen2HdivScore' | 'polyphen2HvarPrediction' | 'polyphen2HvarScore' | 'proveanPrediction' | 'proveanScore' | 'revelScore' | 'siftPrediction' | 'siftScore' | 'siphy' | 'snpeffSnpEffect' | 'snpeffSnpImpact'>
);

export const AssertionPopoverFragmentDoc = gql`
    fragment assertionPopover on Assertion {
  id
  name
  summary
  assertionType
  assertionDirection
  clinicalSignificance
  variantOrigin
  ampLevel
  acmgCodes {
    code
  }
  nccnGuideline
  fdaCompanionTest
  regulatoryApproval
  drugs {
    id
    name
  }
  drugInteractionType
  disease {
    id
    name
  }
  phenotypes {
    id
    name
  }
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const AssertionBrowseTableRowFieldsFragmentDoc = gql`
    fragment AssertionBrowseTableRowFields on Assertion {
  id
  name
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  disease {
    id
    name
  }
  drugs {
    id
    name
  }
  phenotypes @include(if: $cardView) {
    id
    name
  }
  drugInteractionType
  summary
  assertionType
  assertionDirection
  clinicalSignificance
  ampLevel
  acmgCodes @include(if: $cardView) {
    code
  }
  fdaCompanionTest @include(if: $cardView)
  regulatoryApproval @include(if: $cardView)
  nccnGuideline @include(if: $cardView)
  variantOrigin @include(if: $cardView)
}
    `;
export const ClinicalTrialPopoverFragmentDoc = gql`
    fragment clinicalTrialPopover on BrowseClinicalTrial {
  id
  name
  nctId
  url
  sourceCount
  evidenceCount
}
    `;
export const CommentListNodeFragmentDoc = gql`
    fragment commentListNode on Comment {
  id
  title
  comment
  createdAt
  commenter {
    id
    username
    displayName
    name
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
}
    `;
export const CommentPopoverFragmentDoc = gql`
    fragment commentPopover on Comment {
  id
  name
  createdAt
  title
  comment
  commenter {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  commentable {
    id
    name
    __typename
  }
}
    `;
export const DiseasePopoverFragmentDoc = gql`
    fragment diseasePopover on BrowseDisease {
  id
  name
  doid
  diseaseUrl
  assertionCount
  evidenceItemCount
  variantCount
}
    `;
export const BrowseDiseaseRowFieldsFragmentDoc = gql`
    fragment BrowseDiseaseRowFields on BrowseDisease {
  id
  name
  doid
  diseaseUrl
  geneNames
  assertionCount
  evidenceItemCount
  variantCount
}
    `;
export const DrugPopoverFragmentDoc = gql`
    fragment drugPopover on BrowseDrug {
  id
  name
  drugUrl
  ncitId
  assertionCount
  evidenceCount
}
    `;
export const DrugBrowseTableRowFieldsFragmentDoc = gql`
    fragment DrugBrowseTableRowFields on BrowseDrug {
  id
  name
  ncitId
  drugUrl
  assertionCount
  evidenceCount
}
    `;
export const EventFeedNodeFragmentDoc = gql`
    fragment eventFeedNode on Event {
  id
  action
  createdAt
  organization {
    id
    name
    profileImagePath(size: 32)
  }
  originatingUser {
    id
    username
    displayName
    role
    profileImagePath(size: 32)
  }
  subject {
    name
    id
    __typename
  }
  originatingObject {
    id
    name
    __typename
    ... on Revision {
      id
    }
    ... on Comment {
      id
    }
    ... on Flag {
      id
    }
  }
}
    `;
export const EventFeedFragmentDoc = gql`
    fragment eventFeed on EventConnection {
  pageInfo {
    startCursor
    endCursor
    hasNextPage
    hasPreviousPage
  }
  eventTypes
  uniqueParticipants {
    id
    displayName
    role
    profileImagePath(size: 32)
  }
  participatingOrganizations {
    id
    name
    profileImagePath(size: 32)
  }
  edges {
    cursor
    node {
      ...eventFeedNode
    }
  }
}
    ${EventFeedNodeFragmentDoc}`;
export const EvidencePopoverFragmentDoc = gql`
    fragment evidencePopover on EvidenceItem {
  id
  name
  description
  evidenceLevel
  evidenceType
  evidenceDirection
  clinicalSignificance
  variantOrigin
  drugs {
    id
    name
  }
  drugInteractionType
  disease {
    id
    name
  }
  phenotypes {
    id
    name
  }
  evidenceRating
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  source {
    id
    citation
    sourceType
    displayType
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const EvidenceGridFieldsFragmentDoc = gql`
    fragment EvidenceGridFields on EvidenceItem {
  id
  name
  disease {
    id
    name
  }
  drugs {
    id
    name
  }
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  phenotypes @include(if: $cardView) {
    id
    name
  }
  source @include(if: $cardView) {
    id
    citation
    citationId
    sourceType
    sourceUrl
    clinicalTrials {
      nctId
      id
    }
  }
  assertions @include(if: $cardView) {
    id
    name
  }
  status
  drugInteractionType
  description
  evidenceType
  evidenceDirection
  evidenceLevel
  evidenceRating
  clinicalSignificance
  variantOrigin
}
    `;
export const FlagListFragmentDoc = gql`
    fragment flagList on FlagConnection {
  pageInfo {
    startCursor
    endCursor
    hasNextPage
    hasPreviousPage
  }
  edges {
    node {
      id
      state
      createdAt
      resolvedAt
      flaggable {
        id
        name
      }
      flaggingUser {
        id
        displayName
        profileImagePath(size: 32)
      }
      resolvingUser {
        id
        displayName
        profileImagePath(size: 32)
      }
      openComment {
        comment
      }
      resolutionComment {
        comment
      }
    }
  }
}
    `;
export const GenePopoverFragmentDoc = gql`
    fragment genePopover on Gene {
  id
  name
  officialName
  aliases {
    name
  }
  variants {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  flags(state: OPEN) {
    totalCount
  }
}
    `;
export const QuicksearchResultFragmentDoc = gql`
    fragment QuicksearchResult on SearchResult {
  id
  resultType
  name
  matchingText
}
    `;
export const OrgPopoverFragmentDoc = gql`
    fragment orgPopover on Organization {
  id
  profileImagePath(size: 64)
  name
  description
  url
}
    `;
export const OrganizationBrowseTableRowFieldsFragmentDoc = gql`
    fragment OrganizationBrowseTableRowFields on Organization {
  id
  name
  description @include(if: $cardView)
  profileImagePath(size: 256) @include(if: $cardView)
  url
  memberCount
  eventCount
  mostRecentEvent {
    createdAt
  }
  orgStatsHash @include(if: $cardView) {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
}
    `;
export const PhenotypePopoverFragmentDoc = gql`
    fragment phenotypePopover on BrowsePhenotype {
  id
  name
  url
  hpoId
  assertionCount
  evidenceCount
}
    `;
export const PhenotypeBrowseTableRowFieldsFragmentDoc = gql`
    fragment PhenotypeBrowseTableRowFields on BrowsePhenotype {
  id
  name
  hpoId
  url
  assertionCount
  evidenceCount
}
    `;
export const ContributorFieldsFragmentDoc = gql`
    fragment ContributorFields on ContributingUser {
  user {
    id
    profileImagePath(size: 12)
  }
  uniqueActions {
    action
    count
  }
  lastActionDate
  totalActionCount
}
    `;
export const SourcePopoverFragmentDoc = gql`
    fragment sourcePopover on BrowseSource {
  id
  name
  evidenceItemCount
  citation
  citationId
  displayType
  sourceUrl
  clinicalTrials {
    id
    nctId
  }
}
    `;
export const BrowseSourceRowFieldsFragmentDoc = gql`
    fragment BrowseSourceRowFields on BrowseSource {
  id
  authors
  citationId
  evidenceItemCount
  journal
  name
  publicationYear
  sourceType
  citation
  displayType
}
    `;
export const PopoverUserFragmentDoc = gql`
    fragment popoverUser on User {
  id
  profileImagePath(size: 64)
  displayName
  bio
  role
  organizations {
    id
    name
  }
}
    `;
export const BrowseVariantGroupRowFieldsFragmentDoc = gql`
    fragment BrowseVariantGroupRowFields on BrowseVariantGroup {
  id
  name
  geneNames
  variantNames
  variantCount
  evidenceItemCount
}
    `;
export const VariantTypePopoverFragmentDoc = gql`
    fragment variantTypePopover on BrowseVariantType {
  id
  name
  url
  soid
  variantCount
}
    `;
export const VariantTypeBrowseTableRowFieldsFragmentDoc = gql`
    fragment VariantTypeBrowseTableRowFields on BrowseVariantType {
  id
  name
  soid
  url
  variantCount
}
    `;
export const VariantPopoverFieldsFragmentDoc = gql`
    fragment variantPopoverFields on Variant {
  id
  name
  description
  variantAliases
  alleleRegistryId
  evidenceItems {
    totalCount
  }
  gene {
    id
    name
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  flags(state: OPEN) {
    totalCount
  }
}
    `;
export const MenuVariantFragmentDoc = gql`
    fragment menuVariant on Variant {
  id
  name
}
    `;
export const SourceTypeaheadResultFragmentDoc = gql`
    fragment SourceTypeaheadResult on Source {
  id
  name
  citation
  citationId
  sourceType
}
    `;
export const AssertionDetailFieldsFragmentDoc = gql`
    fragment AssertionDetailFields on Assertion {
  id
  name
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const AssertionSummaryFieldsFragmentDoc = gql`
    fragment AssertionSummaryFields on Assertion {
  id
  name
  summary
  description
  status
  variantOrigin
  disease {
    id
    name
  }
  gene {
    id
    name
  }
  variant {
    id
    name
    alleleRegistryId
  }
  assertionType
  assertionDirection
  clinicalSignificance
  drugs {
    ncitId
    name
  }
  phenotypes {
    id
    name
  }
  drugInteractionType
  ampLevel
  acmgCodes {
    code
    description
  }
  nccnGuideline
  regulatoryApproval
  fdaCompanionTest
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  acceptanceEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  submissionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  rejectionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
}
    `;
export const EvidenceDetailFieldsFragmentDoc = gql`
    fragment EvidenceDetailFields on EvidenceItem {
  id
  name
  variant {
    id
    name
  }
  gene {
    id
    name
  }
  assertions {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const EvidenceSummaryFieldsFragmentDoc = gql`
    fragment EvidenceSummaryFields on EvidenceItem {
  id
  name
  description
  status
  evidenceLevel
  evidenceType
  evidenceDirection
  clinicalSignificance
  variantOrigin
  drugs {
    id
    name
  }
  drugInteractionType
  disease {
    id
    name
  }
  phenotypes {
    id
    name
  }
  source {
    id
    citation
    citationId
    sourceType
    displayType
    sourceUrl
    ascoAbstractId
    clinicalTrials {
      nctId
      id
    }
  }
  evidenceRating
  gene {
    id
    name
  }
  variant {
    id
    name
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  acceptanceEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  submissionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
  rejectionEvent {
    originatingUser {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
  }
}
    `;
export const GeneDetailFieldsFragmentDoc = gql`
    fragment GeneDetailFields on Gene {
  id
  name
  officialName
  entrezId
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const GeneSummaryFieldsFragmentDoc = gql`
    fragment GeneSummaryFields on Gene {
  description
  entrezId
  aliases {
    name
  }
  id
  name
  officialName
  sources {
    id
    citation
    sourceUrl
    displayType
    sourceType
  }
  variants {
    edges {
      node {
        id
        name
        description
      }
    }
  }
  myGeneInfoDetails
}
    `;
export const OrganizationDetailFieldsFragmentDoc = gql`
    fragment OrganizationDetailFields on Organization {
  id
  name
  url
  description
  profileImagePath(size: 256)
  subGroups {
    id
    name
    profileImagePath(size: 12)
  }
  orgStatsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
  orgAndSuborgsStatsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
}
    `;
export const OrganizationGroupsFieldsFragmentDoc = gql`
    fragment OrganizationGroupsFields on Organization {
  id
  name
  description
  profileImagePath(size: 12)
  orgStatsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
}
    `;
export const OrganizationMembersFieldsFragmentDoc = gql`
    fragment OrganizationMembersFields on User {
  id
  name
  displayName
  username
  profileImagePath(size: 36)
  role
  url
  areaOfExpertise
  orcid
  twitterHandle
  facebookProfile
  linkedinProfile
}
    `;
export const SourceDetailFieldsFragmentDoc = gql`
    fragment SourceDetailFields on Source {
  id
  citation
  sourceUrl
  displayType
  citationId
}
    `;
export const SourceSummaryFieldsFragmentDoc = gql`
    fragment SourceSummaryFields on Source {
  displayType
  title
  abstract
  publicationDate
  citationId
  fullJournalTitle
  pmcId
  authorString
  clinicalTrials {
    nctId
    id
  }
}
    `;
export const UserDetailFieldsFragmentDoc = gql`
    fragment UserDetailFields on User {
  id
  name
  displayName
  username
  profileImagePath(size: 36)
  role
  url
  bio
  areaOfExpertise
  orcid
  twitterHandle
  facebookProfile
  linkedinProfile
  organizations {
    id
    name
  }
  country
  statsHash {
    comments
    revisions
    appliedRevisions
    submittedEvidenceItems
    acceptedEvidenceItems
    suggestedSources
    submittedAssertions
    acceptedAssertions
  }
  mostRecentConflictOfInterestStatement {
    coiPresent
    coiStatement
    coiStatus
    createdAt
    expiresAt
  }
}
    `;
export const VariantGroupDetailFieldsFragmentDoc = gql`
    fragment VariantGroupDetailFields on VariantGroup {
  id
  name
  variants {
    totalCount
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const VariantGroupSummaryFieldsFragmentDoc = gql`
    fragment VariantGroupSummaryFields on VariantGroup {
  id
  name
  description
}
    `;
export const VariantDetailFieldsFragmentDoc = gql`
    fragment VariantDetailFields on Variant {
  id
  name
  gene {
    id
    name
  }
  variantAliases
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
}
    `;
export const MyVariantInfoFieldsFragmentDoc = gql`
    fragment MyVariantInfoFields on MyVariantInfo {
  myVariantInfoId
  caddConsequence
  caddDetail
  caddScore
  clinvarClinicalSignificance
  clinvarHgvsCoding
  clinvarHgvsGenomic
  clinvarHgvsNonCoding
  clinvarHgvsProtein
  clinvarId
  clinvarOmim
  cosmicId
  dbnsfpInterproDomain
  dbsnpRsid
  eglClass
  eglHgvs
  eglProtein
  eglTranscript
  exacAlleleCount
  exacAlleleFrequency
  exacAlleleNumber
  fathmmMklPrediction
  fathmmMklScore
  fathmmPrediction
  fathmmScore
  fitconsScore
  gerp
  gnomadExomeAlleleCount
  gnomadExomeAlleleFrequency
  gnomadExomeAlleleNumber
  gnomadExomeFilter
  gnomadGenomeAlleleCount
  gnomadGenomeAlleleFrequency
  gnomadGenomeAlleleNumber
  gnomadGenomeFilter
  lrtPrediction
  lrtScore
  metalrPrediction
  metalrScore
  metasvmPrediction
  metasvmScore
  mutationassessorPrediction
  mutationassessorScore
  mutationtasterPrediction
  mutationtasterScore
  phastcons100way
  phastcons30way
  phyloP100way
  phyloP30way
  polyphen2HdivPrediction
  polyphen2HdivScore
  polyphen2HvarPrediction
  polyphen2HvarScore
  proveanPrediction
  proveanScore
  revelScore
  siftPrediction
  siftScore
  siphy
  snpeffSnpEffect
  snpeffSnpImpact
}
    `;
export const VariantSummaryFieldsFragmentDoc = gql`
    fragment VariantSummaryFields on Variant {
  id
  name
  description
  gene {
    id
    name
  }
  sources {
    id
    citation
    sourceUrl
    displayType
    sourceType
  }
  variantAliases
  alleleRegistryId
  variantTypes {
    soid
    name
  }
  hgvsDescriptions
  clinvarIds
  evidenceScore
  referenceBuild
  ensemblVersion
  fivePrimeCoordinates {
    representativeTranscript
    chromosome
    start
    stop
    referenceBases
    variantBases
  }
  threePrimeCoordinates {
    representativeTranscript
    chromosome
    start
    stop
    referenceBases
    variantBases
  }
  flags(state: OPEN) {
    totalCount
  }
  revisions(status: NEW) {
    totalCount
  }
  comments {
    totalCount
  }
  myVariantInfo {
    ...MyVariantInfoFields
  }
}
    ${MyVariantInfoFieldsFragmentDoc}`;
export const AssertionPopoverDocument = gql`
    query AssertionPopover($assertionId: Int!) {
  assertion(id: $assertionId) {
    ...assertionPopover
  }
}
    ${AssertionPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionPopoverGQL extends Apollo.Query<AssertionPopoverQuery, AssertionPopoverQueryVariables> {
    document = AssertionPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssertionsBrowseDocument = gql`
    query AssertionsBrowse($first: Int, $last: Int, $before: String, $after: String, $diseaseName: String, $drugName: String, $id: Int, $summary: String, $assertionDirection: EvidenceDirection, $clinicalSignificance: EvidenceClinicalSignificance, $assertionType: EvidenceType, $variantId: Int, $evidenceId: Int, $geneName: String, $variantName: String, $sortBy: AssertionSort, $ampLevel: AmpLevel, $organizationId: Int, $userId: Int, $phenotypeId: Int, $diseaseId: Int, $drugId: Int, $cardView: Boolean!) {
  assertions(
    first: $first
    last: $last
    before: $before
    after: $after
    diseaseName: $diseaseName
    drugName: $drugName
    id: $id
    summary: $summary
    assertionDirection: $assertionDirection
    clinicalSignificance: $clinicalSignificance
    assertionType: $assertionType
    variantId: $variantId
    sortBy: $sortBy
    ampLevel: $ampLevel
    geneName: $geneName
    variantName: $variantName
    evidenceId: $evidenceId
    organizationId: $organizationId
    userId: $userId
    phenotypeId: $phenotypeId
    drugId: $drugId
    diseaseId: $diseaseId
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...AssertionBrowseTableRowFields
      }
    }
  }
}
    ${AssertionBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionsBrowseGQL extends Apollo.Query<AssertionsBrowseQuery, AssertionsBrowseQueryVariables> {
    document = AssertionsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ClinicalTrialPopoverDocument = gql`
    query ClinicalTrialPopover($clinicalTrialId: Int!) {
  clinicalTrials(id: $clinicalTrialId) {
    edges {
      node {
        ...clinicalTrialPopover
      }
    }
  }
}
    ${ClinicalTrialPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class ClinicalTrialPopoverGQL extends Apollo.Query<ClinicalTrialPopoverQuery, ClinicalTrialPopoverQueryVariables> {
    document = ClinicalTrialPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ClinicalTrialsBrowseDocument = gql`
    query ClinicalTrialsBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $nctId: String, $sortBy: ClinicalTrialSort) {
  clinicalTrials(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    nctId: $nctId
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        name
        nctId
        evidenceCount
        sourceCount
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ClinicalTrialsBrowseGQL extends Apollo.Query<ClinicalTrialsBrowseQuery, ClinicalTrialsBrowseQueryVariables> {
    document = ClinicalTrialsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CommentListDocument = gql`
    query CommentList($first: Int, $last: Int, $before: String, $after: String, $originatingUserId: Int, $subject: CommentableInput, $sortBy: DateSort) {
  comments(
    first: $first
    last: $last
    before: $before
    after: $after
    originatingUserId: $originatingUserId
    subject: $subject
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    uniqueCommenters {
      id
      displayName
      role
      profileImagePath(size: 32)
    }
    edges {
      cursor
      node {
        ...commentListNode
      }
    }
  }
}
    ${CommentListNodeFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CommentListGQL extends Apollo.Query<CommentListQuery, CommentListQueryVariables> {
    document = CommentListDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CommentPopoverDocument = gql`
    query CommentPopover($commentId: Int!) {
  comment(id: $commentId) {
    ...commentPopover
  }
}
    ${CommentPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CommentPopoverGQL extends Apollo.Query<CommentPopoverQuery, CommentPopoverQueryVariables> {
    document = CommentPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DiseasePopoverDocument = gql`
    query DiseasePopover($diseaseId: Int!) {
  browseDiseases(id: $diseaseId) {
    edges {
      node {
        ...diseasePopover
      }
    }
  }
}
    ${DiseasePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class DiseasePopoverGQL extends Apollo.Query<DiseasePopoverQuery, DiseasePopoverQueryVariables> {
    document = DiseasePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseDiseasesDocument = gql`
    query BrowseDiseases($first: Int, $last: Int, $before: String, $after: String, $sortBy: DiseasesSort, $name: String, $doid: String, $geneNames: String) {
  browseDiseases(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    name: $name
    doid: $doid
    geneNames: $geneNames
  ) {
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseDiseaseRowFields
      }
    }
  }
}
    ${BrowseDiseaseRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseDiseasesGQL extends Apollo.Query<BrowseDiseasesQuery, BrowseDiseasesQueryVariables> {
    document = BrowseDiseasesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugPopoverDocument = gql`
    query DrugPopover($drugId: Int!) {
  drugs(id: $drugId) {
    edges {
      node {
        ...drugPopover
      }
    }
  }
}
    ${DrugPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugPopoverGQL extends Apollo.Query<DrugPopoverQuery, DrugPopoverQueryVariables> {
    document = DrugPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugsBrowseDocument = gql`
    query DrugsBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $ncitId: String, $sortBy: DrugSort) {
  drugs(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    ncitId: $ncitId
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...DrugBrowseTableRowFields
      }
    }
  }
}
    ${DrugBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugsBrowseGQL extends Apollo.Query<DrugsBrowseQuery, DrugsBrowseQueryVariables> {
    document = DrugsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EventFeedDocument = gql`
    query EventFeed($subject: SubscribableQueryInput, $first: Int, $last: Int, $before: String, $after: String, $originatingUserId: Int, $organizationId: Int, $eventType: EventAction) {
  events(
    subject: $subject
    first: $first
    last: $last
    before: $before
    after: $after
    originatingUserId: $originatingUserId
    organizationId: $organizationId
    eventType: $eventType
  ) {
    ...eventFeed
  }
}
    ${EventFeedFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EventFeedGQL extends Apollo.Query<EventFeedQuery, EventFeedQueryVariables> {
    document = EventFeedDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidencePopoverDocument = gql`
    query EvidencePopover($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...evidencePopover
  }
}
    ${EvidencePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidencePopoverGQL extends Apollo.Query<EvidencePopoverQuery, EvidencePopoverQueryVariables> {
    document = EvidencePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceBrowseDocument = gql`
    query EvidenceBrowse($first: Int, $last: Int, $before: String, $after: String, $diseaseName: String, $drugName: String, $id: Int, $description: String, $evidenceLevel: EvidenceLevel, $evidenceDirection: EvidenceDirection, $clinicalSignificance: EvidenceClinicalSignificance, $evidenceType: EvidenceType, $rating: Int, $variantOrigin: VariantOrigin, $variantId: Int, $assertionId: Int, $organizationId: Int, $userId: Int, $sortBy: EvidenceSort, $phenotypeId: Int, $diseaseId: Int, $drugId: Int, $sourceId: Int, $clinicalTrialId: Int, $geneSymbol: String, $variantName: String, $cardView: Boolean!) {
  evidenceItems(
    first: $first
    last: $last
    before: $before
    after: $after
    diseaseName: $diseaseName
    drugName: $drugName
    id: $id
    description: $description
    evidenceLevel: $evidenceLevel
    evidenceDirection: $evidenceDirection
    clinicalSignificance: $clinicalSignificance
    evidenceType: $evidenceType
    evidenceRating: $rating
    variantOrigin: $variantOrigin
    variantId: $variantId
    assertionId: $assertionId
    organizationId: $organizationId
    userId: $userId
    phenotypeId: $phenotypeId
    diseaseId: $diseaseId
    drugId: $drugId
    sourceId: $sourceId
    clinicalTrialId: $clinicalTrialId
    geneSymbol: $geneSymbol
    variantName: $variantName
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...EvidenceGridFields
      }
    }
  }
}
    ${EvidenceGridFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceBrowseGQL extends Apollo.Query<EvidenceBrowseQuery, EvidenceBrowseQueryVariables> {
    document = EvidenceBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const FlagListDocument = gql`
    query FlagList($flaggable: FlaggableInput, $flaggingUserId: Int, $resolvingUserId: Int, $state: FlagState, $sortBy: DateSort, $first: Int, $last: Int, $before: String, $after: String) {
  flags(
    flaggable: $flaggable
    flaggingUserId: $flaggingUserId
    resolvingUserId: $resolvingUserId
    state: $state
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    ...flagList
  }
}
    ${FlagListFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class FlagListGQL extends Apollo.Query<FlagListQuery, FlagListQueryVariables> {
    document = FlagListDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseGenesDocument = gql`
    query BrowseGenes($entrezSymbol: String, $drugName: String, $geneAlias: String, $diseaseName: String, $sortBy: GenesSort, $first: Int, $last: Int, $before: String, $after: String) {
  browseGenes(
    entrezSymbol: $entrezSymbol
    drugName: $drugName
    geneAlias: $geneAlias
    diseaseName: $diseaseName
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    edges {
      cursor
      node {
        id
        entrezId
        name
        aliases {
          name
        }
        diseases {
          name
          id
        }
        drugs {
          name
          id
        }
        variantCount
        evidenceItemCount
        assertionCount
      }
    }
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    totalCount
    filteredCount
    pageCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseGenesGQL extends Apollo.Query<BrowseGenesQuery, BrowseGenesQueryVariables> {
    document = BrowseGenesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GenePopoverDocument = gql`
    query GenePopover($geneId: Int!) {
  gene(id: $geneId) {
    ...genePopover
  }
}
    ${GenePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GenePopoverGQL extends Apollo.Query<GenePopoverQuery, GenePopoverQueryVariables> {
    document = GenePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const QuicksearchDocument = gql`
    query Quicksearch($query: String!) {
  search(query: $query) {
    ...QuicksearchResult
  }
}
    ${QuicksearchResultFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class QuicksearchGQL extends Apollo.Query<QuicksearchQuery, QuicksearchQueryVariables> {
    document = QuicksearchDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrgPopoverDocument = gql`
    query OrgPopover($orgId: Int!) {
  organization(id: $orgId) {
    ...orgPopover
  }
}
    ${OrgPopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrgPopoverGQL extends Apollo.Query<OrgPopoverQuery, OrgPopoverQueryVariables> {
    document = OrgPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationsBrowseDocument = gql`
    query OrganizationsBrowse($first: Int, $last: Int, $before: String, $after: String, $id: Int, $orgName: String, $sortBy: OrganizationSort, $cardView: Boolean!) {
  organizations(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $orgName
    id: $id
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...OrganizationBrowseTableRowFields
      }
    }
  }
}
    ${OrganizationBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationsBrowseGQL extends Apollo.Query<OrganizationsBrowseQuery, OrganizationsBrowseQueryVariables> {
    document = OrganizationsBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypePopoverDocument = gql`
    query PhenotypePopover($phenotypeId: Int!) {
  phenotypes(id: $phenotypeId) {
    edges {
      node {
        ...phenotypePopover
      }
    }
  }
}
    ${PhenotypePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypePopoverGQL extends Apollo.Query<PhenotypePopoverQuery, PhenotypePopoverQueryVariables> {
    document = PhenotypePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypesBrowseDocument = gql`
    query PhenotypesBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $hpoId: String, $sortBy: PhenotypeSort) {
  phenotypes(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    hpoId: $hpoId
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...PhenotypeBrowseTableRowFields
      }
    }
  }
}
    ${PhenotypeBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypesBrowseGQL extends Apollo.Query<PhenotypesBrowseQuery, PhenotypesBrowseQueryVariables> {
    document = PhenotypesBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ContributorAvatarsDocument = gql`
    query ContributorAvatars($subscribable: SubscribableInput!) {
  contributors(subscribable: $subscribable) {
    editors {
      ...ContributorFields
    }
    curators {
      ...ContributorFields
    }
  }
}
    ${ContributorFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class ContributorAvatarsGQL extends Apollo.Query<ContributorAvatarsQuery, ContributorAvatarsQueryVariables> {
    document = ContributorAvatarsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourcePopoverDocument = gql`
    query SourcePopover($sourceId: Int!) {
  browseSources(id: $sourceId) {
    edges {
      node {
        ...sourcePopover
      }
    }
  }
}
    ${SourcePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourcePopoverGQL extends Apollo.Query<SourcePopoverQuery, SourcePopoverQueryVariables> {
    document = SourcePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseSourcesDocument = gql`
    query BrowseSources($first: Int, $last: Int, $before: String, $after: String, $sortBy: SourcesSort, $name: String, $year: Int, $sourceType: SourceSource, $citationId: Int, $author: String, $journal: String, $clinicalTrialId: Int) {
  browseSources(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    name: $name
    year: $year
    sourceType: $sourceType
    citationId: $citationId
    author: $author
    journal: $journal
    clinicalTrialId: $clinicalTrialId
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseSourceRowFields
      }
    }
  }
}
    ${BrowseSourceRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseSourcesGQL extends Apollo.Query<BrowseSourcesQuery, BrowseSourcesQueryVariables> {
    document = BrowseSourcesDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserPopoverDocument = gql`
    query UserPopover($userId: Int!) {
  user(id: $userId) {
    ...popoverUser
  }
}
    ${PopoverUserFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UserPopoverGQL extends Apollo.Query<UserPopoverQuery, UserPopoverQueryVariables> {
    document = UserPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseVariantGroupsDocument = gql`
    query BrowseVariantGroups($first: Int, $last: Int, $before: String, $after: String, $sortBy: VariantGroupsSort, $name: String, $geneNames: String, $variantNames: String) {
  browseVariantGroups(
    first: $first
    last: $last
    before: $before
    after: $after
    sortBy: $sortBy
    name: $name
    geneNames: $geneNames
    variantNames: $variantNames
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    totalCount
    filteredCount
    pageCount
    edges {
      cursor
      node {
        ...BrowseVariantGroupRowFields
      }
    }
  }
}
    ${BrowseVariantGroupRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseVariantGroupsGQL extends Apollo.Query<BrowseVariantGroupsQuery, BrowseVariantGroupsQueryVariables> {
    document = BrowseVariantGroupsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypePopoverDocument = gql`
    query VariantTypePopover($variantTypeId: Int!) {
  variantTypes(id: $variantTypeId) {
    edges {
      node {
        ...variantTypePopover
      }
    }
  }
}
    ${VariantTypePopoverFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypePopoverGQL extends Apollo.Query<VariantTypePopoverQuery, VariantTypePopoverQueryVariables> {
    document = VariantTypePopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypesBrowseDocument = gql`
    query VariantTypesBrowse($first: Int, $last: Int, $before: String, $after: String, $name: String, $soid: String, $sortBy: VariantTypeSort) {
  variantTypes(
    first: $first
    last: $last
    before: $before
    after: $after
    name: $name
    soid: $soid
    sortBy: $sortBy
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...VariantTypeBrowseTableRowFields
      }
    }
  }
}
    ${VariantTypeBrowseTableRowFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypesBrowseGQL extends Apollo.Query<VariantTypesBrowseQuery, VariantTypesBrowseQueryVariables> {
    document = VariantTypesBrowseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantPopoverDocument = gql`
    query VariantPopover($variantId: Int!) {
  variant(id: $variantId) {
    ...variantPopoverFields
  }
}
    ${VariantPopoverFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantPopoverGQL extends Apollo.Query<VariantPopoverQuery, VariantPopoverQueryVariables> {
    document = VariantPopoverDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantsMenuDocument = gql`
    query VariantsMenu($geneId: Int, $variantName: String, $evidenceStatusFilter: VariantDisplayFilter, $first: Int, $last: Int, $before: String, $after: String) {
  variants(
    geneId: $geneId
    name: $variantName
    evidenceStatusFilter: $evidenceStatusFilter
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    totalCount
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    edges {
      cursor
      node {
        ...menuVariant
      }
    }
  }
}
    ${MenuVariantFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantsMenuGQL extends Apollo.Query<VariantsMenuQuery, VariantsMenuQueryVariables> {
    document = VariantsMenuDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const BrowseVariantsDocument = gql`
    query BrowseVariants($variantName: String, $entrezSymbol: String, $diseaseName: String, $drugName: String, $variantTypeId: Int, $sortBy: VariantsSort, $first: Int, $last: Int, $before: String, $after: String) {
  browseVariants(
    variantName: $variantName
    entrezSymbol: $entrezSymbol
    diseaseName: $diseaseName
    drugName: $drugName
    variantTypeId: $variantTypeId
    sortBy: $sortBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    pageInfo {
      endCursor
      hasNextPage
      startCursor
      hasPreviousPage
    }
    edges {
      cursor
      node {
        id
        name
        evidenceScore
        evidenceItemCount
        geneId
        geneName
        diseases {
          id
          name
        }
        drugs {
          id
          name
        }
        assertionCount
      }
    }
    totalCount
    filteredCount
    pageCount
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class BrowseVariantsGQL extends Apollo.Query<BrowseVariantsQuery, BrowseVariantsQueryVariables> {
    document = BrowseVariantsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AddCommentDocument = gql`
    mutation AddComment($input: AddCommentInput!) {
  addComment(input: $input) {
    clientMutationId
    comment {
      ...commentListNode
    }
  }
}
    ${CommentListNodeFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AddCommentGQL extends Apollo.Mutation<AddCommentMutation, AddCommentMutationVariables> {
    document = AddCommentDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneRevisableFieldsDocument = gql`
    query GeneRevisableFields($geneId: Int!) {
  gene(id: $geneId) {
    id
    description
    sources {
      id
      sourceType
      citation
      citationId
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class GeneRevisableFieldsGQL extends Apollo.Query<GeneRevisableFieldsQuery, GeneRevisableFieldsQueryVariables> {
    document = GeneRevisableFieldsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SuggestGeneRevisionDocument = gql`
    mutation SuggestGeneRevision($input: SuggestGeneRevisionInput!) {
  suggestGeneRevision(input: $input) {
    clientMutationId
    gene {
      id
      revisions {
        totalCount
        edges {
          node {
            id
            revisionsetId
            createdAt
            fieldName
            currentValue
            suggestedValue
            linkoutData {
              name
              diffValue {
                ... on ObjectFieldDiff {
                  addedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  removedObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                  keptObjects {
                    id
                    displayName
                    displayType
                    entityType
                  }
                }
                ... on ScalarField {
                  value
                }
              }
            }
            revisor {
              id
              name
            }
            status
          }
        }
      }
    }
    results {
      id
      fieldName
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SuggestGeneRevisionGQL extends Apollo.Mutation<SuggestGeneRevisionMutation, SuggestGeneRevisionMutationVariables> {
    document = SuggestGeneRevisionDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CitationExistenceCheckDocument = gql`
    query CitationExistenceCheck($sourceType: SourceSource!, $citationId: Int!) {
  remoteCitation(sourceType: $sourceType, citationId: $citationId)
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CitationExistenceCheckGQL extends Apollo.Query<CitationExistenceCheckQuery, CitationExistenceCheckQueryVariables> {
    document = CitationExistenceCheckDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CreateSourceStubDocument = gql`
    mutation CreateSourceStub($input: AddRemoteCitationInput!) {
  addRemoteCitation(input: $input) {
    newSource {
      id
      citationId
      sourceType
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateSourceStubGQL extends Apollo.Mutation<CreateSourceStubMutation, CreateSourceStubMutationVariables> {
    document = CreateSourceStubDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const CitationTypeaheadDocument = gql`
    query CitationTypeahead($partialCitationId: Int!, $sourceType: SourceSource!) {
  sourceTypeahead(citationId: $partialCitationId, sourceType: $sourceType) {
    ...SourceTypeaheadResult
  }
}
    ${SourceTypeaheadResultFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class CitationTypeaheadGQL extends Apollo.Query<CitationTypeaheadQuery, CitationTypeaheadQueryVariables> {
    document = CitationTypeaheadDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const FlagEntityDocument = gql`
    mutation FlagEntity($input: FlagEntityInput!) {
  flagEntity(input: $input) {
    flag {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class FlagEntityGQL extends Apollo.Mutation<FlagEntityMutation, FlagEntityMutationVariables> {
    document = FlagEntityDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ResolveFlagDocument = gql`
    mutation ResolveFlag($input: ResolveFlagInput!) {
  resolveFlag(input: $input) {
    flag {
      id
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ResolveFlagGQL extends Apollo.Mutation<ResolveFlagMutation, ResolveFlagMutationVariables> {
    document = ResolveFlagDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerBaseDocument = gql`
    query ViewerBase {
  viewer {
    id
    username
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
    events(first: 1) {
      nodes {
        id
        createdAt
        organization {
          id
          name
          profileImagePath(size: 32)
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ViewerBaseGQL extends Apollo.Query<ViewerBaseQuery, ViewerBaseQueryVariables> {
    document = ViewerBaseDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ViewerFullDocument = gql`
    query ViewerFull {
  viewer {
    id
    username
    name
    email
    bio
    url
    role
    profileImagePath(size: 32)
    organizations {
      id
      name
      profileImagePath(size: 32)
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ViewerFullGQL extends Apollo.Query<ViewerFullQuery, ViewerFullQueryVariables> {
    document = ViewerFullDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssertionDetailDocument = gql`
    query AssertionDetail($assertionId: Int!) {
  assertion(id: $assertionId) {
    ...AssertionDetailFields
  }
}
    ${AssertionDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionDetailGQL extends Apollo.Query<AssertionDetailQuery, AssertionDetailQueryVariables> {
    document = AssertionDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const AssertionSummaryDocument = gql`
    query AssertionSummary($assertionId: Int!) {
  assertion(id: $assertionId) {
    ...AssertionSummaryFields
  }
}
    ${AssertionSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class AssertionSummaryGQL extends Apollo.Query<AssertionSummaryQuery, AssertionSummaryQueryVariables> {
    document = AssertionSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const ClinicalTrialDetailDocument = gql`
    query ClinicalTrialDetail($clinicalTrialId: Int!) {
  clinicalTrial(id: $clinicalTrialId) {
    id
    name
    nctId
    description
    url
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class ClinicalTrialDetailGQL extends Apollo.Query<ClinicalTrialDetailQuery, ClinicalTrialDetailQueryVariables> {
    document = ClinicalTrialDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DiseaseDetailDocument = gql`
    query DiseaseDetail($diseaseId: Int!) {
  disease(id: $diseaseId) {
    id
    name
    doid
    diseaseUrl
    displayName
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DiseaseDetailGQL extends Apollo.Query<DiseaseDetailQuery, DiseaseDetailQueryVariables> {
    document = DiseaseDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const DrugDetailDocument = gql`
    query DrugDetail($drugId: Int!) {
  drug(id: $drugId) {
    id
    name
    ncitId
    drugUrl
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DrugDetailGQL extends Apollo.Query<DrugDetailQuery, DrugDetailQueryVariables> {
    document = DrugDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceDetailDocument = gql`
    query EvidenceDetail($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...EvidenceDetailFields
  }
}
    ${EvidenceDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceDetailGQL extends Apollo.Query<EvidenceDetailQuery, EvidenceDetailQueryVariables> {
    document = EvidenceDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const EvidenceSummaryDocument = gql`
    query EvidenceSummary($evidenceId: Int!) {
  evidenceItem(id: $evidenceId) {
    ...EvidenceSummaryFields
  }
}
    ${EvidenceSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class EvidenceSummaryGQL extends Apollo.Query<EvidenceSummaryQuery, EvidenceSummaryQueryVariables> {
    document = EvidenceSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneDetailDocument = gql`
    query GeneDetail($geneId: Int!) {
  gene(id: $geneId) {
    ...GeneDetailFields
  }
}
    ${GeneDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GeneDetailGQL extends Apollo.Query<GeneDetailQuery, GeneDetailQueryVariables> {
    document = GeneDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GeneRevisionsDocument = gql`
    query GeneRevisions($geneId: Int!, $first: Int, $last: Int, $before: String, $after: String, $fieldName: String, $originatingUserId: Int) {
  gene(id: $geneId) {
    id
    revisions(
      first: $first
      last: $last
      before: $before
      after: $after
      fieldName: $fieldName
      originatingUserId: $originatingUserId
    ) {
      totalCount
      uniqueRevisors {
        username
        id
        profileImagePath(size: 32)
      }
      revisedFieldNames {
        name
        displayName
      }
      edges {
        node {
          id
          revisionsetId
          createdAt
          fieldName
          currentValue
          suggestedValue
          linkoutData {
            name
            diffValue {
              ... on ObjectFieldDiff {
                addedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                removedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                keptObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
              }
              ... on ScalarField {
                value
              }
            }
          }
          revisor {
            id
            name
          }
          status
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class GeneRevisionsGQL extends Apollo.Query<GeneRevisionsQuery, GeneRevisionsQueryVariables> {
    document = GeneRevisionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const GenesSummaryDocument = gql`
    query GenesSummary($geneId: Int!) {
  gene(id: $geneId) {
    ...GeneSummaryFields
  }
}
    ${GeneSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class GenesSummaryGQL extends Apollo.Query<GenesSummaryQuery, GenesSummaryQueryVariables> {
    document = GenesSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationDetailDocument = gql`
    query OrganizationDetail($organizationId: Int!) {
  organization(id: $organizationId) {
    ...OrganizationDetailFields
  }
}
    ${OrganizationDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationDetailGQL extends Apollo.Query<OrganizationDetailQuery, OrganizationDetailQueryVariables> {
    document = OrganizationDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationGroupsDocument = gql`
    query OrganizationGroups($organizationId: Int!) {
  organization(id: $organizationId) {
    subGroups {
      ...OrganizationGroupsFields
    }
  }
}
    ${OrganizationGroupsFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationGroupsGQL extends Apollo.Query<OrganizationGroupsQuery, OrganizationGroupsQueryVariables> {
    document = OrganizationGroupsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const OrganizationMembersDocument = gql`
    query OrganizationMembers($organizationId: Int!) {
  organization(id: $organizationId) {
    members {
      edges {
        cursor
        node {
          ...OrganizationMembersFields
        }
      }
    }
  }
}
    ${OrganizationMembersFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class OrganizationMembersGQL extends Apollo.Query<OrganizationMembersQuery, OrganizationMembersQueryVariables> {
    document = OrganizationMembersDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const PhenotypeDetailDocument = gql`
    query PhenotypeDetail($phenotypeId: Int!) {
  phenotype(id: $phenotypeId) {
    id
    name
    hpoId
    url
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class PhenotypeDetailGQL extends Apollo.Query<PhenotypeDetailQuery, PhenotypeDetailQueryVariables> {
    document = PhenotypeDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourceDetailDocument = gql`
    query SourceDetail($sourceId: Int!) {
  source(id: $sourceId) {
    ...SourceDetailFields
  }
}
    ${SourceDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourceDetailGQL extends Apollo.Query<SourceDetailQuery, SourceDetailQueryVariables> {
    document = SourceDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const SourceSummaryDocument = gql`
    query SourceSummary($sourceId: Int!) {
  source(id: $sourceId) {
    ...SourceSummaryFields
  }
}
    ${SourceSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class SourceSummaryGQL extends Apollo.Query<SourceSummaryQuery, SourceSummaryQueryVariables> {
    document = SourceSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const UserDetailDocument = gql`
    query UserDetail($userId: Int!) {
  user(id: $userId) {
    ...UserDetailFields
  }
}
    ${UserDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class UserDetailGQL extends Apollo.Query<UserDetailQuery, UserDetailQueryVariables> {
    document = UserDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantGroupDetailDocument = gql`
    query VariantGroupDetail($variantGroupId: Int!) {
  variantGroup(id: $variantGroupId) {
    ...VariantGroupDetailFields
  }
}
    ${VariantGroupDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantGroupDetailGQL extends Apollo.Query<VariantGroupDetailQuery, VariantGroupDetailQueryVariables> {
    document = VariantGroupDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantGroupRevisionsDocument = gql`
    query VariantGroupRevisions($variantGroupId: Int!, $first: Int, $last: Int, $before: String, $after: String, $fieldName: String, $originatingUserId: Int) {
  variantGroup(id: $variantGroupId) {
    id
    revisions(
      first: $first
      last: $last
      before: $before
      after: $after
      fieldName: $fieldName
      originatingUserId: $originatingUserId
    ) {
      totalCount
      uniqueRevisors {
        username
        id
        profileImagePath(size: 32)
      }
      revisedFieldNames {
        name
        displayName
      }
      edges {
        node {
          id
          revisionsetId
          createdAt
          fieldName
          currentValue
          suggestedValue
          linkoutData {
            name
            diffValue {
              ... on ObjectFieldDiff {
                addedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                removedObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
                keptObjects {
                  id
                  displayName
                  displayType
                  entityType
                }
              }
              ... on ScalarField {
                value
              }
            }
          }
          revisor {
            id
            name
          }
          status
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantGroupRevisionsGQL extends Apollo.Query<VariantGroupRevisionsQuery, VariantGroupRevisionsQueryVariables> {
    document = VariantGroupRevisionsDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantGroupsSummaryDocument = gql`
    query VariantGroupsSummary($variantGroupId: Int!) {
  variantGroup(id: $variantGroupId) {
    ...VariantGroupSummaryFields
  }
}
    ${VariantGroupSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantGroupsSummaryGQL extends Apollo.Query<VariantGroupsSummaryQuery, VariantGroupsSummaryQueryVariables> {
    document = VariantGroupsSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantTypeDetailDocument = gql`
    query VariantTypeDetail($variantTypeId: Int!) {
  variantType(id: $variantTypeId) {
    id
    name
    soid
    description
    url
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantTypeDetailGQL extends Apollo.Query<VariantTypeDetailQuery, VariantTypeDetailQueryVariables> {
    document = VariantTypeDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantDetailDocument = gql`
    query VariantDetail($variantId: Int!) {
  variant(id: $variantId) {
    ...VariantDetailFields
  }
}
    ${VariantDetailFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantDetailGQL extends Apollo.Query<VariantDetailQuery, VariantDetailQueryVariables> {
    document = VariantDetailDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }
export const VariantSummaryDocument = gql`
    query VariantSummary($variantId: Int!) {
  variant(id: $variantId) {
    ...VariantSummaryFields
  }
}
    ${VariantSummaryFieldsFragmentDoc}`;

  @Injectable({
    providedIn: 'root'
  })
  export class VariantSummaryGQL extends Apollo.Query<VariantSummaryQuery, VariantSummaryQueryVariables> {
    document = VariantSummaryDocument;
    
    constructor(apollo: Apollo.Apollo) {
      super(apollo);
    }
  }